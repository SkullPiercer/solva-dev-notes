Системы, обеспечивающие интеграцию и доставку кода (CI/CD), являются неотъемлемой частью современного процесса разработки программного обеспечения. Это комплекс взаимосвязанных автоматизированных процедур, направленных на то, чтобы ускорить и упростить весь цикл создания продукта.

Ключевым элементом является практика **Continuous Integration** (непрерывной интеграции) — подход, при котором изменения, внесённые разработчиками, автоматически объединяются в общий репозиторий и проходят проверку на ошибки. Такая стратегия позволяет выявлять проблемы на раннем этапе, минимизируя время на их исправление и упрощая внедрение новых функций.

В типичной схеме работы запуск CI/CD начинается с события **git push**. Как только изменения попадают в репозиторий, автоматическая система (пайплайн) начинает выполнять задачи:

1. Запуск этапа CI — тестирование интеграции нового кода на выделенном сервере.
    
2. Если все тесты прошли успешно — проект считается готовым к деплою.

---

### Популярные сервисы для CI/CD

- **GitLab CI** — встроенный в GitLab облачный инструмент. Есть ограниченное бесплатное время работы, но интеграции с GitHub нет, поэтому в нашем случае не подходит.
    
- **Bitbucket Pipelines** — аналогичный облачный сервис от Bitbucket, также без интеграции с GitHub.
    
- **Azure Pipelines** — решение от Microsoft с поддержкой GitHub, пробным периодом и ограниченным бесплатным временем выполнения.
    
- **CircleCI** — облачная платформа с поддержкой GitHub и бесплатными лимитами.
    
- **Travis CI** — сервис с поддержкой GitHub, но без бесплатных тарифов.
    
- **GitHub Actions** — нативный инструмент GitHub. Предоставляет бесплатное время выполнения задач для приватных репозиториев (в среднем 200–400 запусков тестов и сборки).

---

### Основные термины GitHub Actions

- **Workflow** — сценарий (цепочка шагов), описывающий процесс CI/CD.
    
- **Trigger** — событие, которое запускает выполнение workflow (например, `push` в репозиторий).
    
- **Jobs** — задачи, входящие в workflow, выполняемые в определённой последовательности.
    
- **Runner** — сервер, на котором выполняются все задачи workflow.

Весь процесс стартует автоматически при срабатывании заданного триггера.

---

### Структура файла Workflow

Любой workflow в GitHub Actions включает три обязательных блока:

- **name** — название процесса, отображаемое в интерфейсе GitHub.
    
- **on** — список событий-триггеров, которые запускают workflow (может быть несколько).
    
- **jobs** — набор действий, выполняемых после срабатывания триггера.

---
# Рассмотрим на практике
Структура репозитория
```
ci-demo/
│
├── .github/
│   └── workflows/
│       └── ci.yml
│
├── app.py
├── test_app.py
├── requirements.txt
└── README.md
```

`app.py` — простое приложение
```
def add(a: int, b: int) -> int:
    return a + b


if __name__ == "__main__":
    print(add(2, 3))
```

`test_app.py` — тест
```
from app import add


def test_add():
    assert add(2, 3) == 5
    assert add(-1, 1) == 0
```

requirements.txt
```
pytest
```

`.github/workflows/ci.yml` — GitHub Actions конфиг
```
name: Python CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run tests
        run: pytest
```

---
Разберём workflow построчно так, чтобы было понятно, что и зачем делает каждая строчка.

```
name: Python CI
```
- **`name`** — имя workflow, которое будет отображаться во вкладке **Actions** в GitHub.
    
- Здесь это `"Python CI"` — чтобы сразу видно было, что это пайплайн для тестирования Python-кода.

```
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
```
- **`on:`** — определяет, при каких событиях запускать workflow.
    
- `push` — запуск при каждом пуше в репозиторий.
    
    - `branches: [ main ]` — ограничиваем запуск только при пуше в ветку `main`.
        
- `pull_request` — запуск при создании или обновлении pull request.
    
    - `branches: [ main ]` — будет работать, только если PR направлен в `main`.

> То есть тесты запустятся либо при прямом пуше в `main`, либо при попытке слить изменения через PR в `main`.

```
jobs:
```
- Раздел, где мы описываем **задачи (jobs)**, которые должен выполнить GitHub Actions.
    
- В одном workflow может быть несколько jobs (например, `test`, `lint`, `deploy`).

```
  test:
```
- Имя конкретного job — здесь `"test"`.
    
- Это название можно будет увидеть в логах выполнения Actions.

```
    runs-on: ubuntu-latest
```
- Указывает, на какой операционной системе будет выполняться job.
    
- `ubuntu-latest` — свежая версия Ubuntu, которую GitHub предоставляет как среду выполнения.
    
- GitHub также поддерживает `windows-latest` и `macos-latest`.

```
    steps:
```
- Список шагов (steps), которые будут выполняться в рамках этого job.
    
- Каждый шаг выполняется по очереди.

```
      - name: Checkout code
        uses: actions/checkout@v4
```
- `name` — описание шага (появится в логах).
    
- `uses: actions/checkout@v4` — официальный экшен GitHub, который **клонирует твой репозиторий** в рабочую директорию на виртуальной машине.
    
- Без этого кода не будет в среде, и тестировать будет нечего.

```
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
```
- `uses: actions/setup-python@v5` — официальный экшен GitHub для установки Python.
    
- `with:` — параметры экшена.
    
    - `python-version: '3.12'` — указываем, какую версию Python поставить.
        
- Этот шаг делает виртуальную машину готовой к запуску Python-кода.

```
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
```
- `run:` — указывает команды, которые нужно выполнить.
    
- `|` — означает многострочную команду (bash-скрипт).
    
- `python -m pip install --upgrade pip` — обновляем `pip` до последней версии.
    
- `pip install -r requirements.txt` — устанавливаем зависимости проекта из файла `requirements.txt`.

```
      - name: Run tests
        run: pytest
```
- Запускаем тесты с помощью `pytest`.
    
- Если хоть один тест упадёт, весь job (и workflow) завершится с ошибкой.

---
# Сценарий: ты сделал изменения и запушил

**Ты локально меняешь код** (например, в `app.py` исправил что-то). И выполнил:
```
git add .
git commit -m "Fix app"
git push origin main
```

GitHub получает событие `push` в ветку `main`.
Срабатывает триггер `on: push: branches: [ main ]` в твоём `ci.yml`.

---
### **Шаг 1 — GitHub Actions поднимает виртуальную машину**

- Выбирается `ubuntu-latest` — это чистая среда с установленными базовыми утилитами, но **без твоего кода** и без Python 3.12.
    
- Создаётся рабочая директория, куда позже скачается твой репозиторий.
---
### **Шаг 2 — Checkout code**
```
- name: Checkout code
  uses: actions/checkout@v4
```

- Экшен **клонирует твой репозиторий** на виртуалку.
    
- Теперь все файлы проекта доступны на этой машине.
    
- Рабочая папка выглядит примерно так:
```
/home/runner/work/ci-demo/ci-demo/
```

---
### **Шаг 3 — Установка Python**
```
- name: Set up Python
  uses: actions/setup-python@v5
  with:
    python-version: '3.12'
```

- Ставится Python 3.12 (если его нет).
    
- Добавляется в `PATH`, чтобы команды `python` и `pip` работали.
    
- Если ты в будущем добавишь **кэширование Python**, то этот шаг может быть быстрее.

---
### **Шаг 4 — Установка зависимостей**
```
- name: Install dependencies
  run: |
    python -m pip install --upgrade pip
    pip install -r requirements.txt
```
- Обновляется `pip`.
    
- Устанавливаются все зависимости, указанные в `requirements.txt`.
    
- Например:
```
Collecting pytest
Downloading pytest-8.2.0-py3-none-any.whl
Installing collected packages: ...
```

---
### **Шаг 5 — Запуск тестов**
```
- name: Run tests
  run: pytest
```
- Запускается `pytest`, который ищет тесты в проекте.
    
- Он проверяет, проходят ли они.
    
- Если хотя бы один тест упадёт:
    
    - В логах будет видно, что именно сломалось.
        
    - Job завершится со статусом ❌ (failure).
        
    - Workflow в целом будет считаться неуспешным.
        
- Если все тесты пройдут:
    
    - Job завершится ✅ (success).

---
### **Шаг 6 — Завершение**

- GitHub Actions убивает виртуалку, освобождая ресурсы.
    
- Вкладка **Actions** в репозитории покажет твой прогон:
    
    - 🟢 зелёный чек — тесты пройдены, всё ок.
        
    - 🔴 красный крест — тесты упали.
        
- Если у тебя были **PR**, то GitHub добавит статус проверки в PR.

---
**Важный момент:**  
Если ты **внесёшь изменения только в `README.md`**, то всё равно запустится CI, потому что в триггере нет условия "только при изменении кода". Это можно оптимизировать.