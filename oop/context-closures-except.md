## Контекстные менеджеры
**Что такое контекстный менеджер?**  
Контекстный менеджер — это механизм, который позволяет организовать выполнение кода в специально подготовленной среде, называемой контекстом.

Он особенно полезен в ситуациях, когда перед началом работы необходимо выполнить подготовительные действия, а после — корректно завершить процесс и освободить ресурсы.

Например, при работе с файлами:
- сначала файл открывается (этап подготовки);
    
- затем с ним происходят нужные действия;
    
- в конце — файл обязательно закрывается (этап завершения работы).

Похожий подход используется и при работе с базами данных:
- открывается соединение;
    
- выполняются необходимые запросы;
    
- затем соединение закрывается.

Для запуска кода внутри контекстного менеджера используют конструкцию `with`.
```
with ContextManager as cm:
    # код, который будет выполнен в контексте КМ
```
**Способы создания пользовательского контекстного менеджера**

Пользовательский контекстный менеджер можно реализовать двумя основными способами:
- через класс,
    
- или с использованием функций.

**Создание контекстного менеджера с помощью класса**

При реализации контекстного менеджера на основе класса необходимо определить два специальных метода: `__enter__` и `__exit__`.
- Метод `__enter__` отвечает за действия, которые должны быть выполнены при входе в контекст, до начала основной работы.
    
- Метод `__exit__`, напротив, срабатывает при выходе из контекста и служит для завершения работы с ресурсом, включая обработку возможных ошибок.

Контекстный менеджер также способен отслеживать исключения, возникающие внутри блока `with`. Он может как обработать некоторые исключения, так и при необходимости подавить их, чтобы выполнение программы продолжилось.

Рассмотрим пример контекстного менеджера для работы с файлами. Класс, реализующий его, получает путь к файлу и режим открытия (например, чтение или запись).  
В `__enter__` файл открывается, а в `__exit__` — обрабатываются возможные исключения и файл закрывается.

Метод `__exit__` принимает три аргумента:
- `exc_type` — тип возникшего исключения,
    
- `exc_value` — объект исключения, содержащий его описание,
    
- `exc_traceback` — объект с информацией о месте, где произошла ошибка.

Если `__exit__` возвращает `True`, это означает, что исключение было обработано, и выполнение продолжается без ошибок. Возврат любого другого значения приведёт к повторному возбуждению исключения.

```
class OpenFile(object):
    
    def __init__(self, file, flag):
        self.file = file
        self.flag = flag

    def __enter__(self):
        try:
            self.fp = open(self.file, self.flag)
        except IOError:
            self.fp = open(self.file, 'w')
        return self.fp

    def __exit__(self, exp_type, exp_value, exc_traceback):
        if exp_type is IOError:
            self.fp.close()  # Закрываем файл в случае ошибки ввода-вывода.
            # Возвращаем True, чтобы обработать ошибку:
            return True
        self.fp.close()  # Закрываем файл.

with OpenFile('hello_bro.txt', 'w') as fp:
    fp.write('Здравствуй, брат!')
```
Если в процессе выполнения возникнет исключение типа `IOError`, контекстный менеджер его перехватит в методе `__exit__()`, прекратит дальнейшее выполнение и вернёт `True`, тем самым подавив исключение. Все остальные ошибки обрабатываться не будут и будут переданы дальше.

Независимо от того, произошло ли исключение или код выполнился успешно, при выходе из блока автоматически вызывается `self.fp.close()` для корректного закрытия файла.

**Создание контекстного менеджера с помощью функции**

Альтернативный способ реализации контекстного менеджера — с помощью функции-генератора. Для этого используется декоратор `@contextmanager`, предоставляемый модулем `contextlib`.
```
from contextlib import contextmanager

@contextmanager
def test_func():
    print('Действия соответствующие методу __enter__')
    yield 'Код из блока with выполнится тут'
    print('Действия соответствующие методу __exit__')

with test_func() as f:
    print(f)
```
Перед ключевым словом `yield` в функции-контекстном менеджере размещается логика, аналогичная `__enter__`, — это подготовка ресурсов. После `yield` следует код, который выполняется при выходе из контекста, аналогично `__exit__`.

**Стандартные контекстные менеджеры в Python**

Хотя мы только что рассмотрели, как самостоятельно реализовать контекстный менеджер для работы с файлами, на самом деле, в Python уже предусмотрены встроенные решения.

Функция `open()` — яркий пример встроенного контекстного менеджера.

Если использовать её без `with`, необходимо вручную управлять ресурсами: открывать файл перед операциями и обязательно закрывать его после — что увеличивает риск ошибок и утечек ресурсов.
```
f = open('hello_bro.txt', 'w')
f.write('Здравствуй, брат!')
f.close()
```
А при использовании контекстного менеджера те же действия выполняются гораздо проще и чище с точки зрения кода.

Благодаря конструкции `with` отпадает необходимость вручную закрывать файл — всё происходит автоматически, что делает код не только короче, но и безопаснее.
```
with open('hello_bro.txt', 'w') as f:
    f.write('Здравствуй, брат!')
```

# Lambda-функции
**Лямбда-функции**

Лямбда-функции в Python — это функции без имени, которые ещё называют анонимными. Для их создания применяется ключевое слово `lambda`.

Как и обычные функции, они могут принимать аргументы, но чаще всего используются для кратких одноразовых операций.

Общий синтаксис объявления выглядит следующим образом:
```
lambda параметры_через_запятую: выполняемое_функцией_выражение
```
Лямбда-функции по своей сути близки к обычным функциям в Python.

Если функция выполняет всего одно действие, её вполне можно определить в одну строку, так же как и лямбду — разница лишь в синтаксисе.
```
def имя_функции(параметры_через_запятую): выполняемое_функцией_выражение
```
**Основные отличия лямбда-функций от обычных**
- Обычные функции объявляются с помощью ключевого слова `def` и всегда имеют имя, тогда как лямбда-функции создаются с помощью `lambda` и могут быть безымянными.
    
- В теле лямбда-функции можно разместить только одно выражение — составные блоки кода в них не поддерживаются.
    
- Ключевое слово `return` в лямбда-функциях не используется: они автоматически возвращают результат выражения.

Внутри лямбды можно использовать, например:
- простые математические и логические выражения, вроде `a + b` или `a > b`;
    
- вызовы других функций, например `sum(a, b)`.

Пример: лямбда-функция, принимающая `x` и `y`, возвращает их произведение.
```
x = lambda x, y: x * y
print(x(5, 4))

# 20
```
Аргументы можно передать лямбда-функции сразу в момент её создания. Для этого саму функцию помещают в скобки, а сразу после — в той же строке — указывают аргументы, тоже в скобках.
```
x = (lambda x, y: x * y)(2, 7)
print(x)

# Будет напечатано: 14
```
Ту же запись можно сделать и без применения дополнительной переменной:
```
print((lambda x, y: x * y) (2, 7))

# Будет напечатано: 14
```
Когда стоит использовать лямбда-функции:

Лямбда-функции отлично подходят для простых функций, которые не предполагается использовать повторно. Вот ещё несколько причин применить лямбда-функции:
- Когда функция выполняет понятное и простое действие, и ей не требуется имя.
    
- Если использование лямбда-функции делает код более читаемым по сравнению с объявлением обычной функции.
    
- Когда в коде отсутствует уже определённая именованная функция для нужной операции.

### Что такое замыкания?

**Замыкание** — это функция, которая "запоминает" переменные из своей внешней области видимости, даже если эта внешняя функция уже завершила своё выполнение.

То есть, если у нас есть функция внутри другой функции, и внутренняя функция использует переменные внешней функции, то при возвращении внутренней функции мы получаем замыкание.

Пример замыкания
```
def outer_func(x):
    def inner_func(y):
        return x + y  # используем переменную x из внешней функции
    return inner_func

closure_func = outer_func(10)
print(closure_func(5))  # Выведет 15
```
Здесь:
- `outer_func` — внешняя функция, принимает `x`
    
- `inner_func` — внутренняя функция, использует `x` из внешней области видимости
    
- При вызове `outer_func(10)` мы получаем функцию `inner_func`, которая "запомнила" `x=10`
    
- Потом вызываем `closure_func(5)` — она использует `x=10` и добавляет 5, получается 15
### Для чего нужны замыкания?
1. **Инкапсуляция данных** — можно хранить состояние, не используя глобальные переменные и не создавая классы.
    
2. **Создание фабрик функций** — когда нужно создавать похожие функции с разными параметрами, не повторяя код.
    
3. **Ленивые вычисления** — можно создавать функции, которые помнят данные для дальнейшего использования.
    
4. **Приватные переменные** — замыкания позволяют скрыть данные от внешнего кода, предоставляя только функции для работы с ними.
### Важное

- Замыкание "запоминает" **ссылку** на переменные, а не их значения, так что если переменная изменяется, замыкание увидит новое значение.
    
- Замыкания часто используют в функциональном программировании.
### Пример с изменением переменной:
```
def outer():
    x = 5
    def inner():
        return x
    x = 10
    return inner

func = outer()
print(func())  # Выведет 10, потому что x был изменён до возврата
```
### Задача: Счётчик вызовов функции

Представь, что тебе нужно сделать функцию, которая считает, сколько раз она была вызвана. Можно сделать это с помощью глобальной переменной, но это не всегда удобно и чисто.

С помощью **замыкания** можно сделать такую функцию, которая хранит счётчик вызовов в своей "внешней" области и обновляет его при каждом вызове.

Реализация через замыкание:
```
def make_counter():
    count = 0  # переменная-счётчик

    def counter():
        nonlocal count  # объявляем, что хотим использовать переменную из внешней области
        count += 1
        return count

    return counter

my_counter = make_counter()

print(my_counter())  # 1
print(my_counter())  # 2
print(my_counter())  # 3
```
### Объяснение:
- `make_counter` — внешняя функция, которая создаёт и инициализирует переменную `count`.
    
- `counter` — внутренняя функция, которая увеличивает `count` на 1 и возвращает его.
    
- `nonlocal count` говорит, что мы хотим изменить переменную `count`, объявленную во внешней функции (иначе Python создаст локальную переменную `count`).
    
- Когда мы вызываем `make_counter()`, получаем функцию-счётчик, которая помнит своё текущее значение `count`.
    
- Каждый вызов `my_counter()` увеличивает и возвращает текущее значение счётчика.
### Для чего это удобно?
- Не нужно создавать класс со свойством-счётчиком — меньше кода.
    
- Логика и состояние хранятся вместе в замыкании.
    
- Несколько счётчиков — просто создаёшь несколько замыканий:
```
counter1 = make_counter()
counter2 = make_counter()

print(counter1())  # 1
print(counter1())  # 2
print(counter2())  # 1
```

# Обработка ошибок | Кастомные исключения
**Что такое исключения в Python**

Исключения в Python — это события, возникающие в процессе выполнения программы, которые указывают на то, что произошла непредвиденная ситуация или ошибка. Они сигнализируют о том, что что-то пошло не так, как предполагалось. Причины возникновения исключений могут быть разными, например:
- ошибка в самом коде,
    
- некорректные или неподходящие входные данные,
    
- недостаток системных ресурсов, например памяти,
    
- и другие обстоятельства, которые мешают нормальной работе программы.

Важно понимать, что исключение — это не то же самое, что ошибка. Исключение может быть следствием ошибки, но само по себе оно является механизмом, который сообщает о проблеме во время выполнения программы.

Ошибка — более широкое понятие, которое описывает неправильное состояние программы, способное привести к её аварийному завершению, если её не обработать.

Исключения же служат инструментом для обработки таких ситуаций. Благодаря им можно «поймать» ошибку, управлять поведением программы при возникновении проблемы и предотвратить её внезапное завершение. Таким образом, использование исключений помогает сделать программу более устойчивой, контролируемой и предсказуемой.

**Встроенные исключения в Python**

В языке Python предусмотрено множество встроенных исключений, которые сигнализируют о различных ошибках или необычных ситуациях, возникающих во время работы программы.

Вот несколько распространённых исключений, которые часто встречаются в практике:
- **ZeroDivisionError** — возникает при попытке разделить число на ноль.
    
- **ImportError** — возникает, если Python не удаётся найти или загрузить указанный модуль или пакет.
    
- **IndexError** — появляется, когда индекс выходит за пределы допустимого диапазона для последовательности (например, списка или строки).
    
- **KeyError** — возникает, если в словаре пытаются получить доступ к отсутствующему ключу.
    
- **SyntaxError** — сигнализирует о наличии ошибки в синтаксисе кода.
    
- **TypeError** — возникает, когда операция или функция применяется к объекту неподходящего типа.
    
- **ValueError** — появляется, когда функция получает аргумент правильного типа, но с недопустимым значением.

Кроме использования этих стандартных исключений, разработчики могут создавать собственные типы исключений. Для этого достаточно определить новый класс, который наследуется от базового класса `Exception`. Это позволяет точнее описывать специфические ошибки, возникающие в вашей программе.

**Как создать собственное исключение**

Чтобы определить своё собственное исключение, необходимо выполнить следующие шаги:
1. Создать новый класс, который наследует встроенный класс `Exception` или один из его потомков. Подклассы — это более конкретные типы исключений, например, `SyntaxError`, `TypeError`, `IndexError`. Название нового класса придумывает разработчик, при этом рекомендуется, чтобы имя заканчивалось на `Error`.
    
2. При желании можно переопределить метод `__str__()`, чтобы выводить понятное и информативное сообщение о причине возникновения исключения.

```
class MyZeroError(ZeroDivisionError):
    def __str__(self):
        return 'Эй! Тут у нас на ноль не делят'

  

def divide(a, b):
    if b == 0:
        raise MyZeroError
    return a / b

print(divide(10, 2))
5.0

print(divide(10, 0))
MyZeroError: Эй! Тут у нас на ноль не делят
```
### Обработка исключений в Python

Программисты часто стараются заранее предусмотреть возможные ошибки в коде. Например, перед тем как делить число, можно проверить, не равно ли оно нулю, чтобы избежать ошибки деления на ноль. Однако такой подход не всегда удобен и не всегда возможен.

В Python есть другой способ — механизм обработки исключений. Чтобы программа не прерывалась при возникновении ошибки, потенциально опасный код помещают в специальный блок `try`. Если внутри этого блока происходит исключение, выполнение программы не останавливается, а управление передаётся в соответствующий блок `except`, где можно написать код для обработки ошибки.

Механизм обработки исключений использует несколько ключевых слов:
- **try** — блок с кодом, который может вызвать исключение.
    
- **except** — блок для обработки исключений, возникающих в `try`.
    
- **else** — выполняется, если код в `try` завершился без ошибок.
    
- **finally** — выполняется всегда, независимо от того, было ли исключение или нет (например, для очистки ресурсов).

Таким образом, структура try-except позволяет «укротить» исключения, сделать работу программы более надёжной и управляемой.
```
  try:
      # Блок кода, который может вызвать исключение.
```
Блок `except` («исключая») обрабатывает исключение, возникшее в блоке `try`.
```
  except SomeException as e:
      # Обработка исключения.
```
`SomeException` — это конкретный тип исключения, который вы хотите обработать. Можно указать несколько блоков `except` для обработки разных типов исключений.
```
  except TypeError:
      # Обработка TypeError.
  except ValueError:
      # Обработка ValueError.
  except Exception as e:
      # Обработка остальных исключений.
      # Доступ к объекту исключения в коде программы
      # можно получить через переменную 'e'.
```
Блок `else` («иначе») выполняется, если в блоке `try` не возникло исключений. Это хорошее место для кода, который должен выполняться **только в том случае**, когда операции в `try` прошли успешно.
```
  else:
      # Блок кода, который выполняется, если исключение не возникло.
```
Блок кода `finally` («в любом случае») выполняется независимо от того, произошло исключение или нет.
```
finally: # Блок кода, который выполняется всегда.
```
Пример «укрощения» исключения:
```
try:
    # Блок кода, который может вызвать исключение.
    result = 10 / 0
except ZeroDivisionError as e:
    # Обработка исключения при делении на ноль.
    print(f'Ошибка: {e}')
else:
    # Блок кода, который выполняется, если исключение не возникло.
    print('Операция выполнена успешно.')
finally:
    # Блок кода, который выполняется всегда.
    print('Программа завершила свою работу.')
```
Если во время выполнения кода в блоке `try` произойдёт деление на ноль, сначала будет выполнен код, находящийся в блоке `except`, который обрабатывает это исключение. После этого независимо от результата работы блока `except` будет выполнен блок `finally`.

Если же исключение в блоке `try` не возникнет, тогда сначала выполнится блок `else`, который содержит код, запускающийся при отсутствии ошибок, а затем снова выполнится блок `finally`.

Стоит отметить, что блоки `else` и `finally` не являются обязательными. Если их не использовать, то после выполнения кода в блоке `try` (или после обработки исключения в блоке `except`) программа продолжит своё выполнение дальше по основному потоку.

### Пакеты и модули в Python

В Python **модуль** — это обычный файл с расширением `.py`, в котором может содержаться любой код: функции, классы, переменные и выполняемые инструкции. Модули используются для организации кода и его повторного использования. Например, если у вас есть набор функций, связанных с обработкой данных, вы можете поместить их в отдельный модуль и импортировать при необходимости.

**Пакет** — это специальный каталог, который служит для группировки связанных модулей. Пакет позволяет структурировать программу в виде иерархии модулей. Внутри пакета могут находиться другие подпакеты и модули, что упрощает организацию большого проекта.

### Файл `__init__.py`
Для того чтобы каталог в Python считался пакетом, в нем обычно создают файл с именем `__init__.py`. Этот файл может быть пустым или содержать код, который будет выполняться при импорте пакета.

Основные задачи `__init__.py`:
- Помечать каталог как пакет, чтобы Python мог распознавать его как таковой.
    
- Выполнять инициализацию пакета, например, импортировать важные модули или определить переменные.
    
- Контролировать, что именно будет доступно при импорте пакета.

Если файла `__init__.py` нет, в новых версиях Python каталог всё равно может рассматриваться как пакет (это называется namespace package), но традиционно и для совместимости с более старыми версиями файл создают.
### Файл `__main__.py`

Файл `__main__.py` используется для того, чтобы сделать пакет исполняемым. Если в каталоге пакета есть этот файл, то можно запустить пакет как программу с помощью команды:
```
python -m имя_пакета
```
При этом интерпретатор Python выполнит код, который находится в `__main__.py`.

Это удобно для организации приложений, которые имеют структуру из нескольких модулей, но при запуске выполняют определённый главный сценарий из `__main__.py`.

Пример пакета
Создадим структуру каталогов:
```
mypackage/
    __init__.py
    operations.py
    __main__.py
```

Файл `operations.py`:
```
# operations.py

def multiply(a, b):
    return a * b

def divide(a, b):
    if b == 0:
        raise ValueError("Деление на ноль невозможно")
    return a / b
```

Файл `__init__.py`:
```
# __init__.py

from .operations import multiply, divide

__all__ = ['multiply', 'divide']
```

Файл `__main__.py`:
```
# __main__.py

from . import multiply, divide

def main():
    print("Умножение 6 на 7 =", multiply(6, 7))
    print("Деление 42 на 7 =", divide(42, 7))

if __name__ == "__main__":
    main()
```

### Как это использовать

1. Чтобы использовать функции из пакета:
```
from mypackage import multiply, divide

print(multiply(3, 4))  # 12
print(divide(10, 2))   # 5.0
```

2. Чтобы запустить пакет как программу из командной строки (находясь в директории, где лежит `mypackage`):
```
python -m mypackage
```

Результат:
```
Умножение 6 на 7 = 42
Деление 42 на 7 = 6.0
```