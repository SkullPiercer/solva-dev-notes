Начнем с того, что разберемся, что такое итерация.
Итерация (от лат. iteratio — повторение) - это однократное выполнение какого-либо действия или процесса, часто в контексте циклического процесса или алгоритма. Если простыми словами то это одно повторение из многих.

Например:
```
fruits = ["apple", "banana", "cherry"]

for fruit in fruits:
    print(fruit)
```
У нас есть обычный цикл, который поочередно выведет на экран фрукты. Всего он сделает это 3 раза
вывод apple - 1-я итерация
вывод banana - 2-я итерация
вывод cherry - 3-я итерация

Обычно мы пробегаемся по коллекциям или же итерируемым объектам. **Итерируемый объект** — это любой объект, от которого встроенная функция iter() может получить итератор.

Попробуем написать простую реализацию собственного итератора
```
class MyIterator:
    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        return self  # сам себя возвращает как итератор

    def __next__(self):
        if self.index < len(self.data):
            result = self.data[self.index]
            self.index += 1
            return result
        else:
            raise StopIteration

words = MyIterator(['hello', 'world'])
for word in words:
    print(word)


Вывод:
hello
world

```
Это пример внешнего итератора

**Внешний итератор** — это такой способ обхода элементов коллекции, при котором управление процессом итерации находится в руках пользователя. То есть, клиентский код сам решает, когда запрашивать следующий элемент, используя метод `next()`. Такой итератор предоставляет максимальный контроль: можно вручную получить элемент, можно прервать обход в любой момент, можно использовать цикл `for`, который внутри сам вызывает `next()`. В Python внешний итератор — это любой объект, у которого есть методы `__iter__()` и `__next__()`. Он позволяет пройтись по итерируемому объекту пошагово, при этом сам объект может быть, например, списком, строкой или пользовательским классом. Когда элементы заканчиваются, метод `__next__()` вызывает исключение `StopIteration`, и цикл останавливается. Именно такой подход является стандартом в Python и используется во всех циклах `for`.

**Внутренний итератор** — это такой способ перебора элементов, при котором управление процессом итерации передаётся самому итератору. Вместо того чтобы вручную запрашивать следующий элемент (как во внешнем итераторе), программист предоставляет функцию (часто называемую `callback`), и итератор сам вызывает её для каждого элемента. Таким образом, весь цикл скрыт внутри итератора. В Python примеры внутренней итерации — это функции вроде `map()`, `filter()`, `sorted()`, `for_each()` и генераторы списков. Внутренние итераторы удобны тем, что делают код более лаконичным и часто читаемым, но при этом теряется часть контроля — например, нельзя просто так остановить цикл посередине. В целом, внутренний итератор хорош, когда нужно просто «что-то сделать» со всеми элементами и не требуется вмешиваться в процесс перебора.

```
def do_for_each(data, callback):
    for item in data:
        callback(item)

def print_item(x):
    print(f"Обрабатываю: {x}")

do_for_each(["a", "b", "c"], print_item)
```

Это **внутренний итератор** — он сам обходит данные и вызывает нашу функцию.


Еще немного про итерируемые объекты:
Почему по списку можно пройтись циклом но 
```
a = [1, 2, 3]
print(next(a))
```
вызовет ошибку
```
TypeError: 'list' object is not an iterator
```
Ошибка говорит: `list` **не итератор**.
Это значит, что у него есть метод `__iter__()`, который **создаёт итератор**.
```
a = [1, 2, 3]
print(hasattr(a, '__iter__'))     # ✅ True
print(hasattr(a, '__next__'))     # ❌ False
```

```
it = iter(a)  # создаёт итератор
print(next(it))  # 1
print(next(it))  # 2
print(next(it))  # 3
```
Теперь всё работает, потому что `iter(a)` возвращает **специальный объект-итератор**, у которого есть метод `__next__`.

# Как работает `for` под капотом?
```
for x in a:
    print(x)
```
Под капотом Python делает то же самое, что и:
```
it = iter(a)
while True:
    try:
        x = next(it)
        print(x)
    except StopIteration:
        break
```

Почему iter(a) а не a.iter()
Дело в том, что в Python вызов `iter(a)` — это **встроенная функция**, которая **под капотом вызывает метод `a.__iter__()`**. Но делает это универсальным способом, не завися от того, что за объект передан.

больше про итераторы: https://habr.com/ru/articles/337314/

# Что такое генератор
С точки зрения реализации, генератор в Python — это языковая конструкция, которую можно реализовать двумя способами: как функция с ключевым словом _yield_ или как генераторное выражение. В результате вызова функции или вычисления выражения, получаем объект-генератор типа types._GeneratorType_.

В объекте-генераторе определены методы __next__ и __iter__, то есть реализован протокол итератора, с этой точки зрения, в Python любой генератор является итератором.
Концептуально, итератор — это механизм поэлементного обхода данных, а генератор позволяет отложено создавать результат при итерации. Генератор может создавать результат на основе какого то алгоритма или брать элементы из источника данных(коллекция, файлы, сетевое подключения и пр) и изменять их.

Ярким пример являются функции range и enumerate:  
  
_range_ генерирует ограниченную арифметическую прогрессию целых чисел, не используя никакой источник данных.  
_enumerate_ генерирует двухэлементные кортежи с индексом и одним элементом из итерируемого объекта.

```
# Создать функцию-генератор.
def short_sequence():
    num = 1
    while num < 5:
    # Сгенерировать значение через yield.
        yield num
        num += 1

# Здесь функция-генератор возвращает итератор.
step = short_sequence()

# Обратиться к методу __next__() итератора
# и получить первое значение последовательности.
print(step.__next__())

# Ещё раз обратиться к методу __next__()
# и получить второе значение последовательности.
print(step.__next__()
```

Логика работы кода такова:

1. При первом вызове метода `__next__()` инструкция `yield` генерирует и возвращает первое значение — `1`.
2. Затем функция-генератор встаёт на паузу на выполнении цикла `while`, запомнив своё состояние.
3. При втором вызове метода `__next__()` функция-генератор продолжает работу с того места, на котором остановилась, и возвращает следующее значение — `2`.

Когда значения исчерпаются, генератор выбросит исключение `StopIteration`.

Если у генератора есть ограничение на количество значений, то все эти значения можно получить, перебрав генератор в цикле.

```
def short_sequence():
    num = 1
    while num < 5:
        yield num
        num += 1

for step in short_sequence():
    print(step)
```

Генератор может быть устроен по-разному; важно, чтобы значения генерировались через инструкцию `yield`.

```
def english_word_generator():
    # Сгенерировать слово.
    yield 'orange'
    
    # Проитерироваться по списку слов и вернуть каждое слово из списка.
    for word in ['apple', 'banana', 'Cherry', 'Date', 'fig']:
        yield word

    # Сгенерировать ещё одно слово.
    yield 'pineapple'

# Запустить генератор, проитерироваться по всем возвращаемым им значениям 
# и вывести каждое значение на экран.
for word in english_word_generator():
    print(word)
```

## Что такое генераторное выражение
Генераторное выражение — это упрощённый синтаксис для создания генератора.

Очень часто генераторы могут быть записаны с использованием синтаксиса, похожего на _list comprehension_, но не в квадратных, а в круглых скобках.

```
# Так описывается список через list comprehension.
simple_list = [digit for digit in range(2)]

print(type(simple_list))
a = iter(simple_list)
print(a.__next__())
print(a.__next__())

# Выведется:
# <class 'list'>
# 0
# 1

# А так описывается генераторное выражение.
simple_generator = (digit for digit in range(2))

print(type(simple_generator))
print(simple_generator.__next__())
print(simple_generator.__next__())

# Выведется:
# <class 'generator'>
# 0
# 1
```
Генераторы требуют меньше памяти, и если нужно сформировать последовательность, то выгоднее формировать её именно через генератор или генераторное выражение, а не через _list comprehension_.

## Что в итоге

- Итерируемым называют объект, который содержит элементы, и эти элементы можно перебрать. Каждый шаг перебора — это итерация.
- Чтобы проверить, итерируется объект или нет, можно применить к нему функцию `iter()`: для итерируемых объектов она вернёт **объект итератора**, а для неитерируемых — ошибку _object is not iterable_.
- Любой итерируемый объект содержит метод `__iter__()`, а объект итератора — метод `__next__()`.
- Чтобы создать собственный итерируемый объект, нужно для этого объекта реализовать методы `__iter__()`, `__next__()` и выброс исключения `StopIteration` на случай, если значения итератора исчерпаются.
- Генератор — это подвид итератора: функция, которая генерирует значения. Его использование помогает экономить место в оперативной памяти.
- Генератор объявляется как обычная функция, но вместо инструкции `return` в нём используется `yield`. Инструкция `return` завершает работу функции, а `yield` лишь приостанавливает её и при этом возвращает какое-то значение.
- Генератор можно перебрать в цикле только один раз.
- Генераторное выражение — это упрощённый синтаксис для создания генератора.

```
simple_generator = (digit for digit in range(2))
```
```
|Тип|Пример|Зачем?|
|---|---|---|
|Простое|`(x for x in range(5))`|Базовое ленивое перебирание|
|С фильтром|`(x for x in range(5) if x % 2 == 0)`|Отбор по условию|
|С вложенными циклами|`(x*y for x in a for y in b)`|Парные комбинации|
|С тернарным оператором|`("yes" if x>0 else "no" for x in data)`|Разные значения по условию|
|С функцией|`(f(x) for x in data)`|Обработка и преобразование|
|С `sum`, `max`, и т.п.|`sum(x for x in range(100))`|Агрегация без списков|
```

