Для того чтобы посчитать сколько у нас букв l в строке Hello world мы используем метод .count()
```
message = 'Hello world'

print(message.count('l'))
```
Мы не знаем что там под "капотом" но получаем нужный нам результат. В наших собственных классах ситуация та же.

```
class Wolf:
    legs = 4

    def __init__(self, age, color):
        self.age = age
        self.color = color

    def hunt(self, target):
        return f'Hunt started on {target}'

    def howl(self):
        return 'Wooooooooooooooo'

  

class Dog(Wolf):
    def __init__(self, age, color, name):
        super().__init__(age, color)
        self.name = name

    def howl(self):
        return 'Auuuuuuuuuuuuuuu'
```
В примере выше у нас есть класс Wold который является родителем для Dog. У Dog есть все методы и атрибуты родителя в том числе и метод hunt. Если не смотреть в родительский класс то реализация функции от нас скрыта. Но мы всегда можем вызвать метод у экземпляра класса и получить результат:
```
sharik = Dog(5, 'white', 'Sharik')
print(sharik.hunt('ball'))

Результат:
Hunt started on ball
```
А второй метод howl мы полностью переопределили и для этого нам даже не понадобилось знать детали реализации.

Такой механизм, когда детали реализации объекта скрыты, а для взаимодействия с ним предоставлен специальный интерфейс, называется **инкапсуляцией**.

Если мы хотим поговорить о более приближенном примере из реальной жизни, возьмем за пример смарт-часы. Для того чтобы пользоваться всеми их функциями: смотреть время, мерять пульс, замерять шаги итд. Нам предоставлен удобный интерфейс с которым мы взаимодействуем, в то время как детали реализации (все эти микросхемы, программы и прочая электроника) скрыты под циферблатом.

# Уровень защищенности и приватности

В Python все атрибуты и методы класса по умолчанию являются общедоступными / публичными. Это означает, что к ним можно свободно обращаться как изнутри самого класса, так и из любой части программы.  

Однако иногда возникают ситуации, когда доступ к определённым методам или атрибутам извне не требуется или даже нежелателен. В таких случаях разработчики могут обозначать их как защищённые или приватные, чтобы дать понять другим, что эти элементы предназначены для внутреннего использования.

## Защищённые атрибуты и методы

Если необходимо указать, что атрибут или метод предназначен только для внутреннего использования внутри класса или его подклассов, перед его именем добавляется одинарное подчёркивание `_`. Такие элементы считаются защищёнными.

Например: 
У автомобиля есть уникальный идентификационный номер (VIN). Он должен быть доступен для чтения, но не для изменения. Поэтому его хранят в защищённом атрибуте и предоставляют публичный метод для получения значения.

```
class Car(Vehicle):
    def __init__(self, VIM):
        super().__init__()
        self._VIM = VIM


    def get_car_info(self):
        return self._VIM
```

Увидев такой атрибут в коде, разработчик поймёт, что он предназначен для использования только внутри самого класса или его подклассов. Однако в Python это всего лишь соглашение, а не строгий запрет — поэтому ничто не мешает обратиться к такому атрибуту напрямую из любого места в программе, минуя предусмотренные методы.
```
bmw = Car(1234567)

print(bmw.get_car_info())
print(bmw._VIM)

Вывод:
1234567
1234567
```
Одинарное подчёркивание перед именем атрибута или метода служит своего рода предупреждением для других разработчиков: «Этот элемент предназначен для внутреннего использования в пределах класса и его потомков. Ты можешь получить к нему доступ, но делай это осознанно и осторожно».

Если же требуется действительно ограничить внешний доступ к атрибуту или методу, можно сделать его приватным, добавив перед именем два подчёркивания.

## Приватные атрибуты и методы
В Python атрибут или метод, имя которого начинается с двойного подчёркивания `__`, считается приватным. Это значит, что обратиться к нему напрямую можно только внутри самого класса. Внешний доступ к такому атрибуту затруднён и не может быть осуществлён случайно.

Например, у класса `Car` есть атрибут `engine_number`, который хранит данные о номере двигателя. Поскольку маловероятно, что этот параметр должен изменяться после создания объекта, его имеет смысл сделать приватным. Это поможет защитить значение от случайного изменения и подчеркнёт, что оно предназначено исключительно для внутреннего использования.

```
class Car(Vehicle):
    def __init__(self, VIM, engine_number):
        super().__init__()
        self._VIM = VIM
        # Уникальный номер двигателя будет приватным
        self.__engine_number = engine_number

  
    def get_car_info(self):
        return self._VIM
```

В Python приватные атрибуты и методы наследуются подклассами, но из-за особого механизма — **искажения имён** (_name mangling_) — доступ к ним становится менее очевидным.

Когда вы создаёте метод или атрибут с двойным подчёркиванием в начале имени (например, `__priv_attr`), Python автоматически преобразует его имя, добавляя имя класса: `__priv_attr` в классе `A` станет `_A__priv_attr`. Это сделано для снижения риска конфликтов имён при наследовании.

Поэтому доступ к таким атрибутам извне или из подклассов возможен, но требует знания оригинального имени класса и точного преобразованного имени.

Когда разработчик видит в коде имя с двумя подчёркиваниями в начале, это воспринимается как строгое предупреждение:  
**«Не трогай, если не уверен на 100%, что действительно нужно»**.

Важно помнить: в Python уровни доступа — это **соглашения**, а не реальные ограничения. Формально ничего не мешает обратиться к приватному атрибуту напрямую, но делать это считается плохой практикой, так как нарушает принцип **инкапсуляции** — один из фундаментальных принципов объектно-ориентированного программирования.

# Геттер (getter) и сеттер (setter)

 Это специальные методы в программировании, которые используются для доступа и изменения значений атрибутов класса.

- **Геттер** — метод, который возвращает значение приватного или защищённого атрибута. Обычно он используется, чтобы безопасно получить доступ к данным объекта без прямого обращения к атрибуту.
    
- **Сеттер** — метод, который позволяет изменить значение приватного или защищённого атрибута. Он обычно содержит проверку или дополнительную логику, чтобы гарантировать корректность данных при изменении.

```
class Person:
    def __init__(self, name):
        self.__name = name  # приватный атрибут

    def get_name(self):
        return self.__name  # геттер

    def set_name(self, new_name):
        if isinstance(new_name, str) and new_name:
            self.__name = new_name  # сеттер
        else:
            print("Некорректное имя")

```

В современных версиях Python часто используют декораторы `@property` для геттеров и `@<имя>.setter` для сеттеров, чтобы обращаться к методам как к обычным атрибутам, делая код более удобным и читабельным.
Пример использования:
```
class Person:
    def __init__(self, name):
        self.__name = name  # приватный атрибут

    @property
    def name(self):
        """Геттер: позволяет получить имя."""
        return self.__name

    @name.setter
    def name(self, new_name):
        """Сеттер: позволяет изменить имя с проверкой."""
        if isinstance(new_name, str) and new_name:
            self.__name = new_name
        else:
            raise ValueError("Имя должно быть непустой строкой")

# Пример использования
person = Person("Анна")

print(person.name)   # Обращение как к обычному атрибуту: Анна

person.name = "Ольга"  # Изменение значения через сеттер
print(person.name)     # Ольга

person.name = ""       # Вызовет исключение: ValueError

```
# Практика

### **Задача 1: Инкапсуляция через наследование**

Создай базовый класс `Employee`, у которого есть публичный метод `get_info()` и защищённый атрибут `_position`.  
Затем создай класс `Manager`, унаследованный от `Employee`, и переопредели метод `get_info()` так, чтобы он возвращал строку, содержащую должность `_position`.  
Убедись, что в коде дочерний класс использует защищённый атрибут родителя.

 _Проверка_: Создай объект `Manager`, передай ему должность, и вызови `get_info()` — должно вернуться название должности.

---

### **Задача 2: Приватный атрибут**

Создай класс `BankAccount`, у которого есть приватный атрибут `__balance`.  
Добавь публичные методы `deposit(amount)` и `get_balance()`.  
Метод `deposit()` должен увеличивать баланс только если `amount > 0`.  
Метод `get_balance()` возвращает текущий баланс.

 _Проверка_: Попробуй изменить `__balance` напрямую снаружи и проверь, изменился ли он.

---

### **Задача 3: Защищённый атрибут**

Создай класс `Book`, в котором есть защищённый атрибут `_isbn`.  
Добавь публичный метод `get_isbn()` для получения значения этого атрибута.  
Покажи, что к `_isbn` можно обратиться извне, но это считается плохой практикой.

_Проверка_: Создай объект `Book`, выведи ISBN через метод и напрямую — сравни подходы.

---

### **Задача 4: Комбо (приватный + защищённый)**

Создай класс `User`, у которого:

- Приватный атрибут `__password`
    
- Защищённый атрибут `_email`
    
- Публичный метод `check_password(password)`
    
- Публичный метод `get_email()`

Затем создай класс `AdminUser`, который наследуется от `User`, и добавь метод `change_email(new_email)`, позволяющий изменить `_email`.

 _Проверка_: Создай обычного пользователя и администратора. Проверь, что `AdminUser` может менять email, а `User` — нет. Попробуй обратиться к `__password` извне.

# Дополнительные задания
https://sky.pro/wiki/python/prakticheskie-zadaniya-po-oop-na-python/
