**Полиморфизм** — это свойство объектов вести себя по-разному в зависимости от того, к какому классу они принадлежат, даже если вызывается один и тот же метод.

То есть:

> Один интерфейс (название метода) — множество реализаций (поведение в разных классах).

Получается, если я вызову метод `attack()` у класса `Warrior`, он скажет "Воин наносит мощный удар мечом!", а если у `Mage` — "Маг запускает огненный шар!"?

```
class Character:
    def attack(self):
        print("Наносит обычный удар")

class Warrior(Character):
    def attack(self):
        print("Воин наносит мощный удар мечом!")

class Mage(Character):
    def attack(self):
        print("Маг запускает огненный шар!")
        

# Создаем персонажей
warrior = Warrior()
mage = Mage()

# Вызываем метод
warrior.attack()
mage.attack()
```
Метод называется одинаково, но ведёт себя по-разному — в этом и заключается одно из ключевых преимуществ объектно-ориентированного программирования. Это свойство называется **полиморфизмом**. С греческого языка слово переводится как «многообразие форм», и в контексте программирования означает, что **один и тот же метод может реализовываться по-разному в разных классах**.

### Полиморфизм «под капотом»
В Python каждый класс имеет метод `__str__`, который отвечает за строковое представление объекта. По умолчанию этот метод определён в базовом классе `object`, от которого наследуются все классы, как встроенные, так и пользовательские.

Однако если вызвать `print()` для разных встроенных типов, мы увидим, что результат отличается в зависимости от класса:
```
# Целое число (int)
value = 42
print(value)  
# Выведется: 42

# Строка (str)
string = 'Hello, World!'
print(string)  
# Выведется: Hello, World!

# Список (list)
my_list = [1, 2, 3, 4, 5]
print(my_list)  
# Выведется: [1, 2, 3, 4, 5]

# Булев тип (bool)
my_bool = True
print(my_bool)  
# Выведется: True
```
Почему так происходит? Потому что встроенные классы переопределяют метод `__str__`, задавая для него свою реализацию, которая выводит содержимое объектов в понятном формате.

Аналогично, вы можете переопределить метод `__str__` в своих пользовательских классах, чтобы управлять тем, как объекты этих классов отображаются при выводе. Если вы этого не сделаете, то при попытке вывести объект вашего класса, результатом будет строка по умолчанию из базового класса `object`, которая обычно содержит информацию о типе объекта и его адресе в памяти.

Если мы обьявем наш класс без метода str то вывод будет:
```
class Dog:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age

sharik = Dog('Sharik', 10)
print(sharik)

вывод <__main__.Dog object at 0x000001DDF8ED6A50>
```

А вот уже с ним:
```
class Dog:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age
  

    def __str__(self):
        return f'Меня зовут {self.name} и мне {self.age} лет'

  

sharik = Dog('Sharik', 10)
print(sharik)

Вывод Меня зовут Sharik и мне 10 лет
```

Вы можете создавать множество экземпляров разных классов, и каждый из них будет иметь общий набор атрибутов и методов, взятых из базового класса. Хотя конкретные значения этих атрибутов и реализация методов могут различаться, структура — то, что можно назвать интерфейсом класса — остаётся неизменной.

Интерфейс класса — это набор «кнопок» и «экранов», которые гарантированно есть у каждого объекта этого класса. Говоря проще, все наследники базового класса поддерживают одинаковый интерфейс, который может быть либо унаследован без изменений, либо модифицирован (переопределён).

В примерах выше мы видели, как один и тот же метод `__str__` применялся к разным объектам. Несмотря на единый интерфейс, результат работы метода отличался в зависимости от конкретного объекта.

Именно это и называется полиморфизмом: единый интерфейс — множество различных реализаций в зависимости от класса и объекта.
