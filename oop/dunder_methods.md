Магические методы в Python — это специальные методы, имена которых начинаются и заканчиваются двойным подчеркиванием (например, `__init__`, `__str__`, `__add__` и так далее). Они позволяют изменять поведение объектов классов при взаимодействии с различными встроенными операциями языка. Такие методы автоматически вызываются интерпретатором в ответ на определённые действия — создание объекта, преобразование к строке, сложение, сравнение и многое другое. По сути, магические методы — это способ встроиться в стандартные механизмы Python и переопределить или дополнить их поведение для пользовательских классов. Это делает классы более гибкими и «естественно» интегрированными в язык. Например, можно задать, как объект класса будет выводиться при печати, как будет сравниваться с другим объектом, как вести себя при использовании в цикле или как реагировать на арифметические операции.

## Создание и удаление объектов
`__new__` — это магический метод, который отвечает за создание нового экземпляра класса. В отличие от `__init__`, который инициализирует уже созданный объект, `__new__` создает сам объект и возвращает его. Это статический метод, первым аргументом которого всегда является сам класс (`cls`), а не экземпляр (`self`). Обычно используется при наследовании от неизменяемых типов (например, `int`, `str`, `tuple`), когда нужно контролировать процесс создания объекта. Если `__new__` не возвращает экземпляр класса (или его подкласса), `__init__` вызван не будет.

```
class MyInt(int):
    def __new__(cls, value):
        print("Вызывается __new__")
        instance = super().__new__(cls, value + 1)
        return instance


    def __init__(self, value):
        print("Вызывается __init__")
        super().__init__()


num = MyInt(5)
print(num)  # Выведет: 6
```

`__init__` — это магический метод, который вызывается сразу после создания объекта и используется для его инициализации. Он не создает объект (этим занимается `__new__`), а лишь настраивает уже готовый экземпляр: задает атрибуты, выполняет начальные вычисления и прочие подготовительные действия. Первый аргумент — это всегда `self`, то есть сам создаваемый объект. Метод ничего не должен возвращать (возврат значения приведёт к ошибке).
```
class Person:
    def __init__(self, name, age):
        print("Вызывается __init__")
        self.name = name
        self.age = age

p = Person("Анна", 30)
print(p.name)  # Анна
print(p.age)   # 30
```

`__init_subclass__` — это магический метод, который вызывается автоматически каждый раз, когда создаётся подкласс текущего класса. Его задача — реагировать на факт наследования и настраивать поведение подклассов. Это метод класса, первым аргументом получает сам создаваемый подкласс (не экземпляр), и может быть переопределён в базовом классе для добавления дополнительной логики при наследовании. Метод полезен, если нужно контролировать или валидировать создание подклассов, автоматически добавлять атрибуты или регистрировать их где-то.
```
class Base:
    def __init_subclass__(cls):
        print(f"Создан подкласс: {cls.__name__}")

class Child1(Base):
    pass

class Child2(Base):
    pass

```

`__del__` — это магический метод, который вызывается при уничтожении объекта, то есть когда объект собирается сборщиком мусора и больше не нужен программе. Его основное предназначение — освободить ресурсы: закрыть файлы, соединения с базой данных, сетевые соединения и другие внешние зависимости. Метод получает один аргумент — `self`, то есть сам объект. Использовать `__del__` нужно с осторожностью, так как он вызывается не всегда предсказуемо, особенно при циклических ссылках или завершении программы.
```
class FileHandler:
    def __init__(self, filename):
        self.filename = filename
        self.file = open(filename, 'w')
        print(f"Открыт файл: {self.filename}")

    def __del__(self):
        print(f"Закрыт файл: {self.filename}")
        self.file.close()

handler = FileHandler("example.txt")
del handler  # Здесь явно вызываем удаление объекта
```
В этом примере при удалении объекта вызывается `__del__`, который закрывает файл. Это позволяет гарантировать, что ресурсы будут освобождены, но на практике для управления ресурсами лучше использовать менеджеры контекста (`with`), так как они надёжнее и предсказуемее.

## Общие свойства объектов
`__repr__` — это магический метод, который отвечает за то, как объект будет представлен в виде строки, когда его печатают в интерактивной консоли или вызывают функцию `repr()`. Главная цель — дать однозначное, понятное для разработчика описание объекта, которое в идеале можно было бы использовать для повторного создания экземпляра. Этот метод должен возвращать строку. Если `__str__` не определён, то `print()` тоже будет использовать `__repr__`.
```
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return f"Point({self.x}, {self.y})"

p = Point(3, 4)
print(repr(p))  # Point(3, 4)
```
Здесь `__repr__` возвращает строку, которая явно описывает объект `Point` и его параметры, что полезно для отладки и логирования.

`__str__` — это магический метод, который определяет строковое представление объекта при вызове функции `str()` или когда объект передаётся в `print()`. В отличие от `__repr__`, который ориентирован на разработчиков и отладку, `__str__` должен возвращать более «человеческое» и понятное описание объекта, удобное для вывода пользователю. Если `__str__` не определён, Python использует `__repr__` как запасной вариант.

```
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f"{self.name}, {self.age} лет"

p = Person("Алексей", 28)
print(p)  # Алексей, 28 лет
```
В этом примере `__str__` возвращает красиво отформатированную строку, которую удобно читать человеку. Это особенно полезно при работе с пользовательскими классами, чтобы не видеть стандартный вывод вроде `<__main__.Person object at 0x...>`.

`__bytes__` — магический метод, который определяет, как объект будет преобразован в байтовое представление при вызове функции `bytes()`. Он должен возвращать объект типа `bytes`. Обычно используется, когда нужно получить низкоуровневое бинарное представление объекта, например, для записи в файл или передачи по сети. Если `__bytes__` не определён, попытка вызвать `bytes()` на объекте приведёт к ошибке.
```
class Message:
    def __init__(self, text):
        self.text = text

    def __bytes__(self):
        return self.text.encode('utf-8')

msg = Message("Привет")
b = bytes(msg)
print(b)  # b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82'
```
Здесь `__bytes__` кодирует текст сообщения в UTF-8 и возвращает байты, что удобно для дальнейшей работы с бинарными данными.

`__format__` — магический метод, который определяет поведение объекта при форматировании с помощью функции `format()` или литералов форматирования (f-строк). Он принимает один аргумент — строку `format_spec`, которая описывает спецификацию формата (например, количество знаков после запятой, выравнивание и т.п.). Метод должен вернуть строку — отформатированное представление объекта согласно заданным параметрам. Если метод не определён, используется стандартное преобразование к строке.
```
class Temperature:
    def __init__(self, celsius):
        self.celsius = celsius

    def __format__(self, format_spec):
        if format_spec == 'f':
            return f"{self.celsius:.2f} °C"
        elif format_spec == 'k':
            return f"{self.celsius + 273.15:.2f} K"
        else:
            return str(self.celsius)

t = Temperature(25)
print(format(t, 'f'))  # 25.00 °C
print(format(t, 'k'))  # 298.15 K
print(f"Температура: {t:f}")  # Температура: 25.00 °C
```
Здесь `__format__` позволяет задавать разные варианты форматирования температуры — в градусах Цельсия или Кельвина — через спецификатор формата.

## Методы сравнения объектов между собой
`__lt__` — магический метод, который определяет поведение оператора "меньше" (`<`) для объектов класса. Когда вы пишете `a < b`, Python вызывает `a.__lt__(b)`. Метод должен возвращать булево значение — `True`, если первый объект считается меньше второго, и `False` в противном случае. Если метод не определён, Python попытается использовать другие методы сравнения или выдаст ошибку.
```
class Person:
    def __init__(self, age):
        self.age = age

    def __lt__(self, other):
        return self.age < other.age

p1 = Person(25)
p2 = Person(30)

print(p1 < p2)  # True
print(p2 < p1)  # False
```
В этом примере сравнение происходит по возрасту: объект считается меньше другого, если его возраст меньше.

`__le__(self, other)` — определяет поведение оператора сравнения «меньше или равно», `<=`.

`__eq__(self, other)` — определяет поведение оператора «равенства», `==`.

`__ne__(self, other)` — определяет поведение оператора «неравенства», `!=`.

`__gt__(self, other)` — определяет поведение оператора сравнения «больше», `>`.

`__ge__(self, other)` — определяет поведение оператора сравнения «больше или равно», `>=`.

`__hash__` — магический метод, который возвращает целочисленное значение — хеш объекта. Этот хеш используется, например, при добавлении объекта в множества (`set`) или в качестве ключа в словарях (`dict`). Метод должен возвращать одно и то же значение для одного и того же объекта, пока он не изменился (то есть для неизменяемых объектов). Если `__hash__` не определён, объект становится необхешируемым и не может использоваться в множествах и ключах словарей. Обычно, если переопределяется метод сравнения (`__eq__`), стоит также переопределить и `__hash__`, чтобы сохранить согласованность.
```
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return (self.x, self.y) == (other.x, other.y)

    def __hash__(self):
        return hash((self.x, self.y))

p1 = Point(1, 2)
p2 = Point(1, 2)

s = {p1}
print(p2 in s)  # True, потому что у p1 и p2 одинаковый хеш и они равны
```

`__bool__` — магический метод, который определяет логическое значение объекта при приведении его к булевому типу, например, в условиях `if`, `while` или при вызове функции `bool()`. Метод должен возвращать либо `True`, либо `False`. Если `__bool__` не определён, Python пытается использовать метод `__len__` — объект считается `False`, если его длина равна нулю. Если нет ни того, ни другого, объект считается `True` по умолчанию.
```
class Box:
    def __init__(self, items):
        self.items = items

    def __bool__(self):
        return bool(self.items)  # True, если список не пустой

b1 = Box([1, 2, 3])
b2 = Box([])

print(bool(b1))  # True
print(bool(b2))  # False

if b1:
    print("В коробке есть вещи")
if not b2:
    print("Коробка пустая")
```
Здесь `__bool__` проверяет, есть ли в коробке предметы, и на этом основании возвращает `True` или `False`.

## Доступ к атрибутам объекта
`__getattr__` — магический метод, который вызывается **только тогда**, когда у объекта **нет** запрашиваемого атрибута. Это позволяет обрабатывать обращения к несуществующим атрибутам динамически, например, для реализации прокси-объектов, делегирования или работы с данными по умолчанию. Метод принимает один аргумент — имя атрибута (`name`), и должен вернуть значение или выбросить `AttributeError`, если значение не может быть получено.
```
class Dummy:
    def __getattr__(self, name):
        return f"Нет такого атрибута: {name}"

d = Dummy()
print(d.foo)  # Нет такого атрибута: foo
print(d.bar)  # Нет такого атрибута: bar
```
Здесь, при попытке получить `d.foo` или `d.bar`, Python не находит такие атрибуты и вызывает `__getattr__`, который возвращает строку-заглушку. Если бы атрибут существовал, этот метод не вызывался бы вовсе.

`__setattr__` — магический метод, который вызывается при **установке значения атрибута** через `obj.name = value`. Этот метод позволяет перехватывать, контролировать или изменять логику установки атрибутов. Чтобы избежать бесконечной рекурсии при присваивании внутри самого метода, необходимо использовать `super().__setattr__(name, value)` или напрямую обращаться к словарю атрибутов: `self.__dict__[name] = value`.
```
class Person:
    def __setattr__(self, name, value):
        if name == 'age' and value < 0:
            raise ValueError("Возраст не может быть отрицательным")
        super().__setattr__(name, value)

p = Person()
p.name = "Алексей"
p.age = 30      # работает нормально
p.age = -5      # вызовет ValueError
```
Здесь метод `__setattr__` проверяет, чтобы возраст не был отрицательным, и только после этого выполняет присваивание через `super()`. Такой подход часто используется для валидации или логирования изменений состояния объекта.

`__delattr__` — магический метод, который вызывается при **удалении атрибута** через `del obj.name`. С его помощью можно контролировать или запрещать удаление определённых атрибутов, выполнять дополнительные действия перед удалением или даже имитировать удаление.

Метод принимает один аргумент — имя удаляемого атрибута (`name`). Если атрибут не может быть удалён, нужно выбросить `AttributeError`.
```
class Person:
    def __init__(self):
        self.name = "Алексей"
        self.age = 30

    def __delattr__(self, name):
        if name == 'name':
            raise AttributeError("Атрибут 'name' нельзя удалить")
        super().__delattr__(name)

p = Person()
del p.age     # успешно удаляется
del p.name    # вызывает исключение
```
Здесь `__delattr__` блокирует удаление имени, но разрешает удаление других атрибутов. Это может быть полезно, если нужно защитить важные поля объекта от случайного удаления.

## Создание последовательностей
`__len__` — магический метод, который определяет поведение объекта при вызове функции `len()`. Метод должен возвращать **целое неотрицательное число**, обычно — количество элементов внутри объекта. Если `__len__` не определён, вызов `len(obj)` приведёт к ошибке `TypeError`.

Этот метод часто используется в коллекциях, контейнерах и структурах данных, чтобы сделать их совместимыми с Python-интерфейсами (например, циклами `for`, функциями `bool`, `list`, `sum` и т.п.).
```
class Basket:
    def __init__(self, items):
        self.items = items

    def __len__(self):
        return len(self.items)

b = Basket(["яблоко", "груша", "банан"])
print(len(b))  # 3
```
Здесь `__len__` возвращает количество элементов в списке `items`, хранящемся в объекте `Basket`. Такой подход делает объект совместимым со стандартными инструментами Python, ожидающими "измеряемость".

`__getitem__` — магический метод, который вызывается при доступе к элементам объекта по ключу или индексу, то есть при использовании синтаксиса `obj[key]`. Метод принимает один аргумент — `key`, который может быть числом (для индексирования), строкой (для словарей), срезом (`slice`) или другим объектом, в зависимости от логики. Если ключ не подходит или не найден, метод должен выбросить исключение `KeyError` или `IndexError`.

Этот метод делает объект "индексируемым", как списки, словари и другие коллекции.
```
class SquareValues:
    def __getitem__(self, index):
        return index * index

squares = SquareValues()
print(squares[5])   # 25
print(squares[10])  # 100
```
В этом примере объект `SquareValues` не хранит данные, но позволяет получить квадрат числа по индексу. Благодаря `__getitem__` можно обращаться к нему как к обычному списку.

`__setitem__` — магический метод, который вызывается при установке значения по ключу или индексу, то есть при использовании синтаксиса `obj[key] = value`. Метод принимает два аргумента: `key` — ключ (или индекс), и `value` — значение, которое нужно сохранить. Этот метод позволяет объекту вести себя как изменяемый контейнер (например, список или словарь), управляя логикой записи данных.
```
class CustomDict:
    def __init__(self):
        self.data = {}

    def __setitem__(self, key, value):
        print(f"Устанавливаю {key} = {value}")
        self.data[key] = value

d = CustomDict()
d["name"] = "Алексей"  # Устанавливаю name = Алексей
d["age"] = 30          # Устанавливаю age = 30

print(d.data)  # {'name': 'Алексей', 'age': 30}
```
В этом примере `__setitem__` перехватывает операцию записи и сохраняет значение во внутренний словарь `data`, при этом добавляя дополнительную логику (печать). Такой метод часто используется в пользовательских коллекциях или обёртках.

`__delitem__` — магический метод, который вызывается при удалении элемента по ключу или индексу через выражение `del obj[key]`. Метод принимает один аргумент — `key`, и должен реализовать логику удаления соответствующего элемента. Если ключ не найден или удаление невозможно, следует выбросить `KeyError` или `IndexError` в зависимости от контекста.

Этот метод делает объект совместимым с поведением стандартных коллекций, таких как списки и словари.
```
class CustomDict:
    def __init__(self):
        self.data = {}

    def __setitem__(self, key, value):
        self.data[key] = value

    def __delitem__(self, key):
        print(f"Удаляю ключ: {key}")
        del self.data[key]

d = CustomDict()
d["name"] = "Алексей"
d["age"] = 30

del d["age"]  # Удаляю ключ: age

print(d.data)  # {'name': 'Алексей'}
```
В этом примере `__delitem__` позволяет объекту вести себя как словарь при удалении, и дополнительно печатает сообщение. Этот метод полезен, если нужно контролировать или логировать удаление данных.

`__missing__` — магический метод, который вызывается **только в подклассах `dict`**, когда происходит попытка доступа к отсутствующему ключу через `obj[key]`, и ключ не найден в словаре. Метод принимает один аргумент — `key`, который не был найден, и должен вернуть значение по умолчанию или выбросить `KeyError`.

Этот метод позволяет задать собственное поведение при обращении к несуществующим ключам.
```
class DefaultDict(dict):
    def __missing__(self, key):
        print(f"Ключ '{key}' не найден, возвращаю 0")
        return 0

d = DefaultDict()
d["a"] = 10
print(d["a"])  # 10
print(d["b"])  # Ключ 'b' не найден, возвращаю 0 → 0
```
Здесь `__missing__` возвращает 0, если ключ отсутствует. Этот подход похож на `collections.defaultdict`, но реализован вручную через магический метод.

`__reversed__` — магический метод, который вызывается при использовании встроенной функции `reversed(obj)`. Метод должен вернуть **итератор**, который будет перебирать элементы объекта в обратном порядке. Если метод не определён, Python попытается вызвать `__len__` и `__getitem__` с индексами от последнего к первому. Если ни один способ не реализован, возникнет `TypeError`.

Метод полезен для пользовательских коллекций, где обычное обращение к индексам не подходит или требует особой логики.
```
class Countdown:
    def __init__(self, start):
        self.start = start

    def __reversed__(self):
        return (i for i in range(0, self.start + 1))

c = Countdown(5)
for num in reversed(c):
    print(num, end=' ')  # 0 1 2 3 4 5
```
Здесь `__reversed__` возвращает генератор, перебирающий числа от 0 до заданного `start`. Таким образом объект `Countdown` поддерживает обратную итерацию по своей логике, не полагаясь на индексы или списки.

`__contains__` — магический метод, который определяет поведение оператора `in` при проверке принадлежности элемента объекту (`item in obj`). Метод принимает один аргумент — элемент `item`, который проверяется на наличие в объекте, и должен возвращать `True` или `False`.

Если `__contains__` не определён, Python пытается перебрать объект с помощью итератора и сравнить элементы, что может быть менее эффективно.
```
class EvenNumbers:
    def __contains__(self, item):
        return isinstance(item, int) and item % 2 == 0

evens = EvenNumbers()
print(4 in evens)   # True
print(5 in evens)   # False
print("6" in evens) # False
```
Здесь `__contains__` проверяет, является ли число чётным, и на основе этого возвращает результат для оператора `in`. Благодаря этому объект ведёт себя как коллекция, но с собственной логикой проверки.

## Числовые магические методы
Данные методы делятся на несколько групп: унарные операторы, обычные арифметические, отражённые арифметические операторы, составные присваивания и преобразования типов.

### Унарные операторы
`__neg__` — магический метод, который вызывается при применении унарного минуса (`-obj`). Он определяет поведение объекта при операции отрицания и должен возвращать новый объект или значение, представляющее результат этой операции.

Чаще всего используется в числовых классах для реализации логики изменения знака.
```
class Number:
    def __init__(self, value):
        self.value = value

    def __neg__(self):
        return Number(-self.value)

    def __repr__(self):
        return f"Number({self.value})"

n = Number(5)
print(-n)  # Number(-5)
```
Здесь `__neg__` возвращает новый объект с противоположным знаком. Это позволяет писать `-n` и получать объект с инвертированным значением.

`__add__` — магический метод, который вызывается при использовании оператора сложения `self + other`. Он определяет логику сложения объекта с другим значением и должен вернуть результат сложения — новый объект или значение.

Метод принимает один аргумент — `other` (правый операнд) и обычно возвращает новый объект, не изменяя исходные.
```
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        if not isinstance(other, Vector):
            return NotImplemented
        return Vector(self.x + other.x, self.y + other.y)

    def __repr__(self):
        return f"Vector({self.x}, {self.y})"

v1 = Vector(1, 2)
v2 = Vector(3, 4)
print(v1 + v2)  # Vector(4, 6)
```
Здесь `__add__` складывает компоненты векторов и возвращает новый объект `Vector`. Если `other` не того типа, возвращается `NotImplemented`, чтобы Python попытался вызвать обратное сложение или выбросил ошибку.

### Составное присваивание
`__iadd__` — магический метод, который вызывается при использовании оператора **+=** (сложение с присваиванием) — например, `obj += other`. Он определяет поведение объекта при таком изменении и должен либо изменить объект «на месте» (мутабельно), либо вернуть новый объект с результатом.

В отличие от `__add__`, который обычно возвращает новый объект, `__iadd__` пытается изменить сам объект, если это возможно. Если метод не определён, Python подставляет поведение через `__add__` и присваивание.
```
class Counter:
    def __init__(self, value=0):
        self.value = value

    def __iadd__(self, other):
        self.value += other
        return self

    def __repr__(self):
        return f"Counter({self.value})"

c = Counter(5)
c += 3
print(c)  # Counter(8)
```
Здесь `__iadd__` изменяет поле `value` объекта на месте и возвращает сам объект. Благодаря этому оператор `+=` работает эффективно и логично для изменяемых объектов.

### Преобразования типов
`__int__` — магический метод, который вызывается при преобразовании объекта в целое число через функцию `int(obj)`. Метод должен возвращать целочисленное значение, соответствующее объекту.

Это позволяет кастомным классам корректно конвертироваться в `int`, например, при необходимости использовать их там, где ожидается целое число.
```
class Age:
    def __init__(self, years):
        self.years = years

    def __int__(self):
        return int(self.years)

    def __repr__(self):
        return f"Age({self.years})"

a = Age(25.7)
print(int(a))  # 25
```
В этом примере `__int__` возвращает целочисленную часть возраста, благодаря чему объект класса `Age` можно преобразовать в целое число с помощью `int()`.

`__call__` — магический метод, который позволяет экземпляру класса вести себя как функция, то есть делать объект вызываемым с помощью синтаксиса `obj(args...)`. Метод принимает любые позиционные и именованные аргументы и выполняет определённую логику при вызове объекта.

Это удобно, когда нужно создать объект с внутренним состоянием, который при вызове выполняет действие, похожее на функцию.
```
class Multiplier:
    def __init__(self, factor):
        self.factor = factor

    def __call__(self, value):
        return value * self.factor

m = Multiplier(3)
print(m(5))  # 15
print(m(10)) # 30
```
Здесь объект `m` ведёт себя как функция, умножая переданное значение на заданный фактор. `__call__` делает объекты гибкими и позволяет использовать их в функциональном стиле.

`__await__` — магический метод, который используется в асинхронном программировании Python. Он позволяет объекту быть **ожидаемым** (awaitable), то есть его можно использовать с ключевым словом `await` в `async` функциях.

Метод должен возвращать итератор или объект-генератор, который поддерживает протокол асинхронного ожидания. Это даёт возможность определить, как именно объект будет «приостанавливаться» и «возобновляться» при использовании `await`.
```
import asyncio

class Awaitable:
    def __await__(self):
        print("Начинаем await")
        yield from asyncio.sleep(1).__await__()
        print("Закончили await")
        return "Результат"

async def main():
    result = await Awaitable()
    print(result)

asyncio.run(main())
```
В этом примере класс `Awaitable` реализует `__await__`, который делает его ожидаемым 
объектом. При `await Awaitable()` выполняется асинхронная пауза на 1 секунду, после чего возвращается результат. Это расширяет возможности кастомных объектов для работы с `async/await`.

## Контекстные менеджеры
`__enter__` — магический метод, который вызывается при входе в контекстный менеджер, то есть при использовании конструкции `with obj:`. Он должен вернуть объект, который будет привязан к переменной после `as`, если она используется. Часто возвращает сам объект (`self`), но может возвращать и другой.

Этот метод вместе с `__exit__` позволяет управлять ресурсами — автоматически открывать, настраивать или готовить объект к работе при входе в блок `with`.
```
class ManagedFile:
    def __init__(self, filename):
        self.filename = filename

    def __enter__(self):
        self.file = open(self.filename, 'w')
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.file.close()

with ManagedFile('test.txt') as f:
    f.write('Привет, мир!')
```
Здесь `__enter__` открывает файл и возвращает файловый объект, который используется внутри блока `with`. При выходе из блока вызывается `__exit__`, где файл закрывается. Таким образом, `__enter__` помогает корректно и безопасно управлять ресурсами.

`__exit__` — магический метод, вызываемый при выходе из контекстного менеджера, то есть после выполнения блока кода внутри `with`. Метод принимает три аргумента: тип исключения (`exc_type`), значение исключения (`exc_value`) и трассировку стека (`traceback`), если исключение произошло; если блок завершился без ошибок — все три будут `None`.

`__exit__` отвечает за очистку ресурсов (например, закрытие файла, освобождение памяти) и может обработать исключение, подавив его, если вернуть `True`. Если вернуть `False` или ничего не вернуть, исключение будет проброшено дальше.
```
class ManagedFile:
    def __init__(self, filename):
        self.filename = filename

    def __enter__(self):
        self.file = open(self.filename, 'w')
        return self.file

    def __exit__(self, exc_type, exc_value, traceback):
        self.file.close()
        if exc_type:
            print(f"Произошло исключение: {exc_type.__name__}")
        # Не подавляем исключение (возвращаем False или None)

with ManagedFile('test.txt') as f:
    f.write('Привет')
    # raise ValueError("Ошибка!")  # Если раскомментировать — сработает __exit__
```
Здесь `__exit__` закрывает файл в любом случае и печатает сообщение при исключении, но не подавляет его, позволяя обработать ошибку дальше. Таким образом, `__exit__` гарантирует корректное завершение работы с ресурсом.

`__aenter__(self)` — аналогично `__enter__`, только функция возвращает корутину (результат которой можно получить с помощью `await`)

`__aexit__(self, exc_type, exc_value, traceback)` — аналогично `__exit__`, только функция возвращает корутину (результат которой можно получить с помощью `await`)

## Упрощение работы с магическими методами

Большая часть из вышеописанных методов реализуется библиотеками, они позволяют использовать так называемые «обрёртки» над классами, в которых будут реализованы необходимые магические методы.

Пример таких библиотек:

- [dataclasses](https://docs.python.org/3/library/dataclasses.html)
- [attrs](https://attrs.org/)

Принципы и идеология этих (и других библиотек) схожи в одном – они позволяют реализовать всю необходимую логику работы с объектом, не дублируя код для каждого отдельного объекта.

Например:

```
>>> from dataclasses import dataclass
>>>
>>> @dataclass(init=True, repr=True, eq=True, order=True, unsafe_hash=True)
>>> class Person:
>>>     first_name: str
>>>     last_name: str
>>>     age: int
```

Данный объект будет иметь в себе:

- Три атрибута `first_name`, `last_name` и `age`, которые также будут передаваться в конструктор класса;
- Будет реализован метод `__repr__` для вывода информации для отладки;
- Будут реализованы все магические методы сравнения (такие как `__lt__`, `__eq__` и так далее), а также метод `__hash__`.

Чаще всего вы будете пользоваться уже готовыми решениями, как пример выше, но для того чтобы понять, как работает язык Python изнутри, необходимо знать, как работают магические методы, за что они отвечают, что будет, если вызвать ту или иную функцию на объект, и что с этим объектом произойдёт.

# Практика
http://github.com/SkullPiercer/solva-dunder-methods
