На предыдущем уроке мы написали класс `Dog` и на основе него создавали разные экземпляры — это были обычные собаки:
```
class Dog:

    breed_type = 'дворняга'

    def __init__(self, bark_type_value):
        self.bark_type = bark_type_value

    def bark(self):
        print('Гав-гав!')

    def fetch(self, item):
        print(f'Принёс {item}! Порода - {self.breed_type}.')

yard_dog = Dog(bark_type_value='громкий')
home_dog = Dog(bark_type_value='тихий') 
```
Но собаки бывают не только дворовыми, но и, например, служебными. И дворовые, и служебные могут лаять и приносить предметы, у каждой есть хвост и лапы, но набор характеристик и функций у служебной собаки заметно шире, чем у дворовой. Там есть навыки охраны, поиск предметов и выполнение команд, или, как сказали бы программисты, новые **атрибуты и методы**.
### Реальность и программирование
В дикой природе волк — это предок собаки. Собака унаследовала от волка многие базовые черты и повадки, а затем развилась в разные породы с уникальными навыками.

В программировании это можно представить так:
- **Wolf** (волк) — родительский класс, задающий основные характеристики и поведение;
    
- **Dog** (собака) — класс, который наследует от волка все базовые свойства и методы;
    
- **ServiceDog** (служебная собака) — дочерний класс, расширяющий класс собаки дополнительными умениями и функциями.

Дочерние классы наследуют от родительских все атрибуты и методы, но при этом могут добавлять свои собственные уникальные возможности.
                 ![[Pasted image 20250523150953.png]]

### Родительский класс

Родительский класс волка — `Wolf`. Это базовый класс с инициализатором, атрибутами и методами, с помощью которого можно создавать объекты:
```
class Wolf:
    species = 'Волк'

    def __init__(self, howl_type):
        self.howl_type = howl_type

    def howl(self):
        print('Ауууууу!')

    def hunt(self, prey):
        print(f'Охочусь на {prey}! Вид: {self.species}.')

```
Создадим экземпляр класса волка:
```
grey_wolf = Wolf('громкий вой')

print(grey_wolf.species)
grey_wolf.howl()

```

Выведется:
```
Волк
Ауууууу!
```
### Дочерний класс

Чтобы создать дочерний класс, нужно указать, что он наследует свойства и методы от родительского класса. Для этого используется такой синтаксис:
```
class ИмяДочернегоКласса(ИмяРодительскогоКласса):
    pass
```
Например, если у нас есть родительский класс `Wolf` (волк), то дочерним классом может быть `Dog` (собака), который описывает особенности домашних собак.

Названия для дочерних классов выбирает разработчик — строгих правил по именованию нет, главное, чтобы имена не повторялись.

Важно помнить, что в Python сначала нужно определить родительский класс, а уже потом создавать от него наследников. Это связано с тем, что интерпретатор читает код сверху вниз, и если попытаться создать дочерний класс раньше, чем объявлен родительский, возникнет ошибка, так как Python не сможет найти описание родительского класса.
Пример правильного порядка:
```
class Wolf:
    pass

class Dog(Wolf):
    pass

```

Родительский класс
```
class Wolf:

    # Атрибут базового класса.
    species = 'Волк'

    # Инициализатор базового класса.
    def __init__(self, howl_type):
        self.howl_type = howl_type

    # Метод базового класса.
    def howl(self):
        print('Ауууууу!')

    # Ещё один метод базового класса.
    def hunt(self, prey):
        print(f'Волк охотится на {prey}!')
```

Дочерний класс, унаследованный от `Wolf`
```
class Dog(Wolf):
    pass

```

В теле нового класса нет кода, но он полностью функционален, так как наследует все методы и атрибуты родительского класса `Wolf`.

Например, можно создать объект класса `Dog`, задать ему тип воя и вызвать метод воя:
```
dog = Dog('тявкающий вой')

dog.howl()
```
Выведется:
```
Ауууууу!
```

### Переопределение атрибутов и методов

Класс `Dog` унаследовал все, что есть в `Wolf`, включая атрибут `species` со значением `'Волк'`. Но собаки — это отдельный вид, у них другие особенности. Чтобы это отразить в коде, можно переопределить атрибут `species` и изменить поведение метода `howl`.

Пусть в классе `Dog` атрибут `species` будет `'Собака'`, а звук будет не вой, а лай: `'Гав-гав!'`.
```
class Dog(Wolf):
    species = 'Собака'

    def howl(self):
        print('Гав-гав!')

```
Теперь если создать объект `Dog` и вызвать `howl()`:
```
dog = Dog('тявкающий вой')

print(dog.species)
dog.howl()
```
Выведется:
```
Собака
Гав-гав!

```
Таким образом, наследование помогает повторно использовать код, а переопределение позволяет менять поведение дочерних классов, не трогая родительский.

# Переопределение атрибутов и методов
Представим, что у нас есть базовый класс **Animal** с атрибутом `sound_type`, который по умолчанию равен `'природный'`. А теперь создадим класс **Wolf**, у которого этот атрибут будет иметь значение `'дикий'`. Кроме того, волк будет издавать другой звук — вместо привычного «Гав-гав!» он будет говорить «Ауууу!».

```
class Animal:
    sound_type = 'природный'

    def __init__(self, name):
        self.name = name

    def make_sound(self):
        print('Гав-гав!')

    def introduce(self):
        print(f'Это {self.name}. Звук типа: {self.sound_type}.')
        

class Wolf(Animal):
    # Меняем значение атрибута sound_type на 'дикий'
    sound_type = 'дикий'

    # Переопределяем метод make_sound()
    def make_sound(self):
        print('Ауууу!')

```
Теперь создадим объекты классов:
```
dog = Animal('Собака')
wolf = Wolf('Волк')

print(dog.sound_type)
dog.make_sound()

print(wolf.sound_type)
wolf.make_sound()
```
Результат будет таким:
```
природный
Гав-гав!
дикий
Ауууу!
```
Несмотря на то что и собака, и волк имеют одинаковый метод и атрибут с одинаковыми именами, результат их работы отличается. 

### Добавляем уникальные свойства и поведение

Волки отличаются от собак не только звуком — у них есть и свои уникальные черты. Например, у каждого волка есть охотничьи навыки и стая, в которой он живет. В то время как у обычной собаки таких характеристик нет.

Это можно отразить в коде, добавив новые атрибуты и методы в класс **Wolf**, которые отсутствуют у класса **Animal**.

Например:
- Атрибут класса `pack_size` — размер стаи волка (общий для всех волков).
    
- Атрибут экземпляра `hunt_skill` — уровень охотничьих навыков.
    
- Метод `howl()` — заставляет волка выть.
    

Атрибут `pack_size` будет общим для всех волков, его удобно объявить как переменную класса:
```
class Wolf(Animal):
    sound_type = 'дикий'
    pack_size = 8  # по умолчанию в стае 8 волков

    def __init__(self, name, hunt_skill):
        self.hunt_skill = hunt_skill
        super().__init__(name)

    def make_sound(self):
        print('Ауууу!')

    def howl(self):
        print('Вой воет на луну!')

```
Обратите внимание, что мы добавили инициализатор с новым параметром `hunt_skill` и вызвали родительский инициализатор с помощью `super()`.

### Что такое `super()`?
`super()` — это встроенная функция Python, которая позволяет вызвать метод родительского класса из дочернего. Это особенно важно при работе с **наследованием** — когда дочерний класс переопределяет методы, но при этом нужно вызвать реализацию этих методов из родительского класса, чтобы не потерять его функциональность.
### Почему это нужно?
Когда вы создаёте дочерний класс, вы можете **переопределить** его методы, включая конструктор `__init__`. Но иногда родительский конструктор выполняет важные действия — например, инициализирует атрибуты, которые нужны и дочернему классу.

Если вы не вызовете родительский инициализатор в дочернем, то эти действия не выполнятся, и объекты дочернего класса могут оказаться неполноценно инициализированными.

```
class Test_One:
    def __init__(self):
        self.value = 51

  

class Test_Two(Test_One):
    def __init__(self):
        super().__init__()
        self.result = self.value * 2

  
  

test_case = Test_Two()

print(test_case.result)

выведет: 102
```

Если мы не напишем 
```
super().__init__()
```
В конструкторе нашего класса то мы не сможем провести расчеты в дочернем и на выходе получим:
```
AttributeError: 'Test_Two' object has no attribute 'value'
```
Использование новых возможностей:
```
wolf = Wolf('Серый', hunt_skill=7)

print(wolf.pack_size)       # общий атрибут для всех волков
print(wolf.hunt_skill)      # индивидуальный навык охоты
wolf.howl()                 # вызываем новый метод
```
Выведет:
```
8
7
Вой воет на луну!
```
### Итог

Объекты дочернего класса **Wolf** имеют доступ как к унаследованным атрибутам и методам, так и к своим уникальным. В то же время объекты базового класса **Animal** не могут использовать возможности волка.

Если попробовать обратиться к атрибуту `pack_size` через объект собаки, будет ошибка:
```
dog = Animal('Собака')
print(dog.pack_size)  # Ошибка AttributeError
```
### Кратко о классах в Python

Хотя в объявлении класса **Animal** мы явно не указываем его родителя, на самом деле все классы в Python неявно наследуют от базового класса `object`. Это даёт им доступ ко множеству встроенных методов, таких как `__str__()`, `__repr__()` и другим.
<img src="Pasted image 20250523153458.png" width="300">

# Практика
### Задача 1. Транспортные средства
Создайте базовый класс `Vehicle` с атрибутом `max_speed` и методом `drive()`, который выводит строку `"Едем со скоростью {max_speed} км/ч"`.

Создайте дочерний класс `Car`, у которого скорость по умолчанию 150, и переопределите метод `drive()`, чтобы он выводил `"Машина едет со скоростью {max_speed} км/ч"`.

Создайте дочерний класс `Boat`, у которого скорость по умолчанию 80, и переопределите метод `drive()`, чтобы он выводил `"Лодка плывет со скоростью {max_speed} км/ч"`.

---

### Задача 2. Животные и звуки
Создайте класс `Animal` с методом `make_sound()`, который выводит строку `"Животное издает звук"`.

Создайте два дочерних класса: `Dog` и `Wolf`.
- В классе `Dog` переопределите метод `make_sound()`, чтобы выводилось `"Гав-гав!"`.
    
- В классе `Wolf` переопределите метод `make_sound()`, чтобы выводилось `"Аууу!"`.

Создайте объекты обоих классов и вызовите их методы `make_sound()`.

---

### Задача 3. Класс с родительским и дочерним инициализатором
Создайте класс `Person` с конструктором, который принимает имя и возраст, и сохраняет их в атрибуты.

Создайте класс `Student`, наследующий от `Person`, у которого есть ещё атрибут `university`. Используйте `super()` для вызова конструктора `Person`.

Напишите метод `introduce()`, который выводит строку `"Меня зовут {name}, мне {age} лет, я учусь в {university}"`.

---

### Задача 4. Магазин и специальные предложения

Создайте класс `Product` с атрибутом `price` и методом `get_price()`, который возвращает цену.

Создайте дочерний класс `DiscountedProduct`, в котором переопределите метод `get_price()`, чтобы возвращать цену со скидкой 20%.

Создайте объекты обоих классов с ценой 100 и выведите результат метода `get_price()`.

---

### Задача 5. Игровые персонажи

Создайте класс `Character` с атрибутами `name` и `health`. В конструкторе задайте эти атрибуты.

Создайте дочерний класс `Mage`, у которого есть дополнительный атрибут `mana`.

Используйте `super()` для вызова конструктора `Character`, а в конструкторе `Mage` добавьте инициализацию `mana`.

Напишите метод `cast_spell()`, который выводит `"Маг {name} использует заклинание! Осталось маны: {mana}"`.

# Дополнительные задачи
https://www.hackerrank.com/challenges/30-inheritance/problem
https://www.hackerrank.com/challenges/java-inheritance-1/problem
https://www.hackerrank.com/challenges/java-inheritance-2/problem
https://leetcode.com/problems/throne-inheritance/description/
