В Python можно передавать в аргументы любые объекты, включая функции. При этом имя функции передаётся без скобок — таким образом передаётся ссылка на неё, а не результат её вызова. Кроме того, функции могут использоваться и как возвращаемые значения из других функций.

Именно эти особенности языка лежат в основе концепции декораторов в Python. Декораторы дают возможность менять поведение функций, методов или классов без необходимости править их исходный код.

Проще говоря, декоратор — это функция A, которая принимает на вход другую функцию B и возвращает функцию C. Функция C при выполнении запускает функцию B и может дополнительно выполнять свои действия. Аналогичным образом можно обрабатывать и классы — декоратор принимает класс и меняет его функциональность.

Например, с помощью функции mega_decorator() можно изменить поведение функции any_function():

```
def mega_decorator(func):
    def wrapper():
        print('Действия до вызова декорируемой функции.')
        func()  # Вызываем декорируемую функцию.
        print('Действия после вызова декорируемой функции.')
    return wrapper


def any_function():
    print('Абслоютно любой функционал')
    print('Самой обычной функции')
  

decorated_function = mega_decorator(any_function)
decorated_function()

# Вывод:
# Действия до вызова декорируемой функции.
# Абслоютно любой функционал
# Самой обычной функции
# Действия после вызова декорируемой функции.
```
Функция **mega_decorator** принимает в качестве аргумента ссылку на функцию **any_function**. Внутри **mega_decorator** определяется вспомогательная функция **wrapper**, которая и возвращается в операторе `return`. Таким образом, **mega_decorator** получает функцию на вход и возвращает функцию-обёртку.

После этого имя **decorated_function** становится ссылкой на внутреннюю функцию **wrapper**, но внутри **wrapper** хранится ссылка на исходную функцию **any_function**. При вызове **wrapper** сначала выполняется одна команда `print()`, затем вызывается оригинальная функция **any_function**, после чего выполняется ещё один `print()`. Таким образом, декоратор «оборачивает» исходную функцию, изменяя её поведение, не трогая при этом сам исходный код функции.

Python предоставляет удобный и лаконичный синтаксис для использования декораторов — его часто называют «синтаксическим сахаром». Благодаря этому, следующий код делает то же самое, что и предыдущий пример, но написан более кратко и понятно:
```
def mega_decorator(func):
    def wrapper():
        print('Действия до вызова декорируемой функции.')
        func()  # Вызываем декорируемую функцию.
        print('Действия после вызова декорируемой функции.')
    return wrapper


@mega_decorator
def any_function():
    print('Абслоютно любой функционал')
    print('Самой обычной функции')


any_function()

# Вывод:
# Действия до вызова декорируемой функции.
# Абслоютно любой функционал
# Самой обычной функции
# Действия после вызова декорируемой функции.
```
Декоратор, применённый с помощью записи `@mega_decorator` перед объявлением функции **any_function**, фактически выполняет ту же работу, что и присваивание `decorated_function = mega_decorator(any_function)`.

Кроме того, к одной функции или классу можно применить сразу несколько декораторов, прописывая их последовательно — каждый из них обернёт объект и внесёт свои изменения в поведение.

Декораторы применяются сверху вниз, но срабатывают они в обратном порядке — снизу вверх.

То есть, если у тебя несколько декораторов, записанных так:
```
@decorator1
@decorator2
def func():
    pass
```
То сначала вызывается `decorator2(func)`, результат которого передаётся в `decorator1`. В итоге функция `func` сначала оборачивается в `decorator2`, а потом результат — в `decorator1`.

То есть, фактически, декораторы применяются «снизу вверх», начиная с ближайшего к определению функции.

Вот почему так происходит:
Когда Python встречает несколько декораторов, он читает их сверху вниз, но по сути каждый декоратор — это функция, которая принимает на вход уже обработанную функцию и возвращает новую функцию.

Процесс выглядит так:

1. Сначала берётся функция, которую нужно задекорировать.
    
2. К ней применяется самый нижний декоратор (тот, что ближе всего к определению функции). Он принимает исходную функцию и возвращает новую — обёртку.
    
3. Затем следующему сверху декоратору передаётся уже эта обёрнутая функция.
    
4. И так продолжается, пока все декораторы не будут применены.

Это похоже на каскад — каждое последующее изменение происходит на базе результата предыдущего. Поэтому порядок вызова функций-декораторов получается обратным по отношению к их расположению в коде.

Если представить декораторы как несколько вложенных коробок, то сначала помещается внутренняя коробка (нижний декоратор), затем вокруг неё — следующая (верхний декоратор), и так далее. В итоге, когда вызывается итоговая функция, сначала срабатывает внешний декоратор (верхний в списке), который может делать свои дела и потом вызвать внутренние.

Без `@wraps`:
```
def my_decorator(func):
    def wrapper(*args, **kwargs):
        """Функция-обёртка"""
        print("До вызова функции")
        result = func()
        print("После вызова функции")
        return result
    return wrapper

@my_decorator
def say_hello():
    """Говорит приветствие"""
    print('Привет!')

print(say_hello.__name__)  # wrapper
print(say_hello.__doc__)   # Функция-обёртка
```
Здесь `say_hello` после декорирования теряет своё оригинальное имя и описание. Вместо `say_hello` теперь функция называется `wrapper`, и её `__doc__` тоже взят из обёртки.

С `@wraps`:
```
from functools import wraps

def my_decorator(func):
    @wraps(func)
    def wrapper():
        """Функция-обёртка"""
        print("До вызова функции")
        result = func()
        print("После вызова функции")
        return result
    return wrapper

@my_decorator
def say_hello():
    """Говорит приветствие"""
    print('Привет!')

print(say_hello.__name__)  # say_hello
print(say_hello.__doc__)   # Говорит приветствие
```
Благодаря `@wraps(func)`, у `say_hello` после декорирования остаётся правильное имя и документация, как у исходной функции.

### Можно ли декорировать функцию, принимающую аргументы?
Если просто задекорировать, то возникнет ошибка:
```
from functools import wraps

  
def my_decorator(func):
    @wraps(func)
    def wrapper():
        """Функция-обёртка"""
        print("До вызова функции")
        result = func()
        print("После вызова функции")
        return result
    return wrapper


@my_decorator
def say_hello(name):
    """Говорит приветствие"""
    print(f'Привет {name}!')

say_hello()

Вывод:
TypeError: say_hello() takes 0 positional arguments but 1 was given
```
Проблема в том, что внутренняя функция декоратора `wrapper()` не принимает аргументов. Нужно добавить их обработку:
```
from functools import wraps

  
def my_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        """Функция-обёртка"""
        print("До вызова функции")
        result = func(*args, **kwargs)
        print("После вызова функции")
        return result
    return wrapper


@my_decorator
def say_hello(name):
    """Говорит приветствие"""
    print(f'Привет {name}!')
  

say_hello('Sasha')

Выводит:
До вызова функции
Привет Sasha!
После вызова функции
```

### Как использовать декораторы для классов?

Декораторы классов в целом аналогичны декораторам функций.
```
def add_two_decorator(decorated_class):
    decorated_class.attr += 2
    return decorated_class


@add_two_decorator
class SimpleClass():
    attr = 1


print(SimpleClass.attr)

# 3
```
Декораторы классов применяются не так часто, как декораторы функций, потому что задачи, которые решаются декораторами, можно решить, например, через обычное наследование.

# Практика
https://github.com/SkullPiercer/solva-decorators