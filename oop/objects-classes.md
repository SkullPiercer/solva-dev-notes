**Объектно-ориентированное программирование (ООП)** — это способ написания программ (методология), в котором мы представляем части программы как «объекты», похожие на реальные вещи. Каждый объект — это как «предмет» с **характеристиками** (например, цвет, размер) и **поведением** (что он умеет делать).

Мы сначала создаём **класс** — это как чертёж или шаблон, по которому можно создавать объекты. 
![[Pasted image 20250523104200.png]]
А сами объекты, сделанные по этому чертежу, называются **экземплярами класса**.
![[Pasted image 20250523104809.png]]

Например, если класс — это "Машина", то экземпляры — это конкретные машины: красная машина, синяя машина и т.д.

**Идея ООП** в том, что мы пишем программу не просто как набор команд, а как **модель реального мира**, где всё представлено в виде объектов — людей, машин, заказов, сообщений и т.д.

Это помогает нам **не теряться в куче кода**, а **разделить всё по смыслу** — каждый объект отвечает за себя, знает, что он умеет, и сам решает, как это делать.

Такой подход помогает:

- **лучше понимать**, что делает программа;
    
- **легче вносить изменения**;
    
- **работать в команде над большим проектом**, где каждый отвечает за свою часть.
    
То есть ООП делает код **более управляемым, понятным и масштабируемым**.

Когда мы говорим про **управляемость** в больших программах с иерархией (например, много связанных классов и объектов), важно:

- **Избегать повторения данных** — чтобы одна и та же информация не хранилась в нескольких местах (это похоже на правила нормализации в базах данных).
    
- **Обеспечивать целостность данных** — чтобы данные были правильными и согласованными.

Если с этим всё в порядке, то программу **легко поддерживать и понимать**.

Проще говоря, если мы грамотно организуем данные и связи между ними, то:

- программисту будет проще понять, что происходит;
    
- код будет проще использовать и изменять в будущем.

### Пример 1: **Хорошая организация (принципы соблюдены)**

Представим, что у нас есть программа для магазина с товарами и категориями.
```
class Category:
    def __init__(self, name):
        self.name = name

class Product:
    def __init__(self, name, category):
        self.name = name
        self.category = category
```
Здесь:
- Категории и товары — отдельные объекты.
    
- Товар хранит **ссылку на категорию**, а не копирует её название.
    
- Если категория изменится, все товары ссылаются на новую категорию — никаких дублирующих данных.
### Пример 2: **Плохая организация (принципы не соблюдаются)**

Теперь представим, что у каждого товара хранится категория просто в виде текста, и это повторяется для всех товаров:
```
class Product:
    def __init__(self, name, category_name):
        self.name = name
        self.category_name = category_name  # текстовое поле с категорией

```
И список товаров:
```
products = [
    Product('Смартфон', 'Электроника'),
    Product('Наушники', 'Электроника'),
    Product('Молоко', 'Продукты'),
    Product('Хлеб', 'Продукты'),
]

```
Здесь:
- Категория хранится как текст у каждого товара.
    
- Если надо изменить название категории "Электроника" на "Гаджеты", нужно искать и менять это в каждом товаре.
    
- Легко сделать ошибку — например, написать "Електроника" с опечаткой.
    
**Почему это плохо?**  
Данные дублируются, их сложнее поддерживать и легко запутаться.

Таким образом, когда мы решаем **тактическую задачу** — сделать программу удобной для управления, мы одновременно решаем **стратегическую задачу** — сделать программу понятной и удобной для всех, кто с ней работает.

![[Pasted image 20250523110850.png]]

**Если подвести итог
Класс — это **чертёж** или **шаблон** для создания объектов. Представьте, что класс — это рецепт, а объект — это блюдо, приготовленное по этому рецепту.
```
class Dog:
    pass 
```
Объект — это **конкретный экземпляр класса**. Если класс — это чертёж, то объект — уже построенный дом по этому чертежу.
```
my_dog = Dog()
```

# Методы класса
Методы - процедуры и функции, связанные с классом. Они определяют действия, которые можно выполнять над объектом такого типа, и которые сам объект может выполнять.

Проще говоря, методы — это **действия или команды**, которые можно применять к объекту. Объект «знает», как выполнить эти действия сам.

Например, если у нас есть класс **«Машина»**, то методы могут быть такими: **завести двигатель**, **поехать**, **остановиться** — это то, что машина умеет делать.

Давайте напишем нашему классу Dog метод, который позволит нашей собаке выводить в консоль: "Bark Bark"
```
class Dog:

    def say_bark(self):

        return 'Bark Bark'

```
Для того чтобы увидеть как наш Шарик будет гавкать, необходимо создать экземпляр класса Dog и вызвать соответствующий метод
```
sharik = Dog()
print(sharik.say_bark())
```
Отлично! Наш шарик научился гавкать

![[Pasted image 20250523111735.png]]

# Конструктор класса
Вот незадача: у меня есть две собаки, и обе зовут Шарик. Но одна — щенок, а другая — старая собака. Как быть?

Тут нам на помощь придет конструктор класса:
```
def __init__(self, name, age):
	...
```
Конструктор `__init__` используется для инициализации атрибутов объекта при его создании. Это значит, что когда я создаю объект класса Dog мне нужно будет передать его атрибуты.
**Атрибуты** — это **данные**, которые **описывают свойства объекта**.
- `self.name` — это **атрибут** объекта, то есть конкретное имя собаки.
    
- `self.age` — это **атрибут**, который хранит возраст.

Давайте посмотрим как это будет выглядеть в коде:
```
class Dog:

    def __init__(self, name, age):
        self.name = name
        self.age = age

  
    def say_bark(self):
        return 'Bark Bark'
```

И сразу создадим двух Шариков:
Если мы не передадим атрибуты то получим ошибку
```
TypeError: Dog.__init__() missing 2 required positional arguments: 'name' and 'age'
```
Теперь мы не можем создать Шарика не указав его имя и возраст, надо это исправить
```
sharik = Dog('Sharik', 10)
sharik_jr = Dog('Sharik', 1.5)
```
## Но это только начало
Теперь, когда каждый объект класса Dog имеет свой собственный набор свойств, мы не можем этим не воспользоваться.
Мы можем посмотреть сколько лет конкретной собаке:
```
print(sharik.age)
print(sharik_jr.age)
```
Вывод:
```
10
1.5 
```

Эти свойства мы можем вызывать прямо в методы нашего класса:
```
class Dog:

    def __init__(self, name, age):
        self.name = name
        self.age = age

  

    def say_bark(self):
        return 'Bark Bark'

    def greeting(self):
        return (
                f'Woof! My name is {self.name} '
                f'And I`m {self.age} years old!'
            )
```
Функция `greeting(self)` — это метод внутри класса, который возвращает строку с приветствием от имени собаки. Когда вызывается этот метод, например `dog.greeting()`, Python передаёт в него сам объект `dog` как `self`. Далее внутри метода используется `self.name` и `self.age`, чтобы подставить в строку имя и возраст этой конкретной собаки. То есть эта функция позволяет собаке "поздороваться" и рассказать о себе, используя информацию, которую мы ей дали при инициализации.

Рассмотрим на примере:
```
sharik = Dog('Sharik', 10)
print(sharik.greeting())
```
Вернет нам:
```
Woof! My name is Sharik And I`m 10 years old!
```

В то время как вторая собака:
```
sharik_jr = Dog('Sharik', 10)
print(sharik_jr.greeting())
```
Вернет нам:
```
Woof! My name is Sharik And I`m 1.5 years old!
```
Отлично! Теперь у нас есть два совершенно разных Шарика и каждый знает сколько ему лет.
![[Pasted image 20250523115839.png]]


# Задания на реализацию:
1) Создай класс `Car`, который при создании принимает марку и цвет автомобиля. Добавь метод `info`, который возвращает строку вида: "Марка: <марка>, Цвет: <цвет>". Создай два объекта этого класса с разными значениями и вызови у них метод `info`.

2) Напиши класс `Student`, принимающий имя и класс (например, 5 или 10). Добавь метод `say_hello`, который возвращает строку "Привет, я <имя> и учусь в <класс> классе". Создай несколько студентов и проверь работу метода.

3) Создай класс `Rectangle`, который принимает ширину и высоту. Добавь метод `area`, который возвращает площадь прямоугольника (ширина × высота). Создай несколько прямоугольников с разными размерами и выведи их площадь.

4) Создай класс `Book`, принимающий название, автора и год выпуска книги. Добавь метод `describe`, который возвращает строку: '"<название>" by <автор> (<год>)'. Проверь работу метода на нескольких книгах.

5) Реализуй класс `BankAccount`, который при создании получает имя владельца и начальный баланс. Добавь методы `deposit(amount)` для пополнения баланса, `withdraw(amount)` для снятия средств и `check_balance()`, который возвращает текущий баланс.

6) Напиши класс `Person`, который хранит имя и возраст. Добавь метод `is_adult`, который возвращает `True`, если возраст 18 лет и больше, иначе `False`. Проверь метод на нескольких людях разного возраста.

7) Реализуй класс `Temperature`, принимающий температуру в градусах Цельсия. Добавь метод `to_fahrenheit`, который возвращает температуру, переведённую в градусы Фаренгейта по формуле `(C * 9/5) + 32`.

8) Напиши класс `Movie`, в котором хранятся название фильма, рейтинг (от 1 до 10) и длительность в минутах. Добавь метод `is_long`, который возвращает `True`, если длительность больше 120 минут, и `False` в остальных случаях.

9) Создай класс `User`, который при инициализации принимает имя и дату рождения в виде строки `"ГГГГ-ММ-ДД"` (например, `"2000-04-15"`). Используя модуль `datetime`, добавь метод `get_age()`, который возвращает возраст пользователя в полных годах на сегодняшний день. Также добавь метод `greeting()`, который возвращает строку: `"Привет, меня зовут <имя>, и мне <возраст> лет."`

10) Создай два класса: `Owner` и `Pet`. Класс `Owner` должен содержать имя и телефон владельца. Класс `Pet` должен содержать имя питомца, его вид (например, собака или кошка) и владельца, который по умолчанию равен `None`. Добавь в класс `Pet` метод `set_owner`, который позволяет установить владельца, и метод `info`, который возвращает строку с информацией о питомце: если владелец установлен, выводит имя, вид питомца, имя и телефон владельца; если владелец не установлен — сообщает, что хозяин не найден.

# Репозиторий с финальными задачами:
https://github.com/SkullPiercer/Solva-oop-exercises

# Дополнительные материалы:
задачи:
https://leetcode.com/problems/design-a-stack-with-increment-operation/
https://leetcode.com/problems/min-stack/description/
https://leetcode.com/problems/exclusive-time-of-functions/description/

Литература:
https://leetcode.com/discuss/post/1852219/object-oriented-programming-made-easy-by-r383/