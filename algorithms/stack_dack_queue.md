### Что такое стек

Стек (от англ. _stack_ — «стопка») — это структура данных, которая часто встречается и в программировании, и в повседневной жизни. Она работает по принципу: **«последним положили — первым достали»** (или _LIFO_ — _Last In, First Out_).

Представьте, что вы печёте блины и складываете их один на другой. Каждый новый блин оказывается сверху. Когда кто-то захочет съесть блин, он возьмёт именно верхний — никто не будет лезть в середину стопки.

Так же ведёт себя и стек. Данные добавляются и извлекаются **только с вершины**. Получить доступ к середине или началу невозможно — только к самому последнему добавленному элементу.
### Где используется стек

Примеры из жизни и программирования:
- Кнопка **«Назад»** в браузере: возвращает вас к последним посещённым страницам — сначала к последней, затем к предыдущей.
    
- **Отмена действий** в редакторе: при каждом нажатии отменяется последнее изменение.

Все эти действия строятся на том, что последняя операция сохраняется сверху, и при откате она откатывается первой.

### Интерфейс стека

Хотя стек может использовать массив (или список) для хранения данных, его ключевая особенность — **ограниченный доступ к данным**. В отличие от обычного массива, стек **не даёт заглянуть внутрь** — только на вершину.

Поэтому набор методов у него весьма ограничен:
- `push(item)` — добавить элемент на вершину;
    
- `pop()` — снять и вернуть верхний элемент;
    
- `size()` — узнать, сколько элементов в стеке.

Иногда добавляют дополнительные методы:
- `peek()` или `top()` — посмотреть, что на вершине, не удаляя;
    
- `is_empty()` — проверить, пуст ли стек.
### Стек на Python

В Python список (`list`) отлично подходит для реализации стека. Официальная документация также рекомендует использовать его.

Вот как основные методы списка соответствуют методам стека:

- `append()` → добавление (`push`);
    
- `pop()` → извлечение верхнего элемента;
    
- `len()` → размер стека.

> Важно: обычный список в Python — это более универсальная структура. Он позволяет вставлять элементы в середину, делать срезы, копировать. Но для работы стека такие операции избыточны. Поэтому, чтобы избежать случайного использования лишнего, лучше **реализовать свой класс**, внутри которого будет использоваться список.

### Пример реализации стека через класс

```
class Stack:
    def __init__(self):
        self.__items = []

    def push(self, item):
        self.__items.append(item)  # Добавить на вершину

    def pop(self):
        return self.__items.pop() if not self.is_empty() else None  # Удалить верхний элемент

    def peek(self):
        return self.__items[-1] if not self.is_empty() else None  # Посмотреть на верхушку

    def is_empty(self):
        return len(self.__items) == 0  # Проверка на пустоту

    def size(self):
        return len(self.__items)  # Кол-во элементов в стеке
```

### Защита данных и смысл названия

Когда вы используете список внутри класса, как это сделано в реализации стека, сам список **скрыт от пользователя**. Он не виден снаружи напрямую — доступ к нему возможен только через методы, специально предусмотренные классом.

Да, технически к атрибуту `__items` можно добраться, но это непросто — и явно нарушает принципы инкапсуляции. Это делает работу с классом более **безопасной и контролируемой**.

Ещё одно преимущество — **само название класса говорит за себя**. Если вы видите `Stack`, сразу понятно, что это стек, и какие действия с ним допустимы. Это снижает вероятность ошибки при использовании.
### Только нужные действия

Внутри класса реализованы только те методы, которые **соответствуют логике работы стека**. Нет операций по поиску элемента по значению, вставке или удалению из середины. Всё строго: либо добавить на вершину, либо снять с неё.

Такое поведение делает стек **надежной и предсказуемой структурой данных** — пользователь просто не может использовать его не по назначению.
### Немного о производительности

Если стек реализован на основе **динамического массива** (например, стандартного списка `list` в Python), то он работает быстро. Однако у него есть одна особенность: при большом количестве элементов может произойти **реаллокация памяти** — когда Python создаёт новый массив большего размера и переносит в него все элементы.

Такой перенос — это нечастая операция, но она считается **самой затратной**: в этом случае сложность увеличивается до `O(n)`, где `n` — количество элементов в стеке. В обычной ситуации операции `push()` и `pop()` работают за `O(1)`.

Временные характеристики операций со стеком (реализация на массиве)
|Операция|Время в среднем|Время в худшем случае|
|---|---|---|
|Добавление элемента в стек (push)|O(1)|O(n)|
|Извлечение элемента со стека (pop)|O(1)|O(n)|
|Определение размера стека (size)|O(1)|O(1)|


### Структура данных «очередь»

Очередь — это как очередь в магазин: кто пришёл первым, тот и будет обслужен первым. Такая структура данных работает по принципу **FIFO** (_first in, first out_ — «первым пришёл, первым ушёл»).  
Все элементы, как и в реальной очереди, добавляются «в конец», а извлекаются строго с начала — в том порядке, в котором поступили.

Очередь, как и стек, — **абстрактная структура данных**, то есть, это не конкретный способ хранения данных, а **интерфейс** — правила, по которым можно взаимодействовать с элементами.  
Добавление и извлечение происходят строго по правилам: нельзя вытащить элемент из середины, как нельзя проскочить вперёд в очереди у кассы.

В отличие от стека, где работает принцип LIFO (последний пришёл — первый ушёл), в очереди всё наоборот: первым обрабатывается самый «старый» элемент, тот, кто стоит у самого начала.

И стек, и очередь не позволяют:
- доставать элементы по индексу;
    
- вставлять или удалять элементы в середине;
    
- обращаться к значениям напрямую — только по правилам интерфейса.

Такие ограничения делают очередь удобной там, где важен **порядок поступления**: например, при обработке запросов, задач или данных в потоке.
### Интерфейс очереди

Очередь — это не столько способ хранения данных, сколько **правила работы с ними**. Как и стек, она описывает, **что можно делать с элементами**, а не **где они физически лежат** в памяти.  
Главное правило: данные обрабатываются в порядке поступления — сначала пришёл, первым обработался.

Чтобы быть настоящей очередью, структура должна поддерживать базовые операции:
- `enqueue(item)` — добавить элемент в конец очереди;
    
- `dequeue()` — извлечь элемент из начала очереди;
    
- `size()` — узнать, сколько элементов в очереди;
    
- `is_empty()` — проверить, пуста ли очередь.

При этом хорошая реализация должна обеспечивать **быстродействие** — желательно, чтобы добавление и извлечение занимали **O(1)** времени (константное, вне зависимости от длины очереди).

В Python есть несколько готовых реализаций очереди:
- `multiprocessing.Queue` — используется, когда нужно обмениваться данными между процессами;
    
- `queue.Queue` — создана для работы в многопоточном режиме;
    
- `queue.SimpleQueue` — простой и нетребовательный вариант, не рассчитанный на потоки и процессы.

Но чаще всего программисты используют **двустороннюю очередь `deque`** из модуля `collections`. Она удобна, быстра и универсальна — может быть обычной очередью, стеком и даже чем-то средним между ними. И что особенно приятно — операции добавления и удаления элементов с обеих сторон выполняются за O(1).

### Дек
Стек удобен, очередь тоже, но что если нам нужно **больше гибкости**? Например, добавлять элементы **и в начало, и в конец**, а потом так же свободно извлекать — **откуда угодно**.  
Для этого и существует специальная структура данных — **дек** (от англ. _deque_, сокращение от _double-ended queue_, «очередь с двумя концами»).

Название говорит само за себя: **дек — это очередь, у которой оба конца «открыты»**. Ты можешь:

- добавить элемент в начало;
    
- добавить в конец;
    
- извлечь из начала;
    
- извлечь из конца.

Такой интерфейс полезен, когда нужна не строгая очередь или стек, а что-то более гибкое. Дек отлично подходит, например, для реализации истории действий, алгоритмов слайдинга по массиву, или буферов, где нужно контролировать оба края данных.

В Python есть готовый инструмент — **`collections.deque`**. Это быстрая и эффективная реализация дека, где все основные операции выполняются за **O(1)**. Если стек или очередь не справляются с задачей — вполне возможно, что тебе нужен именно **дек**.

Набор методов для дека:
- `push_back(item)` — вставка нового элемента в конец;
- `pop_back()` — возврат последнего элемента и его удаление из дека;
- `push_front(item)` — вставка нового элемента в начало;
- `pop_front()` — возврат первого элемента и его удаление из дека;
- `size()` — количество элементов в деке.

Предполагается, что каждый из этих методов должен работать за константное время `O(1)`, как и в очереди.

## Встроенная реализация дека в Python
```
from collections import deque
```
У класса `deque` есть те же методы, что и у списка:

- `append()` — добавить новый элемент в конец дека,
- `extend()` — добавить к деку другой массив,
- `pop()` — получить последний элемент и удалить его из дека,
- …и все прочие.

Но есть и другие, специальные методы, присущие именно деку, например:

- `appendleft()` — добавить новый элемент в начало дека,
- `popleft()` — получить первый элемент и удалить его из дека.

Эти операции работают за константное время `O(1)`. Сравним скорость работы списка и дека:
```
# Импорт библиотеки для работы с временем.
import time
# Импорт дека.
from collections import deque

# Количество элементов в списке и в деке.
elements_count = 100000

# Засекаем время начала.
start_time = time.time()
# Сначала проверяем обычный список.
data1 = []
for data_index in range(elements_count):
    # Каждый раз вставляем элемент в начало списка.
    data1.insert(0, f'Элемент номер {data_index}')
# Печатаем время выполнения для списка.
print(time.time() - start_time)

# Засекаем новое время для дека.
start_time = time.time()
# Создаём дек.
data2 = deque()
for data_index in range(elements_count):
    # Добавляем новые элементы в начало очереди.
    data2.appendleft(f'Элемент номер {data_index}')
# Печатаем время выполнения для дека.
print(time.time() - start_time)
```
Добавление ста тысяч элементов в начало дека выполнено в сто раз быстрее, чем в списке: в списке эта операция занимает линейное время, а в деке — константное.

## Использование дека

Дек можно использовать не только по прямому назначению (для двусторонней очереди), но и для реализации обычной очереди и даже для стека.

Дек обходится без реаллокации: в отличие от списка, деку не нужен единый блок памяти. Элементы дека могут быть разбросаны по ячейкам памяти в любом порядке — ведь от классического дека не требуется быстрый поиск по индексам.

Получается, что в общем случае реализация стека на деке будет работать быстрее, чем реализация на списке, ведь деку не нужна реаллокация.

## Максимальная длина дека

У встроенного класса `deque` есть полезная особенность: для него можно установить максимальную длину. Тогда при заполнении очереди всякий новый элемент будет выталкивать, удалять «лишние» элементы с противоположной стороны очереди.

Для ограничения размера очереди при инициализации дека надо указать параметр `maxlen`.

```
from collections import deque

data = deque(maxlen=10)

for item in range(15):
    data.appendleft(item)

print(data)
```
Когда **дек имеет ограниченную длину**, он начинает вести себя как **кольцевой буфер** — новые элементы **вытесняют** самые старые.  
Например, если в дек можно добавить не больше 5 элементов, а ты поочерёдно добавишь в него числа от 0 до 9, то **первые пять (от 0 до 4)** будут **удалены**, уступив место последним.

Такой дек полезен, когда нужно **хранить только последние события**. Вот несколько примеров:
- **Кеш**: сохраняем последние запросы.
    
- **Буфер обмена**: только несколько последних скопированных элементов.
    
- **История действий пользователя**: как в текстовом редакторе, где можно отменить, скажем, до 50 последних изменений.

Важно: это **не просто очередь**. Это именно **дек**, потому что элементы могут удаляться **и с начала, и с конца**.  
Например, пользователь сделал 50 действий — они хранятся в деке. Он отменил последнее — оно исчезает с одного конца. А если потом сделал ещё одно действие — старейшее действие вытесняется с другого конца.

# Задание на реализацию
Создайте стек и очередь на основе дека.