### Метод Brute Force (Метод полного перебора)

Метод **Brute Force** — это самый простой, «в лоб» подход к решению задачи. Он заключается в **переборе всех возможных вариантов** и проверке каждого из них. Такой способ **не учитывает никакие оптимизации** и работает медленно при больших объёмах данных, зато его **легко реализовать** и он подходит для задач с небольшими входными размерами.
### Алгоритм Brute Force — пошагово
Для задачи поиска непрерывного подмассива (среза) длины `k` с минимальной суммой:
1. Перебираем все возможные подмассивы длины `k` (начиная с индекса `0` до `n - k`).
    
2. Для каждого такого подмассива считаем сумму его элементов.
    
3. Сравниваем полученную сумму с текущим минимальным значением.
    
4. Если сумма меньше текущего минимума — обновляем минимум.
    
5. После перебора всех срезов выводим минимальную найденную сумму.
### Пример

Для массива:
```
arr = [5, -3, -2, 10, 2, 7, 1, -6, 13]
k = 4
```
Подмассивы длины 4:
- `[5, -3, -2, 10]` → сумма `10`
    
- `[-3, -2, 10, 2]` → сумма `7`
    
- `[-2, 10, 2, 7]` → сумма `17`
    
- `[10, 2, 7, 1]` → сумма `20`
    
- `[2, 7, 1, -6]` → сумма `4`
    
- `[7, 1, -6, 13]` → сумма `15`

Минимальная сумма среди них — **4**, она принадлежит подмассиву `[2, 7, 1, -6]`.
Реализация
```
def min_subarray_sum_brute_force(arr, k):
    n = len(arr)
    min_sum = float('inf')  # Начальное значение - бесконечность
    for i in range(n - k + 1):
        current_sum = sum(arr[i:i + k])
        if current_sum < min_sum:
            min_sum = current_sum
    return min_sum

# Пример
arr = [5, -3, -2, 10, 2, 7, 1, -6, 13]
k = 4
print(min_subarray_sum_brute_force(arr, k))  # Вывод: 4
```
### Временная и пространственная сложность
- **Временная сложность**: `O(n * k)` — для каждого из `n - k + 1` подмассивов суммируются `k` элементов.
    
- **Память**: `O(1)` — не создаются дополнительные структуры данных (если не считать временные срезы, которые Python оптимизирует).
### Когда использовать Brute Force
- Когда массив маленький.
    
- Когда нужно быстро набросать и проверить идею.
    
- Когда важно сначала сделать работающий код, а затем оптимизировать.
# **Анализ условия задачи**
Прежде всего, при решении алгоритмических задач важно обратить внимание на свойства входных данных и способ их хранения. Эти особенности могут значительно повлиять на выбор подхода и эффективность решения.

В наивном варианте решения применяется метод полного перебора пар элементов. Такой подход универсален и подходит даже для несортированных массивов. Однако в условиях задачи указано, что входной массив **отсортирован по возрастанию**. Это важная подсказка: возможно, мы можем использовать свойства отсортированного массива для оптимизации алгоритма.

Рассмотрим пример: массив `[1, 2, 3, 4, 5, 6, 7, 11]`, целевая сумма — `10`. Заметим, что последний элемент — `11` — больше искомой суммы. Это значит, что получить 10 с участием числа 11 можно только в сочетании с отрицательным числом. Но в массиве отрицательных чисел нет, следовательно, 11 можно **исключить из рассмотрения**.

**Рассмотрим наименьшее значение**

Так как массив отсортирован по возрастанию, его **наименьшее значение — это первый элемент**. Возьмём наш пример: массив `[1, 2, 3, 4, 5, 6, 7, 11]`, где наименьший элемент равен `1`.
```
data = [1, 2, 3, 4, 5, 6, 7, 11]
data[0] + data[len(data) - 1] > 10  # True.
```
Сумма минимального и максимального значений превышает искомую — значит, число 11 можно сразу исключить: с любым другим элементом оно даст результат больше 10.  
Далее проверим сумму минимального и предпоследнего элементов.  
1 + 7 < 10. Остальные элементы массива (кроме 11 и 7) не больше 7, а значит, сумма с единицей будет меньше искомого значения. Следовательно, и 1 можно исключить.  
Таким образом, сразу удалось отбросить два элемента без перебора остальных. Это экономит ресурсы.  
Анализ входных данных помогает выявить закономерности, позволяющие исключать заведомо неподходящие случаи. Реализовав такие приёмы в коде, можно значительно ускорить поиск.  
**Метод двух указателей** — один из таких подходов. Он используется при работе с отсортированными массивами, когда нужно найти элементы, удовлетворяющие определённому условию — например, сумму двух чисел. Также его можно применять для поиска подотрезков с заданной суммой.

Для выполнения алгоритма создаются два указателя: `left_pointer` и `right_pointer`. Каждый из них указывает на определённый элемент массива, то есть хранит индекс этого элемента. На начальном этапе `left_pointer` установлен на первый элемент массива, а `right_pointer` — на последний.
```
data = [1, 2, 3, 4, 5, 6, 7, 11]
# Указатели хранят индексы определённых элементов массива, 
# "указывают" на эти элементы.
# В начале работы указатели хранят первый и последний индексы массива.
left_pointer = data[0]
right_pointer = data[len(data) - 1]
```
Алгоритм выполняется поэтапно:
1. Указатели устанавливаются на определённые индексы массива.
    
2. Сравнивается сумма элементов, на которые указывают указатели.
    
3. В зависимости от результата сравнения один из указателей сдвигается на один шаг ближе к центру массива.
    
4. Операции повторяются.

В процессе работы левый указатель может двигаться только вправо, а правый — только влево. Таким образом, указатели постепенно сближаются, сокращая рассматриваемый участок массива. Значения, оказавшиеся за пределами этого участка, считаются не имеющими смысла для дальнейшего поиска и исключаются, как это было сделано с числами 1 и 11.

На каждом шаге выполняется проверка: если значение, на которое указывает один из указателей, не может входить в решение, указатель смещается к центру. Следующая проверка производится уже в пределах суженного диапазона.

Изначально левый указатель установлен на значение 1, а правый — на 11.

Сумма минимального и максимального значений превышает нужную сумму, значит, значение под правым указателем слишком велико и не может быть частью ответа.  
Сдвигаем правый указатель на одну позицию влево — таким образом, рассматриваемое значение становится меньше, а сумма элементов, на которые указывают указатели, также уменьшается.

Теперь правый указатель указывает на 7, а левый всё ещё на 1. Сумма 1 + 7 меньше нужного значения. Это значит, что 1 точно не участвует в решении: числа, большего 7, в массиве уже нет, а значит, нет элемента, который в сумме с 1 дал бы 10.  
Чтобы увеличить сумму, сдвигаем левый указатель вправо.

Теперь рассматриваются 2 и 7. Проверка показывает, что 2 + 7 всё ещё меньше 10 — сдвигаем левый указатель снова.  
Процесс повторяется до тех пор, пока:
- если сумма элементов превышает целевое значение — сдвигаем правый указатель влево;
    
- если сумма меньше — сдвигаем левый указатель вправо;
    
- если указатели сошлись на одном индексе — решение отсутствует (один элемент нельзя использовать дважды);
    
- если левый указатель прошёл правый — значит, варианты исчерпаны, задача не имеет решения.
```
def find_two_indexes(data, expected_result):
    # В начале работы 
    # - левый указатель указывает на первый элемент списка (с индексом 0):
    left_pointer = 0
    # - правый указатель указывает на последний элемент; 
    # индекс этого элемента на единицу меньше длины списка.
    right_pointer = len(data) - 1
    # Пока индекс левого указателя меньше индекса правого указателя.
    while left_pointer < right_pointer:
        # Считаем сумму двух элементов.
        result = data[left_pointer] + data[right_pointer]
        # Если она совпадает с искомой...
        if result == expected_result:
            # ...возвращаем ответ:
            return left_pointer, right_pointer
        # Если сумма больше искомой, то...
        if result > expected_result:
            # ...надо уменьшить сумму: уменьшаем значение правого указателя.
            right_pointer -= 1
        # Все остальные варианты относятся к случаям, когда сумма меньше искомой. 
        else:
            # Сумму надо увеличить, для этого увеличиваем значение левого указателя.
            left_pointer += 1


if __name__ == '__main__':
    data = [1, 2, 3, 4, 5, 6, 7, 11]
    expected_result = 10
    print(find_two_indexes(data, expected_result))
```
В этом подходе используется цикл `while`, а не `for`, поскольку заранее неизвестно, сколько итераций потребуется. Однако чётко определены два условия завершения цикла:  
– либо будет найдено нужное значение,  
– либо указатели сойдутся.

За одну итерацию сдвигается только один указатель, поэтому они не могут пересечься или обогнать друг друга.  
Временная сложность алгоритма — линейная (O(n)), в отличие от квадратичной в наивном варианте.  
Дополнительные структуры данных не создаются, следовательно, и память используется более эффективно.
# Метод скользящего окна
Дан массив из n целых чисел. Необходимо определить непрерывный участок массива длины k, сумма элементов которого наименьшая. Вывести эту сумму.  
Значение k всегда положительное и меньше n.  
Пример:  
массив — [3, -5, -22, 1, 2, 37, 13, -66, 131],  
k = 4.  
Нужно найти такой отрезок длины 4, у которого сумма минимальна.
Если мы визуализируем каждую рамку отдельно то получим
```
[3, -5, -22, 1]
[-5, -22, 1, 2]
[-22, 1, 2, 37]
[1, 2, 37, 13]
[2, 37, 13, -66]
[37, 13, -66, 131]
```
Если присмотреться то значение каждого среза отличается только первым и последним элементом
Данный способ называется методом скользящего окна: окно последовательно перемещается по массиву.  
Этот метод обычно используется для поиска определённого подмассива или значения, вычисленного на его основе: минимальной суммы, заданной суммы, среднего значения и т.д.  
В отличие от метода двух указателей, скользящее окно не нуждается в предварительной сортировке данных.
```
def find_min_slice_sum(data, elements_in_slice):
    # Считаем сумму первого окна.
    window_sum = sum(data[0:elements_in_slice])
    # Запоминаем результат подсчёта в качестве минимальной суммы.
    min_sum = window_sum
    # В цикле перебираем индексы массива от elements_in_slice до последнего.
    for index in range(elements_in_slice, len(data)):
        # К сумме предыдущего окна добавляем новый элемент: data[index]
        # и вычитаем "вышедший" элемент: data[index - elements_in_slice]
        window_sum += data[index] - data[index - elements_in_slice]
        # Находим минимальную сумму.
        min_sum = min(min_sum, window_sum)
    return min_sum


if __name__ == '__main__':
    data = [5, -3, -2, 10, 2, 7, 1, -6, 13]
    elements_in_slice = 4
    print(find_min_slice_sum(data, elements_in_slice))
```
