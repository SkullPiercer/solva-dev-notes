**Деревья. Теория**

Структура дерева представляет собой развитие концепции связного списка, но с расширенными возможностями: каждый элемент (узел) может быть связан не с одним, а с несколькими последующими узлами.

В деревьях узел может иметь любое количество дочерних элементов, благодаря чему структура данных становится более разветвлённой и универсальной. Это делает деревья удобными для организации информации и быстрого доступа к ней.

Одной из разновидностей деревьев является _двоичное дерево поиска_ (Binary Search Tree, или BST). Мы уже упоминали ранее, что данный тип дерева особенно хорош в плане скорости поиска данных. Такая производительность обеспечивается соблюдением двух ключевых принципов:

- У каждого узла может быть максимум два дочерних.
    
- Все значения в левом поддереве должны быть меньше значения родительского узла, а в правом — больше.
![[Pasted image 20250602112546.png]]
Поиск значения в двоичном дереве поиска (BST) выполняется за время O(log n), что позволяет находить нужную информацию даже среди огромного объёма данных — от миллионов до миллиардов элементов — за считанные мгновения.

Рассмотрим, как работает алгоритм поиска элемента со значением `x` в BST:
1. Поиск начинается с корневого узла.
    
2. Если текущий узел содержит значение `x`, поиск завершён.
    
3. Если `x` меньше текущего значения, переходим к левому дочернему узлу.
    
4. Если `x` больше текущего значения, продолжаем поиск в правом дочернем узле.
    
5. Повторяем процесс, начиная со второго шага.

Если мы не уверены, что нужный элемент точно есть в дереве, алгоритм нужно дополнить проверками на случай отсутствия подходящего узла, чтобы завершить поиск при достижении конца ветви.

# **Реализация**
Процесс создания узла дерева (`TreeNode`) во многом схож с созданием элемента связного списка (`ListNode`). Главное различие заключается в том, что у узла дерева предусмотрены два указателя — `left` и `right`, которые отвечают за связи с левым и правым дочерними узлами соответственно.

```
class TreeNode:
    def __init__(self, val=None, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

    def __repr__(self):
      return f"TreeNode со значением {self.val}"
```

В результате мы получаем дерево, состоящее из трёх уровней. Важно подчеркнуть, что это обычное двоичное дерево, а не двоичное дерево поиска (BST), поскольку значения в нём не упорядочены по правилам BST.

```
# Уровень 0
root = TreeNode('a')

# Уровень 1
root.left = TreeNode('b')
root.right = TreeNode('c')

# Уровень 2
root.left.left = TreeNode('d')
root.left.right = TreeNode('e')

root.right.left = TreeNode('f')
root.right.right = TreeNode('g')
  
#            a
#          /   \
#         b     c
#        / \   / \
#       d   e f   g
```
**Примеры**

Работая с двоичными деревьями, мы часто сталкиваемся с задачами, связанными с разными способами обхода узлов.

Обход дерева обычно начинается с корневого элемента. Далее применяются определённые шаги для обработки каждого узла, включая его потомков. То, в каком порядке будут посещаться узлы, зависит от позиции родительского элемента относительно дочерних:  
– если он обрабатывается до них — это **pre-order**;  
– между левым и правым — **in-order**;  
– после дочерних — **post-order**.

Во всех приведённых примерах обход начинался с корня дерева, однако последовательность обработки узлов различалась в зависимости от выбранного типа обхода.
![[Pasted image 20250602113834.png]]
Существует несколько способов реализовать обход дерева:
- **Итеративный подход** использует цикл `while` и структуру данных стек. При таком методе элементы извлекаются с конца, что соответствует принципу LIFO (последним пришёл — первым вышел).
    
- **Рекурсивный способ** основан на функции, которая вызывает саму себя для обработки дочерних узлов, следуя определённому порядку обхода.

Кроме этих трёх основных типов обхода, существует ещё **обход по уровням** (или **level-order traversal**). Для него применяется очередь, что позволяет обрабатывать узлы по порядку их уровней — элементы удаляются с начала очереди, согласно принципу FIFO (первым пришёл — первым вышел).

![[Pasted image 20250602113916.png]]
У первых трёх способов обхода узлов структура реализации во многом схожа — различие заключается лишь в порядке обработки. В данном случае мы сосредоточимся на **обходе в порядке возрастания** (in-order). Ниже рассмотрим два подхода к решению задачи LC 94: _Binary Tree Inorder Traversal_, начав с **итеративного метода**.
```
# Итеративный обход
def traverse_in_order(root: TreeNode) -> List[int]:
    """
    Обход двоичного дерева, возвращается список значений по порядку
    """
    answer = []
    stack = [(root, False)]   # (узел, посещен ли он еще)

    while stack:
        node, visited = stack.pop()
        if node:
            if visited:
                answer.append(node.val)
            else:
                stack.append((node.right, False))
                stack.append((node, True))
                stack.append((node.left, False))
    return answer
```

**Алгоритм выполнения:**
- **Строки 6–7:** Создаются два списка — `answer` для хранения результата и `stack` для хранения текущих узлов. В стек добавляется корневой узел в паре с флагом `False`, указывающим, что узел ещё не был обработан.
    
- **Строка 9:** Запускается цикл `while`, который продолжается, пока в стеке остаются элементы.
    
- **Строки 10–12:** Из стека извлекается последний элемент методом `.pop`. Далее проверяется, существует ли текущий узел (`node`), поскольку на более поздних этапах некоторые дочерние узлы могут быть равны `None`.
    
- **Строки 14–15:** Если узел существует и уже был отмечен как посещённый (`visited = True`), его значение добавляется в итоговый список.
    
- **Строки 16–19:** В стек последовательно помещаются: правый дочерний узел (с флагом `False`), сам текущий узел (но уже с флагом `True`, указывающим, что он был "замечен"), и левый дочерний узел (с флагом `False`). Это делается до момента обработки узла.
    
- **Строки 9–19:** Цикл повторяется, пока не будут обработаны все элементы дерева.
    
- **Строка 21:** Возвращается список значений узлов, отсортированный в соответствии с порядком обхода in-order.

**Примечание:**  
Порядок добавления узлов в стек может показаться нелогичным, однако он соответствует принципу работы стека — _последним вошёл, первым вышел_ (LIFO). Чтобы первым был обработан левый узел, его нужно поместить в стек последним, поэтому порядок добавления: правый → текущий → левый.

Далее рассмотрим рекурсивный метод:
```
# Рекурсивный обход
class Solution:
    def __init__(self):
        self.answer = []
  

    def traverse_inorder(self, root: TreeNode) -> List[Any]:
        """
        Проходим двоичное дерево, и возвращаем список значений в порядке их следования
        """
        self._traverse(root)
        return self.answer
  

    def _traverse(self, node: Optional[TreeNode]) -> None:
      """
      Рекурсивная функция для последовательного обхода
      """
        if not node:
            return None


        self._traverse(node.left)
        self.answer.append(node.val)
        self._traverse(node.right)
```
**Пошаговое описание алгоритма:**
- **Строки 2–4:** Определяется класс, в котором при инициализации создаётся список `self.answer`, предназначенный для хранения результатов обхода.
    
- **Строки 6–11:** Реализуется метод `traverse_inorder`, принимающий корневой узел дерева. Внутри он вызывает вспомогательную рекурсивную функцию `_traverse` и в итоге возвращает `self.answer`.
    
- **Строки 13–22:** Функция `_traverse` выполняет рекурсивный обход. Сначала проверяется, существует ли переданный узел. Если да — вызывается рекурсия для левого поддерева. Затем значение текущего узла добавляется в список `self.answer`, после чего осуществляется рекурсивный вызов для правого поддерева.

**Заключение:**  
Оба приведённых варианта демонстрируют обход дерева в порядке **in-order**. Чтобы реализовать **pre-order** или **post-order**, нужно всего лишь изменить порядок действий относительно текущего узла и его потомков. В остальном структура алгоритма остаётся прежней.

```
# Изменение обхода
def iterative(root):
    ...
    stack.append((node.right, False))
    stack.append((node.left, False))
    stack.append((node, True))     # <- изменение
    ...

  

def _traverse(self, node):
    ...
    self.answer.append(node.val)   # <- изменение
    self._traverse(node.left)
    self._traverse(node.right)
```

# **Графы. Основы**  
Если деревья можно рассматривать как развитие связанных списков с возможностью наличия нескольких дочерних элементов, то графы идут ещё дальше — они устраняют жёсткую иерархию, присущую деревьям. В графах отсутствует чёткое разграничение между «родительскими» и «дочерними» узлами. Любой узел может быть напрямую соединён с любым другим, что делает структуру гораздо более гибкой и универсальной.
![[Pasted image 20250602114648.png]]
Обычно графы отображаются с помощью матриц смежности (adjacency matrix). Для графа, рассмотренного выше, соответствующая матрица будет выглядеть следующим образом.
![[Pasted image 20250602120502.png]]Каждая строка и каждый столбец матрицы соответствуют определённому узлу графа. Если в позиции строки i и столбца j стоит единица (A_{ij} = 1), это означает наличие связи между узлами i и j.

Если же A_{ij} = 0, то между этими узлами связи нет.

В рассматриваемом графе ни один узел не соединён сам с собой, поэтому элементы на главной диагонали матрицы равны нулю. Кроме того, поскольку связи являются ненаправленными, матрица смежности симметрична: A_{ij} = A_{ji}. Это значит, что если узел A связан с узлом B, то и узел B связан с узлом A.

Далее приведём пример, который иллюстрирует описанные принципы.
![[Pasted image 20250602120602.png]]На представленных рисунках мы видим взвешенный граф с направленными ребрами. Обратите внимание, что связи больше не симметричны – вторая строка матрицы смежности пуста, потому что у `B` нет исходящих связей. Числа от `0` до `1` отражают силу связи. Например, граф `C` влияет на граф `A` сильнее, чем `A` на `C`.
![[Pasted image 20250602120613.png]]
**Реализация**  
Создадим простой неориентированный и невзвешенный граф. В основе класса лежит структура — список списков в Python. Каждый внутренний список соответствует строке матрицы, а его индексы — столбцам. При инициализации объекта `Graph` нужно указать количество узлов `n`, чтобы создать такую матрицу нужного размера. После этого можно обращаться к связи между узлами `a` и `b` через `self.graph[a][b]`.
```
from typing import List

  
class Graph:
    def __init__(self, n: int):
        self.graph = [[0]*n for _ in range(n)]
  

    def connect(self, a: int, b: int) -> List[List[int]]:
        """
        Обновляем self.graph для соединения узлов A и B.
        """
        self.graph[a][b] = 1
        self.graph[b][a] = 1
        return self.graph

  
    def disconnect(self, a: int, b: int) -> List[List[int]]:
        """
        Обновляем self.graph для разъединения узлов A и B.
        """
        self.graph[a][b] = 0
        self.graph[b][a] = 0
        return self.graph
```
Воссоздать график из первого примера можно следующим образом:
```
g = Graph(4) 

# соединения A 
g.connect(0, 1) 
g.connect(0, 2)

# соединения B (исключая A) 
g.connect(1, 2) 

# соединения C (исключая B) 
g.connect(2, 3)
```
**Пример**  
Одна из ключевых задач в теории графов — это подсчёт числа связанных компонентов или подграфов внутри общего графа. К примеру, на изображённом ниже графе можно выделить три отдельных компонента.
![[Pasted image 20250602121007.png]]
Для решения задачи LC 323: «Количество связных компонентов» необходимо последовательно проходить по каждому узлу графа. Для каждого узла выполняем обход его соседей, отмечая посещённые вершины. Этот процесс продолжается до тех пор, пока не будут обнаружены только те узлы, которые уже посещались. Затем проверяется, остались ли в графе непосещённые узлы. Если такие узлы есть, значит, найден ещё один связный компонент, и процесс повторяется с нового узла.
```
def get_n_components(self, mat: List[List[int]]) -> int:
    """
    Учитывая матрицу смежности, возвращает количество связанных компонентов
    """
    q = []
    unseen = [*range(len(mat))]
    answer = 0

    while q or unseen:
        # Если все соседние узлы прошли через цикл, переходим к новому кластеру
        if not q:
            q.append(unseen.pop(0))
            answer += 1
            
        # Выбираем узел из текущего кластера
        focal = q.pop(0)
        i = 0
        
        # Поиск связей во всех оставшихся узлах
        while i < len(unseen):
            node = unseen[i]

            # Если узел подключен к центру, добавляем его в очередь
            # чтобы перебрать его соседей
            # из невидимых узлов и избежать бесконечного цикла
            if mat[focal][node] == 1:
                q.append(node)
                unseen.remove(node)
            else:
                i += 1
    return answer
```
**Алгоритм работы:**

- На строках 5-8 создаются очередь `q`, список непосещённых узлов `unseen` и счётчик связанных компонентов `answer`.
    
- В строке 10 запускается цикл `while`, который продолжается, пока в очереди есть узлы для обработки или остаются непосещённые узлы.
    
- На строках 13-15, если очередь пуста, из списка `unseen` извлекается первый узел, и счётчик компонентов увеличивается на единицу.
    
- На строках 18-19 выбирается следующий узел из очереди — так называемый `focal`.
    
- В строке 22 начинается вложенный цикл `while`, выполняющийся до тех пор, пока есть узлы для обработки.
    
- На строке 23 текущий узел присваивается переменной для удобства и оптимизации.
    
- На строках 28-30, если текущий узел связан с `focal`, он добавляется в очередь текущего кластера, а также удаляется из списка непосещённых узлов, что предотвращает зацикливание.
    
- На строках 31-32, если связи нет, переходим к следующему узлу.

**Итог**  
Графы и деревья — это фундаментальные структуры данных, широко применяемые в самых разных областях. Графы особенно полезны для решения задач, связанных с поиском оптимальных путей и вариантов, например, в механизме sea-of-nodes, используемом в JIT-компиляторах.

Деревья применяются там, где требуется быстрое добавление или удаление элементов с возможностью поиска по ключу. Их часто используют в словарях и индексах баз данных. Кроме того, деревья являются ключевым элементом таких алгоритмов машинного обучения, как случайный лес.