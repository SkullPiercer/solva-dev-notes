Связный список — это тип структуры данных, при котором элементы можно добавлять или удалять без необходимости сдвига остальных.  
В отличие от массивов, где данные располагаются последовательно, элементы связного списка размещаются в памяти произвольно. Это означает, что при добавлении нового элемента не нужно перемещать другие — он просто сохраняется в любой свободной области памяти.

Каждый элемент списка называется узлом. Узел содержит не только значение, но и указатель на следующий элемент в списке. Таким образом, каждый узел «знает», где находится следующий. Последний элемент не содержит ссылки — она указывает в пустоту (например, `None`).

Связный список всегда имеет начальную точку — первый элемент, называемый **головой списка**. Именно с неё начинается обход элементов.

### Как работают указатели в связном списке и как добавляются элементы

Указатель в каждом узле указывает, где находится следующий элемент списка. Следующий узел, в свою очередь, содержит свой указатель — и так, переходя от одного к другому, можно последовательно пройти весь список.

#### Добавление элементов

- **В начало списка**:  
    Чтобы вставить новый элемент первым, достаточно сделать его новой головой списка. Его указатель должен ссылаться на прежнюю голову.
    
- **В конец списка**:  
    При добавлении элемента в конец необходимо изменить указатель текущего последнего элемента — он должен указывать на новый узел. Указатель нового элемента при этом остаётся пустым, так как за ним больше ничего нет.
    
- **Вставка в произвольную позицию**:  
    Этот вариант сложнее. Требуется найти нужное место, изменить указатели соседних узлов так, чтобы они «обошли» через новый элемент, сохранив структуру списка.

![[Pasted image 20250602164151.png]]
Связный список особенно удобен в ситуациях, когда часто требуется добавлять или удалять элементы — эти операции выполняются быстро, за постоянное время. Однако есть и ограничение: доступ к элементу по его индексу занимает больше времени, поскольку нужно пройти по списку от начала, последовательно отсчитывая элементы.

Если же задача предполагает частую последовательную обработку элементов, начиная с первого, то связный список становится подходящим и эффективным решением.
Время выполнения операций в связном списке:
|Операция|Среднее время|Худшее время|
|---|---|---|
|Доступ по индексу|O(n)|O(n)|
|Вставка после текущего элемента|O(1)|O(1)|
|Вставка перед текущим элементом|O(n)|O(n)|
|Удаление первого элемента|O(1)|O(1)|
|Удаление текущего элемента|O(n)|O(n)|
|Поиск по значению|O(n)|O(n)|
|Определение длины|O(n)|O(n)|

**Особенности односвязного списка**
Связный список можно представить как одностороннюю улицу: двигаться можно только вперёд. Все узлы соединены последовательно, и чтобы дойти до нужного, приходится начинать с самого первого. Если нужно получить элемент перед заданным, придётся заново пройти весь путь от начала списка.

Такой тип структуры также называют **односвязным списком**, поскольку каждый элемент знает только о своём следующем соседе.

# **Двусвязный список**
Более гибкий вариант — **двусвязный список**. Здесь каждый узел содержит две ссылки: одну на следующий элемент, а вторую — на предыдущий. Это позволяет двигаться в обе стороны. Первый элемент списка не имеет предыдущего узла, а последний — следующего. Такой подход упрощает операции удаления и вставки в середине списка, но требует больше памяти.

**Двусвязный список: особенности**

Двусвязный список позволяет выполнять вставку как **после**, так и **перед** текущим элементом всего за **O(1)** — то есть за константное время. То же самое касается и удаления текущего узла. Это делает структуру особенно удобной для задач, связанных с частыми изменениями внутри списка.

Однако за удобство приходится платить: каждый элемент двусвязного списка хранит **две ссылки** — на предыдущий и следующий элементы. Это увеличивает потребление памяти по сравнению с односвязным списком.

**Связные списки в Python и других языках**
В языке **Python** стандартная библиотека **не включает** реализацию связных списков. Но в других языках, таких как **C++** и **Java**, они уже встроены:
- В **C++** используется `std::list` — реализация двусвязного списка.
    
- В **Java** есть класс `LinkedList`, который также представляет двусвязный список.

Если нужно, связный список в Python можно реализовать вручную с помощью классов.
**Почему Python не подходит для "настоящих" связных списков**

В классических языках программирования указатели могут напрямую ссылаться на ячейки оперативной памяти. Но **Python** работает по-другому: у него **нет прямого доступа к памяти**, и он **не поддерживает указатели в привычном смысле**.

Это имеет свои плюсы:
- Программисту не нужно вручную управлять памятью (освобождать, выделять, отслеживать утечки).
    
- Меньше рисков повредить систему или вызвать критические ошибки.
    

Но есть и минусы:
- **Невозможно создать полноценный связный список**, ссылающийся на физические адреса в памяти.
    
- Приходится использовать **объектно-ориентированный подход**, который создаёт **дополнительные накладные расходы** по памяти и скорости.

**Как можно реализовать связный список в Python**
Тем не менее, в Python можно **смоделировать** связный список при помощи классов. Каждый элемент (узел) будет объектом, содержащим:
- некоторое значение;
    
- ссылку на следующий элемент (в виде ссылки на другой объект).

Простейший пример односвязного списка:
```
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None  # ссылка на следующий узел

# Создаём узлы
a = Node(5)
b = Node(10)
c = Node(15)

# Связываем узлы
a.next = b
b.next = c

# Теперь список выглядит как: 5 -> 10 -> 15
```