**Пространственная сложность и расход памяти**

Пространственной сложностью алгоритма называют зависимость объёма потребляемой памяти от размера входных данных.

При её оценке важно помнить следующее:
- **Измеряют не конкретный объём памяти**, а **характер роста** — насколько увеличится расход памяти при увеличении размера входных данных. Например: если массив стал в 2 раза длиннее, во сколько раз вырастет используемая память?
    
- **Учитывают только дополнительную память**, которая используется **в процессе обработки данных**. Память, занятую самими входными данными (например, исходным массивом), не считают — она есть вне зависимости от алгоритма.

```
# При расчёте пространственной сложности не учитывается память, 
# занятая этим массивом.
mars_craters = [
    'Гусев', 'Ибрагимов', 'Королёв', 'Ломоносов', 'Мороз', 'Тихонравов'
]


def array_len(data):
    """Подсчёт количества элементов в массиве."""
    # При оценке пространственной сложности алгоритма
    # память, занятая массивом data, не учитывается.

    # При выполнении алгоритма создаётся переменная result, на это расходуется память. 
    # Этот расход учитывается при расчёте пространственной сложности.
    # В этом алгоритме всегда создаётся лишь одна переменная,
    # вне зависимости от размера входного массива data:
    result = len(data)
    return result


print(array_len(mars_craters))
```
Если алгоритм не создаёт новых структур данных и использует лишь фиксированное количество переменных — его **памятные затраты не зависят от размера входа**. Например, если алгоритм обрабатывает массив любой длины, но сохраняет лишь одну переменную, объём используемой памяти остаётся неизменным. В таком случае **пространственная сложность алгоритма равна O(1)** — постоянной.

Но если программа **создаёт копию массива** или **дополнительные структуры**, которые увеличиваются вместе с размером входных данных (например, сохраняет результат обработки каждого элемента в новом списке), тогда **объём памяти растёт пропорционально количеству входных данных**. Это уже **линейная пространственная сложность — O(n)**.

_Пример:_  
Все марсианские кратеры необходимо срочно проанализировать. Для начала посчитаем количество букв в каждом названии и сохраним результат:
```
mars_craters = [
    'Гусев', 'Ибрагимов', 'Королёв', 'Ломоносов', 'Мороз', 'Тихонравов'
]


def symbols_count_for_array_items(data):
    """Подсчёт количества символов в каждом элементе массива."""
    # При оценке пространственной сложности алгоритма
    # память, занятая массивом data, не учитывается.

    # Создаём список для хранения результата, он потребует места в памяти;
    # учтём это при подсчёте пространственной сложности.
    result = []

    for item in data:
        # Переменная item тоже займёт место в памяти, 
        # при подсчёте пространственной сложности учитываем и её тоже.

        # Добавляем в список новые элементы. 
        # Количество этих элементов зависит от длины входного массива.
        result.append(len(item))
    return result


print(symbols_count_for_array_items(mars_craters))
```
В этом алгоритме создаётся список `result`, в который по одному добавляются элементы из входного массива `data`. Размер этого нового списка будет **линейно зависеть от количества элементов входа** — если передать 1000 элементов, будет создан список из 1000 значений. Это даёт **пространственную сложность O(n)**.

Также используется переменная `item`, которая просто хранит текущий элемент в цикле. Независимо от размера входного массива, **объём памяти под `item` остаётся постоянным** — это **O(1)**.

В сумме получается: **O(n + 1)**, а при отбросе констант — **O(n)**.

Теперь представим **более сложный вариант**. Алгоритм принимает массив длины `n`, но создаёт **массив всех попарных сочетаний элементов**. То есть для каждого элемента он сопоставляет его со всеми остальными.
```
# Входной массив:
mars_craters = [
    'Гусев', 'Ибрагимов', 'Королёв', 'Ломоносов', 'Мороз', 'Тихонравов'
]


def pairwise_matching(data):
    """
    Создаёт список всех возможных пар,
    составленных из разных элементов входного массива.
    """
    result = []

    for departure_point in data:
        for destination_point in data:
            if destination_point != departure_point:
                result.append(departure_point+ ' - ' + destination_point)
    return result


print(pairwise_matching(mars_craters))
```
### При квадратичной пространственной сложности O(n²)

Если **объём входных данных удваивается**, то объём необходимой памяти **увеличивается в четыре раза**. А если массив становится в 10 раз больше — памяти потребуется **в 100 раз больше**. Такой рост делает алгоритмы с пространственной сложностью **O(n²)** опасными на больших данных: они могут быстро «съесть» всю доступную оперативную память и замедлить или даже остановить выполнение программы.
### Взаимосвязь пространственной и временной сложности

Во многих случаях между **памятью** и **временем выполнения** существует **компромисс**:

- Быстрые алгоритмы **могут использовать больше памяти**. Это часто делается намеренно — часть промежуточных вычислений сохраняется, чтобы не пересчитывать их повторно.
    
    **Пример** — кэширование (мемоизация) результатов функции: память расходуется для хранения уже вычисленных значений, чтобы ускорить повторные вызовы.
    
- Алгоритмы с низким потреблением памяти часто **работают дольше**, так как они пересчитывают значения каждый раз, не сохраняя промежуточных результатов.
    


### Обмен памяти на время

Такой приём часто называют **"обменом памяти на производительность" (space-time tradeoff)**.

Например, в динамическом программировании многие задачи решаются **быстрее**, если сохранить таблицу с результатами подзадач. Но **каждая ячейка таблицы — это расход памяти**.

Поэтому при проектировании алгоритма важно учитывать:

- Размер входных данных.
    
- Ограничения по памяти.
    
- Допустимое время выполнения.

### Подсчёт положительных температур в марсианский день

Представим, что летом на экваторе Марса были зафиксированы суточные температуры. Массив может выглядеть так:
```
days_temp = [-1, -4, 8, -7, 3, 0, 1, -7, -7, 0, 0, -4, 1, 8, 1, -5, 4, 0, 7, 1]
```
На деле таких значений будет в разы больше — ведь экспедиция рассчитана на много лет.
### Задача

Пусть исследовательская группа хочет анализировать отдельные отрезки массива: например, узнать, сколько положительных температур было между 158-м и 314-м днями. Для этого:

1. Определим границы отрезка: меньший индекс — `left`, больший — `right`.
    
2. Пройдёмся по этому диапазону.
    
3. Подсчитаем все значения больше нуля.
```
def count_positive_temperatures(temps, start, end):
    """Подсчитывает положительные значения в заданном диапазоне массива."""
    count = 0
    for temp in temps[start:end]:
        if temp > 0:
            count += 1
    return count

# Пример использования:
print(count_positive_temperatures(days_temp, 10, 19))  # Вывод: 4
```
### Временная сложность

Каждое значение в заданном диапазоне проверяется один раз — алгоритм выполняет **O(n)** операций, где `n = end - start`. Это **линейная сложность по времени**: чем шире отрезок, тем дольше длится подсчёт.

### Пространственная сложность

Алгоритм использует:

- переменную `count` для хранения количества положительных значений,
    
- временную переменную `temp` для перебора значений.

Эти переменные не зависят от размера отрезка — значит, **пространственная сложность — O(1)**, то есть **константная**.

## Подсчёт положительных значений с использованием накопительной суммы

Для того чтобы быстро определять, сколько положительных значений находится в произвольном участке массива, можно заранее посчитать **накопительную сумму** — массив, каждый элемент которого хранит количество положительных чисел, встретившихся **до текущего индекса**.

### Исходный массив:
```
[-1, -4, 8, -7, 3, 0, 1, -7, -7, 0, 0, -4, 1]
```
Накопительная сумма:
```
[0, 0, 0, 1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 4]
```
**Принцип:**  
Элемент с индексом `i+1` в накопительной сумме показывает, сколько положительных значений было в исходном массиве на интервале от `0` до `i` включительно.

### Пример

Чтобы узнать, сколько положительных чисел находится на отрезке массива от индекса `2` до `6` (включительно `2`, не включая `6`), нужно просто вычесть два значения из массива накопительных сумм:
```
result = cumulative_sums[6] - cumulative_sums[2]
# result = 2 - 0 = 2
```
## Зачем это нужно?

Подсчёт нужных значений на участке массива с помощью обычного перебора требует времени `O(n)` — чем длиннее участок, тем дольше выполнение.  
С накопительной суммой это делается за `O(1)` — всего одно вычитание.
## Реализация

Вначале можно написать простой скрипт, который хранит накопительную сумму в глобальной переменной:
```
days_temp = [-1, -4, 8, -7, 3, 0, 1, -7, -7, 0, 0, -4, 1]

cumulative_sums = [0]

def calculate_cumulative_sums(sequence):
    count = 0
    for item in sequence:
        if item > 0:
            count += 1
        cumulative_sums.append(count)

def calculate_positive(left, right):
    return cumulative_sums[right] - cumulative_sums[left]

calculate_cumulative_sums(days_temp)
print(calculate_positive(2, 6))  # Результат: 2
```
## Улучшение структуры: инкапсуляция в класс

Использование глобальных переменных — плохая практика. Вместо этого можно оформить логику в виде класса:
```
class Sequence:

    def __init__(self, sequence):
        self.cumulative_sums = [0]
        count = 0
        for value in sequence:
            if value > 0:
                count += 1
            self.cumulative_sums.append(count)

    def calculate_positive(self, left, right):
        return self.cumulative_sums[right] - self.cumulative_sums[left]
```
Пример использования:
```
days_temp = [-1, -4, 8, -7, 3, 0, 1, -7, -7, 0, 0, -4, 1, 8, 1, -5, 4, 0, 7, 1]

s = Sequence(days_temp)

# Подсчёт положительных значений в интервале от 10 до 19 (не включая 19)
print(s.calculate_positive(10, 19))  # Результат: 4
```
## Временная и пространственная сложность

- Построение накопительной суммы: **O(n)** по времени и **O(n)** по памяти.
    
- Запрос количества положительных чисел на участке: **O(1)**.
## Вывод

Создание накопительной суммы требует предварительной обработки массива, но существенно ускоряет все последующие запросы. Этот метод особенно эффективен, когда нужно многократно анализировать данные на отдельных участках массива.