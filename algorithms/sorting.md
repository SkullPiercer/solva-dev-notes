**Сортировка пузырьком**
Это один из базовых методов сортировки, суть которого заключается в многократном проходе по массиву с попарным сравнением элементов. При этом более крупные значения постепенно перемещаются к концу списка, словно всплывая наверх, в то время как меньшие остаются внизу.

**Принцип работы**
Алгоритм начинает с первых двух элементов: если левый больше правого — они меняются местами. Если порядок верный — всё остаётся как есть. Далее таким же образом проверяется следующая пара. Процесс продолжается до конца массива.

После первого прохода самый большой элемент оказывается в конце. Алгоритм запускается заново, уже не затрагивая последний элемент, и так далее, пока весь список не будет отсортирован.

Однако такой метод неэффективен, особенно если необходимо выполнить всего одну перестановку. Даже если массив почти упорядочен, алгоритм всё равно выполнит около _n²_ операций.

Чтобы улучшить работу алгоритма, можно внедрить механизм досрочного завершения. Для этого вводится специальная переменная, которая отслеживает, происходили ли обмены. Если в одном из проходов не было ни одной перестановки, это означает, что массив уже отсортирован, и дальнейшие итерации не нужны.

### Реализация
```
def bubble_sort(nums):  
    # Устанавливаем swapped в True, чтобы цикл запустился хотя бы один раз
    swapped = True
    while swapped:
        swapped = False
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                # Меняем элементы
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
                # Устанавливаем swapped в True для следующей итерации
                swapped = True

# Проверяем, что оно работает
random_list_of_nums = [5, 2, 1, 8, 4]  
bubble_sort(random_list_of_nums)  
print(random_list_of_nums)
```
Алгоритм реализуется с помощью цикла `while`, который продолжается до тех пор, пока в процессе прохода по списку происходят хотя бы какие-либо перестановки. Чтобы инициировать хотя бы один проход, в начале переменной, отвечающей за отслеживание изменений (например, `swapped`), присваивается значение `True`.

**Оценка производительности**
В наихудшем сценарии, когда элементы изначально упорядочены в обратном (убывающем) порядке, алгоритму потребуется максимальное количество операций. В этом случае его временная сложность оценивается как O(n²), где _n_ — это число элементов в массиве.

# **Сортировка выбором**
Данный метод основан на постепенном разделении массива на отсортированную и неотсортированную части. С каждым шагом из неотсортированной области выбирается наименьший элемент и перемещается в начало, таким образом расширяя отсортированную зону.

**Как работает алгоритм**

Фактически не требуется создавать отдельный массив для хранения отсортированных значений. Вместо этого роль отсортированной части выполняет левая часть исходного списка. Сначала ищется минимальный элемент во всей последовательности и меняется местами с тем, что находится в первой позиции.

После этого считается, что первый элемент стоит на своём месте. Далее среди оставшихся ищется следующий наименьший, который затем ставится на вторую позицию. Эта операция повторяется до тех пор, пока весь массив не будет отсортирован — в последней итерации останется лишь один элемент, который автоматически окажется на нужном месте.

```
def selection_sort(nums):  
    # Значение i соответствует кол-ву отсортированных значений
    for i in range(len(nums)):
        # Исходно считаем наименьшим первый элемент
        lowest_value_index = i
        # Этот цикл перебирает несортированные элементы
        for j in range(i + 1, len(nums)):
            if nums[j] < nums[lowest_value_index]:
                lowest_value_index = j
        # Самый маленький элемент меняем с первым в списке
        nums[i], nums[lowest_value_index] = nums[lowest_value_index], nums[i]

# Проверяем, что оно работает
random_list_of_nums = [12, 8, 3, 20, 11]  
selection_sort(random_list_of_nums)  
print(random_list_of_nums)
```
**Оптимизация выбора**
С каждым новым шагом в процессе сортировки становится необходимо проверять всё меньше элементов, так как часть массива уже упорядочена.

**Оценка производительности**
В среднем сортировка выбором требует порядка O(n²) операций, где _n_ — это количество элементов. Такая сложность обусловлена тем, что для каждой позиции необходимо найти минимальный элемент из оставшихся.

# **Сортировка вставками**

Этот метод, как и выборочный, делит список на две части — упорядоченную и ту, что ещё предстоит отсортировать. При этом каждый элемент из неотсортированной части вставляется в нужное место уже отсортированной последовательности.

**Как устроен алгоритм**
На старте считается, что первый элемент уже стоит на своём месте. Переходя ко второму элементу (обозначим его _x_), сравниваем его с первым: если _x_ больше, он остаётся там, где был. Если меньше — текущие значения сдвигаются, и _x_ перемещается в начало.

При дальнейшем проходе по списку для каждого нового элемента производится сравнение с элементами отсортированной части. Более крупные значения сдвигаются вправо, чтобы освободить место для вставки. Процесс продолжается до тех пор, пока не будет найдено подходящее положение для текущего элемента или пока не достигнется начало списка.

### Реализация
```
def insertion_sort(nums):  
    # Сортировку начинаем со второго элемента, т.к. считается, что первый элемент уже отсортирован
    for i in range(1, len(nums)):
        item_to_insert = nums[i]
        # Сохраняем ссылку на индекс предыдущего элемента
        j = i - 1
        # Элементы отсортированного сегмента перемещаем вперёд, если они больше
        # элемента для вставки
        while j >= 0 and nums[j] > item_to_insert:
            nums[j + 1] = nums[j]
            j -= 1
        # Вставляем элемент
        nums[j + 1] = item_to_insert

# Проверяем, что оно работает
random_list_of_nums = [9, 1, 15, 28, 6]  
insertion_sort(random_list_of_nums)  
print(random_list_of_nums)
```
Время сортировки вставками в среднем равно O(n²), где n — количество элементов списка.

# **Сортировка слиянием**
Этот метод относится к классу алгоритмов «разделяй и властвуй». Его суть заключается в последовательном разбиении исходного массива на более мелкие части. Каждый раз список делится пополам, пока не останутся только одиночные элементы — их уже можно считать отсортированными.

Затем начинается обратный процесс: соседние элементы объединяются в отсортированные пары, пары — в упорядоченные четверки и так далее, пока не получится отсортированный массив в целом.

**Принцип работы**
Процесс начинается с рекурсивного деления массива на две части. Деление продолжается до тех пор, пока не получатся подмассивы, содержащие по одному элементу. Такие фрагменты считаются отсортированными по определению.

Далее происходит слияние: два соседних подмассива сравниваются и объединяются в один, соблюдая порядок. Сначала сравниваются первые элементы каждой половины. Меньший из них добавляется в новый массив, после чего счётчик этого подмассива сдвигается на один элемент вперёд. Процесс продолжается до тех пор, пока все элементы не будут объединены в единый отсортированный массив.

### Реализация
```
def merge(left_list, right_list):  
    sorted_list = []
    left_list_index = right_list_index = 0

    # Длина списков часто используется, поэтому создадим переменные для удобства
    left_list_length, right_list_length = len(left_list), len(right_list)

    for _ in range(left_list_length + right_list_length):
        if left_list_index < left_list_length and right_list_index < right_list_length:
            # Сравниваем первые элементы в начале каждого списка
            # Если первый элемент левого подсписка меньше, добавляем его
            # в отсортированный массив
            if left_list[left_list_index] <= right_list[right_list_index]:
                sorted_list.append(left_list[left_list_index])
                left_list_index += 1
            # Если первый элемент правого подсписка меньше, добавляем его
            # в отсортированный массив
            else:
                sorted_list.append(right_list[right_list_index])
                right_list_index += 1

        # Если достигнут конец левого списка, элементы правого списка
        # добавляем в конец результирующего списка
        elif left_list_index == left_list_length:
            sorted_list.append(right_list[right_list_index])
            right_list_index += 1
        # Если достигнут конец правого списка, элементы левого списка
        # добавляем в отсортированный массив
        elif right_list_index == right_list_length:
            sorted_list.append(left_list[left_list_index])
            left_list_index += 1

    return sorted_list

def merge_sort(nums):  
    # Возвращаем список, если он состоит из одного элемента
    if len(nums) <= 1:
        return nums

    # Для того чтобы найти середину списка, используем деление без остатка
    # Индексы должны быть integer
    mid = len(nums) // 2

    # Сортируем и объединяем подсписки
    left_list = merge_sort(nums[:mid])
    right_list = merge_sort(nums[mid:])

    # Объединяем отсортированные списки в результирующий
    return merge(left_list, right_list)

# Проверяем, что оно работает
random_list_of_nums = [120, 45, 68, 250, 176]  
random_list_of_nums = merge_sort(random_list_of_nums)  
print(random_list_of_nums)
```
**Особенности реализации**
Важно отметить, что функция `merge_sort()` в отличие от многих других алгоритмов не изменяет исходный список, а создает и возвращает новый. Это означает, что для её работы требуется дополнительная память, равная размеру сортируемого массива. Такой подход может быть ресурсоёмким при работе с большими объёмами данных.

**Оценка эффективности**
В среднем алгоритм сортировки слиянием демонстрирует производительность порядка O(n log n), что делает его значительно быстрее простых алгоритмов (например, пузырьковой или выборочной сортировки) при работе с крупными наборами данных.

**Быстрая сортировка**
Этот алгоритм тоже относится к категории «разделяй и властвуй», однако его часто применяют на практике из-за высокой эффективности. В отличие от сортировки слиянием, здесь не требуется выделять дополнительную память — сортировка происходит непосредственно в исходном массиве.

Суть метода — в выборе опорного элемента и перестановке остальных значений относительно него: все меньшие отправляются влево, а те, что больше или равны — вправо. Таким образом массив делится на две части, каждая из которых затем сортируется аналогичным образом.

**Принцип работы**
Алгоритм начинается с выбора опорного значения. После этого выполняется перестройка массива таким образом, чтобы опорный элемент оказался в позиции, на которую он должен встать в отсортированном массиве. При этом элементы с меньшими значениями перемещаются в левую часть, а большие или равные — в правую.

**Особенности реализации**
Существует множество подходов к разбиению массива. Одна из самых известных реализаций быстрой сортировки использует метод, предложенный Тони Хоаром — создателем алгоритма. Именно эта схема описывается в текущем варианте реализации.

```
def partition(nums, low, high):  
    # Выбираем средний элемент в качестве опорного
    # Также возможен выбор первого, последнего
    # или произвольного элементов в качестве опорного
    pivot = nums[(low + high) // 2]
    i = low - 1
    j = high + 1
    while True:
        i += 1
        while nums[i] < pivot:
            i += 1

        j -= 1
        while nums[j] > pivot:
            j -= 1

        if i >= j:
            return j

        # Если элемент с индексом i (слева от опорного) больше, чем
        # элемент с индексом j (справа от опорного), меняем их местами
        nums[i], nums[j] = nums[j], nums[i]

def quick_sort(nums):  
    # Создадим вспомогательную функцию, которая вызывается рекурсивно
    def _quick_sort(items, low, high):
        if low < high:
            # This is the index after the pivot, where our lists are split
            split_index = partition(items, low, high)
            _quick_sort(items, low, split_index)
            _quick_sort(items, split_index + 1, high)

    _quick_sort(nums, 0, len(nums) - 1)

# Проверяем, что оно работает
random_list_of_nums = [22, 5, 1, 18, 99]  
quick_sort(random_list_of_nums)  
print(random_list_of_nums)
```
**Временная сложность**
В среднем быстрая сортировка демонстрирует высокую производительность с временной сложностью порядка O(n log n), что делает её одним из самых эффективных алгоритмов сортировки при нормальных условиях.

Однако стоит учитывать, что её эффективность может резко снизиться в случае неудачного выбора опорного элемента. Если в качестве опорного регулярно выбирается минимальное или максимальное значение, структура массива разбивается неравномерно. Это приводит к худшему сценарию, в котором время выполнения возрастает до O(n²). В этом плане сортировка слиянием или пирамидальная сортировка (сортировка кучей) надёжнее, так как даже в наихудших случаях сохраняют сложность O(n log n).

**Сортировка в Python: стандартные средства**
Хотя знание классических алгоритмов полезно для понимания принципов работы, в повседневной разработке чаще всего используются встроенные функции языка программирования. В Python упорядочить список можно с помощью метода `sort()`:
```
>>> apples_eaten_a_day = [2, 1, 1, 3, 1, 2, 2]
>>> apples_eaten_a_day.sort()
>>> apples_eaten_a_day
[1, 1, 1, 2, 2, 2, 3]
```
Или можно использовать функцию `sorted()` для создания нового отсортированного списка, оставив входной список нетронутым:
```
>>> apples_eaten_a_day_2 = [2, 1, 1, 3, 1, 2, 2]
>>> sorted_apples = sorted(apples_eaten_a_day_2)
>>> sorted_apples
[1, 1, 1, 2, 2, 2, 3]
```
Оба эти метода сортируют в порядке возрастания, но можно изменить порядок, установив для флага `reverse` значение `True`:
```
# Обратная сортировка списка на месте
>>> apples_eaten_a_day.sort(reverse=True)
>>> apples_eaten_a_day
[3, 2, 2, 2, 1, 1, 1]

# Обратная сортировка, чтобы получить новый список
>>> sorted_apples_desc = sorted(apples_eaten_a_day_2, reverse=True)
>>> sorted_apples_desc
[3, 2, 2, 2, 1, 1, 1]
```
**Особенности встроенных функций сортировки в Python**
В отличие от большинства алгоритмов, реализованных вручную, встроенные функции Python — `sort()` и `sorted()` — способны обрабатывать не только простые списки, но и более сложные структуры, такие как списки кортежей, экземпляры пользовательских классов и другие коллекции.

При этом `sorted()` обладает большей универсальностью, так как позволяет сортировать любые итерируемые объекты: списки, строки, кортежи, словари (по ключам), множества, а также пользовательские итераторы.

Обе функции используют алгоритм Timsort — адаптивную гибридную сортировку, объединяющую идеи сортировки слиянием и вставками. Он обеспечивает стабильность и высокую эффективность при работе с различными типами данных и частично отсортированными последовательностями.

**Сравнение производительности различных алгоритмов**
Для оценки скорости различных алгоритмов была проведена серия экспериментов: создавался массив из 5000 случайных чисел в диапазоне от 0 до 1000. Каждый алгоритм запускался 10 раз, чтобы получить усреднённые значения времени выполнения.
- **Пузырьковая сортировка** оказалась наименее эффективной. Несмотря на её простоту, она не предназначена для работы с большими объёмами данных и скорее служит учебной демонстрацией основных принципов сортировки.
    
- **Быстрая сортировка** оправдала своё название: она показала наилучшее время выполнения, приблизительно вдвое быстрее сортировки слиянием. Её преимущество — отсутствие необходимости в дополнительной памяти, что делает её особенно удобной в условиях ограниченных ресурсов.
    
- **Сортировка вставками** показала себя чуть медленнее, чем ожидалось. Хотя она выполняет меньше сравнений, чем сортировка выбором, число обменов между элементами в ней существенно выше. Если сами операции перестановки затратны по времени, это может сказаться на общем результате.

**Вывод**
Как видно, скорость работы зависит не только от сложности алгоритма, но и от деталей реализации, структуры данных и условий выполнения кода.

В реальных проектах, особенно в промышленных системах и при работе с большими объёмами данных, рекомендуется отдавать предпочтение встроенным функциям сортировки в Python. Они оптимизированы, стабильны и удобны для использования, избавляя разработчика от необходимости заботиться о деталях низкоуровневой реализации.