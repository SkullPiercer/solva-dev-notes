**Массивы** (например, списки в Python) хороши тем, что можно **мгновенно получить элемент по индексу** — на это уходит **постоянное время, O(1)**.  
Но вот если захочется **вставить что-то в середину или в начало**, придётся **сдвигать остальные элементы**, а это уже **занимает больше времени — O(n)**.

А что насчёт **стека, очереди и дека**?  
Они, наоборот, **позволяют быстро добавлять и удалять элементы**, но **только с концов**. Зато **доступ к произвольному элементу — невозможен**: нельзя просто так обратиться по индексу.

Так неужели нельзя сделать какую-то структуру, в которой можно было бы и **добавлять элементы быстро**, и **находить их быстро**?
Можно! Такая структура **уже существует** — это **хеш-таблица** (в Python — это обычный `dict`) 
В ней и добавление, и поиск элемента происходят за **O(1)** — **если нет коллизий**.

Конечно, **идеальных структур данных не существует**. У хеш-таблиц тоже есть **свои минусы**.  
Например, вы **не можете просто так взять элемент по индексу** — потому что в привычном смысле **индексов у хеш-таблицы нет вообще**.  
В этом плане она явно **уступает спискам**.

А ещё есть **жёсткие правила**, которые нельзя нарушать:

**Во-первых**, у каждой пары ключ–значение в хеш-таблице **ключ должен быть уникальным**.  
Два одинаковых ключа — это ошибка. Всегда будет храниться **только одно значение на каждый ключ**.

**Во-вторых**, **ключи должны быть неизменяемыми** (то есть хешируемыми).  
Например, строки, числа и кортежи подойдут. А вот списки и словари — нет.

Это не просто прихоти — это **особенности самой структуры**.  
Кстати, **в Python словари (`dict`) устроены именно как хеш-таблицы**, поэтому у них **те же ограничения**.

Но стоит помнить:  
**Хеш-таблица** — это **структура данных**,  
а **словарь в Python** — это **конкретная реализация этой структуры**.  
И хотя они похожи, **путать их не стоит**.

### Как устроена хеш-таблица

Хеш-таблица — это **коллекция элементов**, и у каждого элемента есть **ключ** и **значение**. Именно с этой парой работает разработчик:  
при добавлении — указывает ключ и значение,  
при поиске — задаёт только ключ.

Но это только верхний уровень.  
Под капотом каждый элемент хеш-таблицы содержит ещё **и индекс** — он нужен для быстрого доступа к данным.  
Однако этот индекс — **внутренняя, служебная часть**. Разработчик **не может управлять им напрямую**.

Можно представить хеш-таблицу в виде таблицы с тремя колонками:  
**Индекс | Ключ | Значение**

Каждая строка в этой таблице — это один элемент хеш-таблицы.  
Ключи и значения доступны вам как пользователю,  
а индексы — это то, чем оперирует сама структура «под капотом», чтобы обеспечить быструю работу.

# Почему в хеш-таблице есть пустые ячейки?
В отличие от обычного массива, элементы в хеш-таблицу не добавляются последовательно — каждый новый элемент помещается **по определённому правилу**.

Хеш-таблица использует **внутренний массив**, и для каждого нового элемента вычисляется **индекс**, куда его нужно поместить.  
Например, если вы добавите три элемента в пустую таблицу, они могут попасть по адресам `[5]`, `[2]` и `[4]`.  
А ячейки с индексами `[0]`, `[1]` и `[3]` останутся пустыми — до поры до времени.

# Как происходит добавление элемента в хеш-таблицу?
В обычных массивах индекс — просто число, которое ничего не говорит о значении.  
В хеш-таблице всё иначе: **индекс зависит от ключа**.

Общая схема:
1. Вы передаёте в хеш-таблицу пару: **ключ — значение**.
    
2. Ключ проходит через **хеш-функцию** и превращается в **хеш** — уникальную последовательность символов.
    
3. Хеш преобразуется в **целое число** — это и есть индекс.
    
4. Элемент записывается в массив по полученному индексу.

Алгоритм на шаге 3 учитывает размер таблицы:  
если в таблице всего 6 элементов, нет смысла создавать индекс `10998`.  
Поэтому индексы всегда будут попадать в допустимый диапазон, например от `0` до `15`.
### Что происходит при нехватке места?

Внутренний массив хеш-таблицы работает как обычный массив:
- элементы располагаются в последовательных ячейках памяти;
    
- если места не хватает, выделяется новый, более крупный массив (реаллокация);
    
- при этом **все элементы переносятся**, а их индексы **пересчитываются заново**.

Это нужно, потому что индекс зависит и от ключа, и от **размера массива**.  
Операция пересчёта занимает **O(n)** времени — линейную сложность.
### А что такое хеш-функция?
Слово "хеш" звучит постоянно. А как он получается?  
Это действительно «абракадабра» — но откуда она берётся?

«абракадабра» создаётся **хеш-функцией**.  
Она принимает на вход, например, строку — и возвращает **хеш-значение**, уникальный набор символов.

Существует **много разных хеш-функций**.  
Они используют разные алгоритмы и возвращают разные результаты.

Например, одну и ту же строку можно захешировать тремя способами:
- с помощью **SHA-1**
    
- или **SHA-256**
    
- или **MD5**

И на выходе каждый алгоритм даст **разное хеш-значение**.  
Для примеров можно воспользоваться онлайн-сервисами хеширования.

Стандартные алгоритмы хеширования — это удобно, и их хватает для большинства задач.  
Однако **разработчик может написать собственную хеш-функцию**, если в этом есть необходимость.

Главное — соблюдать два базовых требования:

1. **Одинаковый ввод → одинаковый результат**:  
    если дважды передать в функцию одну и ту же строку, результат должен быть абсолютно одинаковым.
    
2. **Разный ввод → разный результат**:  
    разные строки должны возвращать разные хеш-значения — насколько это возможно.

Это позволит хеш-функции работать корректно в составе хеш-таблицы.

# Особенности хеш-таблиц
Если копнуть чуть глубже, становятся понятны и другие особенности хеш-таблиц:

- **Быстрый поиск по ключу**  
    Чтобы найти элемент, хеш-таблица сначала превращает ключ в хеш, а потом — в индекс. По индексу получить значение очень быстро: всего за **O(1)**.
    
- **Добавление нового элемента**  
    В большинстве случаев — тоже за **O(1)**, потому что нет нужды сдвигать элементы: каждый ключ получает свой уникальный индекс, и элемент просто «садится» на свободное место.  
    Однако если массив «переполнится», придётся **реаллоцировать** память (увеличить массив и пересчитать все индексы), а это уже **O(n)**.
    
- **Удаление элемента**  
    Происходит по той же схеме: ключ → хеш → индекс → удаление. И опять всё быстро: **O(1)**. Элементы не нужно сдвигать — каждый хранится строго на своей позиции.
    
### Коллизии
Ключи в хеш-таблице могут быть **любыми неизменяемыми объектами**, и теоретически таких ключей **бесконечно много**.  
А вот количество доступных **индексов в массиве ограничено** — ведь в памяти под таблицу выделяется конечное количество ячеек.

Что это значит?  
Даже если хеши у разных ключей будут разными, **их индексы могут совпасть** — ведь все хеши в итоге преобразуются в **ограниченное множество индексов**.

 Так возникает **коллизия** — ситуация, когда **разные ключи попадают в одну и ту же ячейку массива**.  
А записать два разных элемента в одну ячейку, **невозможно**.

Когда разные ключи дают один и тот же индекс — возникает **коллизия**.  
Полностью избежать их **невозможно**, но есть способы **сгладить последствия**. Существуют два основных метода:

### 1. Метод открытой адресации

Если нужная ячейка занята, таблица ищет **следующую свободную** и помещает данные туда.

При поиске элемента по ключу:
- Нужно сравнивать не только индекс, но и **ключ**.
    
- Если ключ не совпадает — продолжаем поиск **в следующей ячейке**, пока не найдём нужный или пустую.

### 2. Метод цепочек (списков)

Вместо одной пары ключ-значение в каждой ячейке массива хранится **список таких пар**.

 Если два ключа попали в одну ячейку — оба значения помещаются в список под этим индексом.  
При поиске сначала находим ячейку по индексу, а затем — нужную пару в списке.

## Ассоциативный массив

**Ассоциативный массив** — абстрактная структура данных, где:
- Данные хранятся в формате **ключ → значение**.
    
- Можно добавлять, удалять и искать пары по ключу.

Хеш-таблица — это **один из способов** реализации ассоциативного массива.

Например:
- В **Python** ассоциативный массив реализуется через `dict`, основанный на хеш-таблице.
    
- В **C++** контейнер `map` реализует ассоциативный массив на основе **сбалансированного дерева**, операции в нём выполняются за **O(log n)**.

## Словари в Python и хеш-таблицы

Хотя Python-словарь (`dict`) построен **на основе хеш-таблицы**, он **не является классической хеш-таблицей**. У него есть свои особенности:
|Особенность|Python `dict`|Классическая хеш-таблица|
|---|---|---|
|Вложенные значения|✅ Поддерживает (вложенные словари, списки и т.п.)|❌ Обычно не поддерживает|
|Доп. методы|✅ Есть (`setdefault()`, `popitem()` и др.)|❌ Не предусмотрены|
|Итерация|✅ Можно итерировать (в цикле `for`)|❌ Нет встроенной итерации|
|Структура данных|Более гибкая|Простая, только пары ключ-значение|

`dict` в Python — это **мощная надстройка** над хеш-таблицей. Она унаследовала основные преимущества хеширования (быстрые операции), но добавила богатую функциональность.
