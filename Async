**Асинхронность** и **многопоточность** — это два различных, но часто связанных понятия, которые используются для управления выполнением задач таким образом, чтобы повысить эффективность и отзывчивость приложений. Хотя они оба направлены на оптимизацию выполнения программ, между ними есть ключевые различия в подходах и использовании.

Асинхронность

Это подход, при котором задача может выполняться независимо от основного потока программы, и не блокирует его выполнение в ожидании завершения. Это позволяет программе продолжать работу, пока выполняется асинхронная операция, например, доступ к файлу или сетевой запрос. Ключевая особенность асинхронности заключается в том, что она позволяет обрабатывать задачи без блокировки, улучшая отзывчивость и производительность приложения, особенно в средах с графическим интерфейсом пользователя или в серверных приложениях.

Примеры:

- Запросы к веб-сервисам
- Операции чтения/записи файлов
- Базы данных или сетевые операции

Многопоточность

Это подход, при котором несколько потоков исполнения работают параллельно, что позволяет выполнять несколько операций одновременно. Это может быть реализовано как на одном процессоре с использованием временной мультиплексированной многозадачности, так и на многоядерных процессорах, где каждый поток может выполняться фактически одновременно на своем ядре. Многопоточность идеально подходит для задач, требующих тяжелых вычислений, и может значительно ускорить выполнение программы за счет распараллеливания работы.

Примеры:

- Параллельные вычисления и обработка больших объемов данных
- Серверы, обрабатывающие множество одновременных соединений
- Реализация фоновых задач, которые должны исполняться параллельно основному потоку

Ключевые различия

- **Цели использования:** Асинхронность обычно используется для улучшения отзывчивости приложений и эффективного использования ожидания (например, I/O операции), тогда как многопоточность применяется для ускорения выполнения вычислительно сложных задач за счет параллелизма.
- **Управление ресурсами:** Асинхронные операции часто управляются операционной системой и могут использовать меньше ресурсов, поскольку не требуют постоянного выделения отдельного потока. Многопоточность требует более активного управления потоками, что может привести к большему потреблению памяти и процессорного времени.
- **Сложность разработки:** Работа с многопоточностью часто более сложна из-за необходимости синхронизации доступа к общим ресурсам и управления состоянием, что может привести к ошибкам, таким как взаимные блокировки и состояния гонки. Асинхронное программирование также требует понимания, но оно более структурировано и часто управляется с помощью высокоуровневых паттернов и библиотек.

Оба эти подхода важны в современной разработке ПО и могут использоваться вместе для создания высокопроизводительных, масштабируемых и отзывчивых приложений.

В линейном исполнении программ каждый шаг осуществляется строго один за другим. Временные затраты при этом не имеют значения — пока текущая операция не завершится, следующая не начнётся. Именно так функционировало большинство ваших программ до настоящего момента.

Однако это ограничение можно обойти. Вы уже сталкивались с возможностями параллельной и конкурентной обработки. На этот раз нарушим последовательность с помощью асинхронного подхода.

Создадим новую программу, которая выполнит десять однотипных задач: каждая из них отправит HTTP GET-запрос на сайт [https://python.org](https://python.org).

Структура программы будет следующей:

- Метод `perform_request()` осуществляет сетевой запрос (что является длительной операцией, зависящей от внешних ресурсов) и выводит первые 15 символов полученного HTML;
    
- Метод `run_synchronously()` запускает `perform_request()` десять раз последовательно.
    

Дополнительно программа будет фиксировать и выводить общее время выполнения. Учитывая нестабильность сетевых соединений, каждый запрос может занимать разное время — от задержек до сбоев. Поэтому не удивляйтесь, если общее время будет разниться при каждом запуске.

Выполните следующий код и проанализируйте вывод:
```
from datetime import datetime
import requests

# Выполнение одного HTTP-запроса
def perform_request(index):
    reply = requests.get('https://python.org')
    html = reply.text
    print(html[:15])
    print(f'Операция {index} завершена.')

# Последовательный вызов запроса десять раз
def run_synchronously():
    for number in range(1, 11):
        perform_request(number)

if __name__ == '__main__':
    print('Старт последовательного запуска:')
    start = datetime.now()
    run_synchronously()
    end = datetime.now()
    print(f'Общее время выполнения: {end - start} секунд.')
```
Примерный результат выполнения может выглядеть так (разумеется, время может варьироваться):
```
Старт последовательного запуска:
<!doctype html>
Операция 1 завершена.
<!doctype html>
Операция 2 завершена.
<!doctype html>
Операция 3 завершена.
<!doctype html>
Операция 4 завершена.
<!doctype html>
Операция 5 завершена.
<!doctype html>
Операция 6 завершена.
<!doctype html>
Операция 7 завершена.
<!doctype html>
Операция 8 завершена.
<!doctype html>
Операция 9 завершена.
<!doctype html>
Операция 10 завершена.
Общее время выполнения: 0:00:08.357859 секунд.
```

Всё проходит по законам "линейного мира": каждое действие стартует только после завершения предыдущего. Это не всегда удобно, особенно если вы уже знакомы с библиотеками `threading` и `multiprocessing`, способными ускорить процесс.

### От последовательного выполнения — к многопоточному

Рассмотрим, как улучшить производительность программы, выполняющей десять GET-запросов к сайту `https://python.org`. Сначала она выполняется последовательно, но теперь мы перепишем её, используя многопоточность, чтобы сократить общее время выполнения.

Вот пример программы, в которой каждый сетевой запрос выполняется в отдельном потоке:
```
import threading
from datetime import datetime
import requests

def task(task_id):
    response = requests.get('https://python.org')
    response_html = response.text
    print(response_html[:15])
    print(f'Задача {task_id} выполнена.')

def sync_execute():
    tasks = []
    # Создаём десять потоков через цикл
    for i in range(1, 11):
        tasks.append(threading.Thread(target=task, args=(i,)))
    
    # Запускаем все потоки
    for t in tasks:
        t.start()
    
    # Ждём завершения каждого потока
    for t in tasks:
        t.join()

if __name__ == '__main__':
    print('Многопоточное выполнение кода:')
    start_time = datetime.now()
    sync_execute()
    end_time = datetime.now()
    print(f'Итоговое время выполнения: {end_time - start_time} секунд.')
```
Пример результата:
```
Многопоточное выполнение кода:
<!doctype html>
Задача 3 выполнена.
<!doctype html>
Задача 7 выполнена.
...
Итоговое время выполнения: 0:00:00.75 секунд.
```
Хотя потоки завершились в случайном порядке, общая скорость увеличилась. Однако стоит отметить: это лишь удачное стечение обстоятельств. Потоки "переключаются", ожидая завершения операций, и не всегда это эффективно.

### Решение: асинхронный подход

Чтобы устранить задержки и сделать выполнение более управляемым, используем асинхронный подход с модулем `asyncio`. Однако стандартный `requests` для этого не подходит — он блокирует выполнение. Поэтому подключим модуль `aiohttp`, поддерживающий асинхронные HTTP-запросы:

Установите его командой:
```
pip install aiohttp==3.8.1
```

Теперь перепишем код, используя корутины и событийный цикл:
```
import asyncio
from datetime import datetime
import aiohttp

async def task(task_id):
    async with aiohttp.ClientSession() as session:
        response = await session.get('https://python.org')
        response_html = await response.text()
    print(response_html[:15])
    print(f'Задача {task_id} выполнена.')

async def async_execute():
    tasks = [asyncio.ensure_future(task(i)) for i in range(1, 11)]
    await asyncio.wait(tasks)

if __name__ == '__main__':
    ioloop = asyncio.get_event_loop()
    print('Асинхронное выполнение кода:')
    start_time = datetime.now()
    ioloop.run_until_complete(async_execute())
    ioloop.close()
    end_time = datetime.now()
    print(f'Итоговое время выполнения: {end_time - start_time} секунд.')
```
Пример результата:
```
Асинхронное выполнение кода:
<!doctype html>
Задача 5 выполнена.
<!doctype html>
Задача 1 выполнена.
...
Итоговое время выполнения: 0:00:00.73 секунд.
```
Асинхронный код демонстрирует ещё более эффективную обработку запросов. Задачи запускаются одновременно, и каждый запрос продолжается, как только сервер присылает ответ. Это позволяет запускать тысячи операций параллельно — там, где многопоточность начинает «тормозить».

### Как работает асинхронный подход

Асинхронное программирование позволяет выполнять задачи параллельно, переключаясь между ними в определённых местах. Такие места в коде называются **точками переключения** и отмечаются ключевым словом `await`. Оно может использоваться **только** перед другими асинхронными вызовами — например, перед корутинами или методами, возвращающими awaitable-объекты.

Если функция использует `await`, её необходимо объявить как `async def`. Это делает её **корутиной** — специальной функцией, которую может управлять **цикл событий**. Эти два элемента — **корутины** и **цикл событий** — составляют базу для построения асинхронных приложений на Python.

Все эти элементы уже были использованы в коде, с которым вы работали. Ниже вы найдёте подробный разбор команд из этого примера, дополненный комментариями:
```
import asyncio  
from datetime import datetime
import aiohttp  # Асинхронная альтернатива requests

# Асинхронная функция (корутина), которая делает HTTP-запрос
async def task(task_id):
    async with aiohttp.ClientSession() as session:
        response = await session.get('http://python.org')  # Ожидаем ответа от сервера
        response_html = await response.text()              # Читаем HTML как текст
    print(response_html[:15])
    print(f'Задача {task_id} выполнена.')

# Корутина верхнего уровня, запускающая несколько задач
async def async_execute():
    tasks = [asyncio.ensure_future(task(i)) for i in range(1, 11)]  # Оборачиваем каждую задачу
    await asyncio.wait(tasks)  # Ожидаем завершения всех задач

if __name__ == '__main__':
    print('Асинхронное выполнение кода:')
    start_time = datetime.now()
    
    myloop = asyncio.get_event_loop()  # Получаем текущий цикл событий
    myloop.run_until_complete(async_execute())  # Запускаем выполнение
    myloop.close()  # Закрываем цикл

    end_time = datetime.now()
    print(f'Итоговое время выполнения: {end_time - start_time} секунд.')
```
### Упрощённая версия с `asyncio.run()`

В Python начиная с версии 3.7 можно использовать более лаконичный способ запуска корутин. Метод `asyncio.run()` создаёт и запускает цикл событий автоматически, а затем закрывает его по завершении.

Пример того же кода, но более компактный:
```
import asyncio
from datetime import datetime
import aiohttp

async def task(task_id):
    async with aiohttp.ClientSession() as session:
        response = await session.get('http://python.org')
        response_html = await response.text()
    print(response_html[:15])
    print(f'Задача {task_id} выполнена.')

async def async_execute():
    tasks = [asyncio.ensure_future(task(i)) for i in range(1, 11)]
    await asyncio.wait(tasks)

if __name__ == '__main__':
    print('Асинхронное выполнение кода:')
    start_time = datetime.now()
    
    asyncio.run(async_execute())  # Запускаем всё в одну строчку

    end_time = datetime.now()
    print(f'Итоговое время выполнения: {end_time - start_time} секунд.')
```
## Как работает Event Loop?

Представьте, что есть несколько задач, и все они делают что-то долгое: ждут файл, сеть или таймер. Event Loop запускает задачу, а когда та уходит в ожидание, он переключается на другую. Так достигается высокая производительность без создания дополнительных потоков.
```
import asyncio

async def say_hello():
    await asyncio.sleep(1)
    print("Hello")

async def say_world():
    await asyncio.sleep(1)
    print("World")

async def main():
    await asyncio.gather(say_hello(), say_world())

asyncio.run(main())
```
Здесь `asyncio.run(main())` запускает Event Loop, который следит за обеими корутинами (`say_hello` и `say_world`), пока те не завершатся.
Основные методы и понятия:
|Понятие|Описание|
|---|---|
|`asyncio.run()`|Запускает Event Loop и завершает его по окончании всех задач|
|`await`|Приостанавливает выполнение корутины до завершения другой|
|`asyncio.gather()`|Выполняет сразу несколько корутин параллельно|
|`asyncio.sleep(n)`|Асинхронная пауза на `n` секунд|
|`asyncio.create_task()`|Регистрирует задачу для отслеживания Event Loop'ом|

## Почему это важно?

Асинхронность позволяет писать **отзывчивые, масштабируемые и быстрые программы**, особенно при работе с:
- API и веб-серверами,
    
- базами данных,
    
- обработкой большого количества подключений,
    
- задачами, где много времени тратится на ожидание.

# `aiohttp` и `httpx` — Асинхронные HTTP-клиенты в Python
В асинхронном программировании часто требуется делать HTTP-запросы (например, к API) без блокировки всего приложения. Для этого используются библиотеки:

- **`aiohttp`** — старейшая и наиболее популярная библиотека для асинхронных запросов.
    
- **`httpx`** — более новая альтернатива от создателей `requests`, поддерживает как синхронный, так и асинхронный режимы.
Установка
```
pip install aiohttp
```
## . Асинхронные запросы с `aiohttp`

### Основные понятия:

- Используется вместе с `async with` для безопасного открытия и закрытия сессий.
    
- Поддерживает `GET`, `POST`, `PUT`, `DELETE` и другие методы.
    
- Нужно явно закрывать соединения (через контекстный менеджер).
    

### Пример: получение HTML с сайта

```
import aiohttp
import asyncio

async def fetch(url):
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.text()

async def main():
    html = await fetch("https://example.com")
    print(html)

asyncio.run(main())
```
Как работает `aiohttp`
1. Создаём асинхронную сессию с aiohttp.ClientSession()
2. Выполняем запрос session.get/post/... через async with
3. Получаем данные через await response.text() или response.json()
Пример: несколько запросов параллельно
```
urls = ["https://example.com", "https://httpbin.org/get", "https://google.com"]

async def fetch_all(urls):
    async with aiohttp.ClientSession() as session:
        tasks = [session.get(url) for url in urls]
        responses = await asyncio.gather(*[handle_response(r) for r in tasks])
        return responses

async def handle_response(request_coro):
    async with await request_coro as response:
        return await response.text()

asyncio.run(fetch_all(urls))
```
# Практика
https://github.com/SkullPiercer/solva-asyncio
