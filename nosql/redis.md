# Кэширование с Redis

Redis — это высокопроизводительное хранилище структур данных, часто используемое как кэш, брокер сообщений или даже основное хранилище. Он хранит данные в памяти, что обеспечивает чрезвычайно быстрый доступ.



## Зачем использовать Redis как кэш?

- **Высокая скорость** — данные хранятся в оперативной памяти, что делает доступ к ним на порядки быстрее, чем к данным в реляционных СУБД
- **TTL (Time To Live)** — можно задать время жизни кэшируемых данных
- **Автоматическое удаление устаревших ключей**
- **Поддержка различных структур данных** — строки, списки, множества, хэши, sorted sets и др.
- **Простота использования** — понятный API, поддержка множества языков
- **Поддержка репликации и кластеризации**



## Примеры использования кэша

### 1. Кэширование результата дорогостоящей операции
```python
# Пример на Python с использованием redis-py
import redis

r = redis.Redis(host='localhost', port=6379, db=0)

def get_user_data(user_id):
    cache_key = f"user:{user_id}"
    cached = r.get(cache_key)
    if cached:
        return cached

    # Представим, что это дорогой запрос в БД
    user_data = db.get_user(user_id)
    r.setex(cache_key, 3600, user_data)  # Кэшируем на 1 час
    return user_data
```

### 2. Кэш HTML-страниц / API-ответов
```python
@app.route('/products')
def get_products():
    cached = r.get("products")
    if cached:
        return cached

    products = db.fetch_all_products()
    response = render_template("products.html", products=products)
    r.setex("products", 60, response)
    return response
```



## TTL и управление временем жизни

Команда `SETEX` позволяет задать TTL прямо при установке:
```bash
SETEX key 3600 "value"  # хранить значение 1 час
```

Команды управления TTL:
- `EXPIRE key seconds` — установить TTL
- `TTL key` — узнать сколько осталось жить ключу
- `PERSIST key` — убрать TTL



## Политики удаления ключей

Redis поддерживает несколько стратегий, когда заканчивается память:
- `noeviction` — выдаёт ошибку при нехватке памяти
- `allkeys-lru` — удаляет наименее используемые ключи (по алгоритму LRU)
- `volatile-ttl` — удаляет ключи с истекающим TTL, у которых самый короткий TTL
- `allkeys-random` — случайное удаление ключей

Выбор политики осуществляется через `redis.conf`:
```ini
maxmemory 256mb
maxmemory-policy allkeys-lru
```



## Механизмы восстановления данных

Redis предоставляет два основных механизма для обеспечения надёжности и восстановления данных после сбоя:

### 1. **RDB (Redis Database Backup)**
- Делает снимок данных в определённый момент времени (snapshot)
- Записывается в бинарный файл (обычно `dump.rdb`)
- Быстр в восстановлении
- Подходит, если не важна точность данных за последние секунды

#### Конфигурация:
```ini
save 900 1    # если за 900 секунд было как минимум 1 изменение
save 300 10   # если за 5 минут было как минимум 10 изменений
```

### 2. **AOF (Append Only File)**
- Логирует каждую операцию записи
- Более надёжен: можно восстановить до последней успешной операции
- Позволяет восстановить состояние Redis почти без потерь

#### Конфигурация:
```ini
appendonly yes
appendfsync everysec  # раз в секунду (баланс надёжности и производительности)
```

### 3. **Смешанный режим (Hybrid)**
С Redis 4.0 можно использовать оба режима одновременно: быструю загрузку из RDB и надёжность AOF.



## Распределённое кэширование и кластеризация

- Redis поддерживает **репликацию** (master → replica)
- Redis **Sentinel** обеспечивает отказоустойчивость и автоматическое переключение
- Redis **Cluster** позволяет масштабировать Redis горизонтально, разбивая ключи по slot-ам



## Расширенные применения

- **Rate Limiting** — ограничение числа запросов к API:
```python
key = f"rate:{user_id}"
if r.incr(key) == 1:
    r.expire(key, 60)  # 60 секундное окно
```

- **Pub/Sub** — реализация подписки на события между микросервисами
- **Task Queues** — использование Redis как брокера задач (например, для Celery)
- **Locks (блокировки)** — через `SET key value NX PX 10000`



## Лучшие практики

- Избегайте хранения больших объектов — Redis предназначен для небольших, часто используемых данных
- Устанавливайте TTL на кэшируемые значения
- Учитывайте возможность потери данных — Redis в первую очередь — in-memory
- Логируйте промахи кэша
- Используйте мониторинг (`INFO`, `MONITOR`, инструменты как RedisInsight)
- Используйте `SCAN`, а не `KEYS` в продакшене для избежания блокировок



## Инструменты и обёртки

- `redis-py` — официальная Python-библиотека
- RedisInsight — GUI-интерфейс от Redis
- `aioredis` — асинхронная работа с Redis в Python
- `Django-Redis` — интеграция с Django Cache Framework



## Что дальше?

- Изучите архитектуру Redis Sentinel и Redis Cluster
- Настройте автоматическое восстановление и бэкапы RDB/AOF
- Реализуйте гибридное кэширование (Redis + Memcached)
- Настройте метрики через Prometheus + Grafana



## Заключение

Redis — это мощный и гибкий инструмент, который может использоваться не только для кэширования, но и как фундаментальный компонент распределённых систем.
