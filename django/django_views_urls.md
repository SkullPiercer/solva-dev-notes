Продолжая работу с нашим приложением blog рассмотрим маршруты и представления.
View-функции (или просто **views**) — это центральный элемент любой Django-логики.  
Они обрабатывают HTTP-запросы от пользователя и возвращают HTTP-ответ (HTML-страницу, JSON-данные, файл и т.д.).

Чтобы понять, как работают view-функции, нужно разобраться с несколькими важными понятиями.

---
### **Виды HTTP-запросов**

Когда браузер или клиент обращается к серверу, он отправляет **HTTP-запрос**.  
Django поддерживает все стандартные методы HTTP, но чаще всего используются:

```
|Метод|Для чего применяется|Пример|
|---|---|---|
|**GET**|Получение данных. Не изменяет состояние сервера.|Загрузить страницу новостей.|
|**POST**|Отправка данных на сервер. Может изменить данные в БД.|Отправить форму регистрации.|
|**PUT**|Полное обновление ресурса.|Полностью обновить данные профиля.|
|**PATCH**|Частичное обновление ресурса.|Изменить только email пользователя.|
|**DELETE**|Удаление ресурса.|Удалить комментарий.|
```

**Важно**:
- `GET` обычно используют для получения страниц и данных.
    
- `POST` — для действий, которые изменяют данные.
    
- В Django view-функция сама определяет, какие методы обрабатывать (через `if request.method == 'POST'` или декораторы).

---
### **Абсолютные и относительные адреса**
#### **Абсолютный адрес (Absolute URL)**
Это полный путь к ресурсу, включая домен.  
Например:
```
https://example.com/news/2025/
```

Он содержит:
- Протокол (`https://`)
    
- Домен (`example.com`)
    
- Путь (`/news/2025/`)

Абсолютный адрес одинаков в любом месте сайта или приложения.

---
#### **Относительный адрес (Relative URL)**

Это путь относительно текущего местоположения.  
Например, находясь на странице `/news/`, ссылка `2025/` поведет на `/news/2025/`.

 В Django мы часто используем относительные пути в `href` или при формировании ссылок, но для генерации лучше использовать функцию **`reverse()`** или тег шаблона `{% url %}` — тогда при изменении маршрута в `urls.py` все ссылки автоматически обновятся.

---
### **Параметры в пути: `slug`, `int`, `str` и др.**

В Django `urls.py` можно передавать переменные прямо в адресе, чтобы view-функция получала их как аргументы.

Пример:
```
from django.urls import path
from . import views

urlpatterns = [
    path('news/<int:year>/', views.news_by_year),
]
```
Здесь `<int:year>` — параметр маршрута.

**Типы параметров в Django:**
```
|Тип|Что принимает|Пример URL|Переданное значение|
|---|---|---|---|
|`str` (по умолчанию)|Любая непустая строка, кроме `/`|`/post/hello/`|`"hello"`|
|`int`|Целое число|`/news/2025/`|`2025`|
|`slug`|Строка из букв, цифр, дефисов, подчеркиваний|`/blog/python-tips/`|`"python-tips"`|
|`uuid`|UUID-строка|`/item/550e8400-e29b-41d4-a716-446655440000/`|`"550e8400-e29b-41d4-a716-446655440000"`|
|`path`|Строка, включая `/`|`/docs/intro/setup/`|`"intro/setup"`|
```

**Slug** часто используют для красивых ссылок (SEO): вместо `/post/123/` — `/post/python-tips/`.

---
### **Как дать view-функции имя и зачем это нужно**

Каждый маршрут (`path`) в `urls.py` можно **назвать** с помощью параметра `name`:
```
urlpatterns = [
    path('news/<int:year>/', views.news_by_year, name='news_by_year'),
]
```

**Зачем это нужно?**

Чтобы удобно генерировать ссылки:
```
from django.urls import reverse
url = reverse('news_by_year', args=[2025])
# Результат: "/news/2025/"
```

Чтобы в шаблонах не писать адрес руками:
```
<a href="{% url 'news_by_year' 2025 %}">Новости 2025</a>
```

Чтобы при изменении адреса в `urls.py` не пришлось искать и исправлять все ссылки вручную.

Имена должны быть уникальными в пределах одного приложения, иначе `reverse()` и `{% url %}` не смогут однозначно определить путь.

---
### **Итоговая схема работы view в Django**

1. Пользователь открывает URL → браузер отправляет HTTP-запрос.
    
2. Django ищет соответствие в `urls.py` и находит нужный `path()`.
    
3. Если путь содержит параметры (`<int:id>`), они передаются в функцию.
    
4. View-функция выполняет логику (запрос в БД, вычисления и т.д.).
    
5. Возвращается HTTP-ответ (HTML, JSON и т.д.).

---
# Рассмотрим вышеперечисленное на примере

К головному файлу blog/urls.py добавим маршруты нашего приложения posts, для этого: 
```
from django.contrib import admin
from django.urls import include, path # Добавляем include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('posts/', include('posts.urls')),  # Подключаем URL-адреса приложения posts
]
```

Дальше опишем простую view-функцию, которая будет возвращать любой текст:
```
# posts/views.py
from django.http import HttpResponse

def all_posts(request):
    return HttpResponse('Тут будут все посты')
```

Для того чтобы получить данные от этой функции на странице, нужно выделить ей адрес и прописать в urls его приложения:
```
# posts/urls.py
from django.urls import path

from . import views # Подключаем views из текущего приложения

urlpatterns = [
    path('', views.all_posts, name='all_posts'), # URL для отображения всех постов
]
```

Все готово, теперь при переходе на 
```
http://127.0.0.1:8000/posts/
```

Мы увидим
```
Тут будут все посты
```
---
## **Переменные из URL**
Для начала напишем view-функцию, которая помимо request, будет принимать post_id, и возвращать ответ в формате: 'text post_id'
```
def post_detail(request, post_id):
    return HttpResponse(f'Детали поста с ID {post_id}')
```

Подключим ее к маршруту из которого django и будет брать post_id:
```
from django.urls import path

from . import views # Подключаем views из текущего приложения
  
urlpatterns = [
    path('', views.all_posts, name='all_posts'), # URL для отображения всех постов
    path('<int:post_id>/', views.post_detail, name='post_detail'), # URL для отображения деталей поста по ID
]
```

