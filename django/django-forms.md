В первые годы существования Интернета веб-ресурсы были крайне примитивными. Они представляли собой набор статических страниц, связанных гиперссылками, и могли лишь отображать заранее подготовленный контент. Пользователь открывал страницу, читал текст, переходил по ссылкам, но никак не влиял на содержимое сайта.

Очень скоро стало понятно, что такой формат ограничивает развитие технологий. Во второй версии HTML (сегодня актуальна пятая) появились специальные теги для создания форм ввода данных, а браузеры научились передавать информацию, введённую пользователем, на сервер.

Сейчас сложно представить веб-приложения без обмена данными в обе стороны. Многие привычные действия — от авторизации до оформления заказа — требуют, чтобы браузер отправил сведения пользователя серверу.

### HTML-формы

HTML-форма — это элемент страницы, предназначенный для ввода и отправки данных. Она состоит из различных компонентов: текстовых полей, выпадающих списков, радиокнопок, чекбоксов, кнопок загрузки файлов, а также управляющих элементов вроде «Отправить» или «Сбросить».  
Внутри формы можно размещать вспомогательные надписи, подсказки и сообщения об ошибках. При этом HTML-разметка формы допускает добавление любых тегов, чтобы оформить её в нужном стиле.

Когда пользователь вводит данные в форму и нажимает кнопку «Отправить», браузер формирует HTTP-запрос к серверу, используя метод, указанный в атрибуте `method` формы — обычно это **GET** или **POST**. В теле или параметрах запроса передаются введённые значения.

Помимо видимых полей, форма может содержать и скрытые элементы (`type="hidden"`). Они не отображаются в браузере, но могут быть заполнены автоматически — например, при генерации формы скриптом. Такие поля часто применяются для передачи служебной информации.

Ниже приведён пример минимальной HTML-формы: одно поле ввода и кнопка отправки. Подобная форма может служить, например, для передачи имени пользователя на сервер.

```
<form>  
  <input type="text" name="username" required>
  <input type="submit" value="Отправить">
</form>
```

`<form>` — это парный HTML-тег, который задаёт область формы: всё, что находится между открывающим и закрывающим тегами, относится к её содержимому.

`<input>` — универсальный одиночный элемент, способный выполнять разные роли в зависимости от указанных параметров: он может быть текстовым полем, кнопкой, переключателем (radio), флажком (checkbox) и многим другим.

### Атрибуты тега `<input>`

Одним из ключевых атрибутов является `type`. Он определяет, как именно элемент будет отображаться в браузере и как пользователь сможет с ним взаимодействовать. В зависимости от значения `type`, `<input>` может принимать самые разные формы.

Примеры возможных значений:
| Значение           | Назначение                                                                 | Пример кода |
|--------------------|----------------------------------------------------------------------------|-------------|
| **text**           | Однострочное поле для ввода текста.                                        | `<input type="text" name="username" placeholder="Введите имя">` |
| **password**       | Поле для ввода пароля, символы заменяются точками или звёздочками.         | `<input type="password" name="pass">` |
| **email**          | Поле для ввода e-mail; браузер может проверять правильность формата.       | `<input type="email" name="email">` |
| **number**         | Поле для ввода чисел; можно задать диапазон через `min` и `max`.           | `<input type="number" name="age" min="1" max="120">` |
| **tel**            | Поле для ввода телефона; на мобильных устройствах выводит цифровую клаву. | `<input type="tel" name="phone">` |
| **url**            | Поле для ввода адреса сайта с проверкой формата.                          | `<input type="url" name="website">` |
| **search**         | Поле для поиска с кнопкой очистки (в некоторых браузерах).                 | `<input type="search" name="query">` |
| **checkbox**       | Флажок (галочка), позволяющий выбрать один или несколько вариантов.       | `<input type="checkbox" name="subscribe">` |
| **radio**          | Переключатель для выбора одного варианта из группы.                       | `<input type="radio" name="gender" value="male">` |
| **file**           | Кнопка выбора файла на устройстве.                                        | `<input type="file" name="avatar">` |
| **date**           | Выбор даты с календарём.                                                   | `<input type="date" name="birthdate">` |
| **time**           | Выбор времени (часы и минуты).                                             | `<input type="time" name="meeting_time">` |
| **datetime-local** | Выбор даты и времени (без часового пояса).                                 | `<input type="datetime-local" name="appointment">` |
| **range**          | Ползунок для выбора значения из диапазона.                                | `<input type="range" name="volume" min="0" max="100">` |
| **color**          | Выбор цвета через палитру.                                                 | `<input type="color" name="favcolor">` |
| **hidden**         | Скрытое поле для передачи служебных данных.                               | `<input type="hidden" name="token" value="12345">` |
| **submit**         | Кнопка отправки формы.                                                     | `<input type="submit" value="Отправить">` |
| **reset**          | Кнопка для сброса значений формы.                                          | `<input type="reset" value="Очистить">` |
| **button**         | Обычная кнопка с действием, заданным JS-скриптом.                         | `<input type="button" value="Нажми" onclick="alert('Привет!')">` |

---
Если в атрибуте `type` задан определённый формат данных (например, `number` для чисел или `email` для адреса электронной почты), браузер перед отправкой формы автоматически выполнит проверку введённых значений. Если данные не соответствуют требуемому формату, пользователь увидит сообщение об ошибке, и форма не будет отправлена до исправления.

---
## Дополнительные атрибуты `<input>`
- **`name`** — задаёт уникальное имя элемента, по которому сервер будет получать переданное значение.
    
- **`required`** — делает поле обязательным для заполнения перед отправкой формы.
    
- **`value`** — используется по-разному в зависимости от типа элемента:
    
    - для кнопок (`type="submit"` или `type="reset"`) определяет надпись;
        
    - для полей ввода задаёт значение по умолчанию.
        

Полный перечень атрибутов `<input>` с описанием можно найти в официальной спецификации HTML.

Когда пользователь нажимает кнопку отправки формы (обычно `<input type="submit">`), браузер собирает все поля формы и формирует для каждого пару **«имя=значение»**:

- имя берётся из атрибута `name`;
    
- значение — это введённые данные или значение, указанное по умолчанию.
    

Например, если в поле с `name="username"` введено **Олег**, на сервер будет передано:
```
username=Олег
```


## Подписи к полям (`<label>`)

Чтобы сделать форму более понятной, для каждого поля можно указать заголовок. Чаще всего для этого используется тег `<label>` — «метка» для поля ввода.

Пример:
```
<form>
  <label>Введите имя:</label>
  <input type="text" name="user_name" required>
  <input type="submit" value="Отправить">
</form>
```
Хотя для подписей можно применять и другие теги (например, `<span>`), у `<label>` есть важное преимущество: он позволяет кликать по надписи, чтобы активировать связанный элемент (поле ввода или чекбокс).

Чтобы связать `<label>` с конкретным элементом:

1. В `<input>` указываем уникальный `id`.
    
2. В `<label>` прописываем атрибут `for` со значением этого `id`.

```
<form>
  <label for="is_robot">Вы робот?</label>
  <input id="is_robot" type="checkbox" name="robot">
  <input type="submit" value="Отправить">
</form>
```
Теперь кликая по надписи «Вы робот?», пользователь будет устанавливать или снимать галочку.

---
## Атрибуты `<form>`

У тега `<form>` есть множество параметров, но ключевые для базовой работы — это `method` и `action`:
- **`action`** — указывает адрес (URL), на который будут отправлены данные формы.
    
- **`method`** — определяет HTTP-метод запроса:
    
    - `get` — данные передаются в адресной строке (подходит для поиска и фильтрации);
        
    - `post` — данные передаются в теле запроса (используется при регистрации, входе, публикации сообщений и т. д.).

Если `method` и `action` не заданы:
- запрос отправляется методом **GET**;
    
- данные уходят на тот же адрес, где находится страница с формой.

Пример: если форма размещена на странице `https://acme.not/form/` без указания `method` и `action`, то после отправки браузер выполнит GET-запрос на этот же адрес.

---
## Как выглядит GET-запрос

При использовании метода **GET** данные из формы добавляются к URL в виде параметров.

Пример HTML-кода:
```
<form method="get" action="/submit">
  <p>
	<label>Введите имя: </label>
	<input type="text" name="username" required>
  </p>
  <p>
	<label for="is_robot">Вы робот?</label>
	<input id="is_robot" type="checkbox" name="robot"><br>
	<small>Поставьте галочку если вы ИИ</small>
  </p>
  <p>
	<input type="submit" value="Отправить">
  </p>
</form>
```

Если пользователь введёт имя **Олег** и поставит галочку, адрес в браузере после отправки будет выглядеть так:
```
/submit?username=Олег&robot=on
```

---
Проведём небольшой эксперимент.  
В той же папке, где находится файл html, создадим ещё один документ — `welcome.html`. В нём разместим произвольный текст, например:
```
<!-- welcome.html -->
<html>
  <head>
    <title>Добро пожаловать</title>
  </head>
  <body>
    <h1>Добро пожаловать на сайт</h1>
  </body>
</html>

```

Теперь в коде основного html пропишем у формы атрибут `action="welcome.html"`, чтобы при отправке данных запрос был направлен на эту страницу
```
<form action="welcome.html">
  ...
</form>
```

В адресной строке при этом появятся параметры запроса — это данные, введённые в форму.

---
## Передача данных методом POST

Теперь изменим форму так, чтобы данные отправлялись через **POST**
```
<form action="welcome.html" method="post">
  ...
</form>
```
После сохранения изменений и повторной отправки формы вы снова попадёте на `welcome.html`, но параметры в адресной строке исчезнут — в POST-запросах информация передаётся в теле запроса, а не в URL.

---
## Как посмотреть отправленные данные

Чтобы убедиться, что данные всё же передаются, можно открыть **Инструменты разработчика**:
- Windows — `F12`
    
- Linux — `Ctrl + Shift + I`
    
- macOS — `Command + Option + I`

1. Перейдите на вкладку **Network** (Сеть) и включите фильтр **All**.
    
2. Отправьте форму и кликните по запросу, который появился в списке слева.
    
3. На вкладке **Payload** будет видно содержимое тела POST-запроса.

Если нажать **view source**, можно заметить, что формат данных совпадает с GET-запросом, но способ передачи отличается.

---
## Формы без сервера — зачем они нужны?

Даже в статичном HTML-файле форма является готовым интерфейсом для отправки запросов на сервер (если такой сервер есть и готов принять данные).

Например, достаточно изменить `action` и `name` поля ввода — и форма превратится в поисковый интерфейс, но для начала исследуем запрос в гугл на поиск котиков в интернете:
```
Выглядит он следующим образом
https://www.google.com/search?q=%D0%BA%D0%BE%D1%82%D0%B8%D0%BA%D0%B8 #
```
Почему котики превратились в %D0%BA%D0%BE%D1%82%D0%B8%D0%BA%D0%B8 ?
Это нормальное поведение — браузер **кодирует строку запроса** в формате **URL encoding (percent-encoding)**, чтобы её можно было безопасно передать по HTTP.

---
### Что происходит

- Адресная строка и параметры запроса могут содержать **только ASCII-символы**.
    
- Всё, что выходит за пределы ASCII (например, кириллица, пробелы, спецсимволы), кодируется.
    
- В случае кириллицы символы сначала переводятся в байты в кодировке **UTF-8**, а потом каждый байт заменяется на `%XX` (где `XX` — шестнадцатеричное значение байта).
    

---
### Пример для слова `котики`

1. Слово `"котики"` в UTF-8 превращается в последовательность байт:
```
D0 BA D0 BE D1 82 D0 B8 D0 BA D0 B8

```
2. Каждый байт кодируется как `%XX`:
```
%D0%BA%D0%BE%D1%82%D0%B8%D0%BA%D0%B8
```

В адресной строке именно это и отображается

---
Соберем форму на основе полученной информации:
```
<html>
  <head>
    <title>А не поискать ли в Google?</title>
  </head>
  <body>
    <!-- Ставим адрес, куда должен уйти запрос -->
    <form action="https://www.google.com/search"> 
      <p>
        <label>Введите запрос: </label>
        <!-- Ставим то name поля, которое ожидает сервер: q -->
        <input type="text" name="q" required>
      </p>
      <!-- Для красоты меняем название на кнопке -->
      <input type="submit" value="Спросить у Google">
    </form>
  </body>
</html>
```
Теперь мы можем отправлять гугл запросы прямиком из нашей формы!

---
# forms.Form

Внутри приложения создадим файл forms.py
В Django каждая форма описывается как класс, где отдельные поля указываются в виде атрибутов. Для задания типа поля применяются специальные классы из модуля `django.forms`, и почти все они имеют суффикс `Field`.  
Например:

- `IntegerField` — для числовых значений,
    
- `CharField` — для строк,
    
- `DateField` — для дат.

Полный перечень таких полей можно найти в официальной документации.

Простейший пример формы для ввода имени, фамилии и даты рождения может выглядеть так:
```
from django import forms

class TaskForm(forms.Form):
    title = forms.CharField()
    description = forms.CharField()
    dead_line = forms.DateField()
```

Кроме самого объявления полей, их поведение можно настраивать: указывать максимальную длину текста, задавать обязательность или необязательность заполнения и т. д.  
Например, ограничим имя двадцатью символами, а фамилию сделаем опциональной (по умолчанию поля обязательные, поэтому `required=True` указывать нет необходимости):
```
from django import forms

class TaskForm(forms.Form):
    title = forms.CharField(max_length=20)
    description = forms.CharField(required=False)
    dead_line = forms.DateField()
```

В таком виде форма не даст ввести title длиннее 20 символов и не позволит оставить пустыми поля title или dead_line, но description может быть не заполнена.

Теперь нужно отобразить эту форму на странице по адресу `/task/`.  
Маршрут уже привязан к функции `create_task()` во `views.py`, и эта функция отрисовывает шаблон `create_task.html`.

---

### HTML-шаблон формы

В Django принято передавать экземпляр формы в шаблон под ключом `form`. Этот объект содержит готовую HTML-разметку полей, поэтому вручную прописывать каждое поле не требуется. Но оболочку `<form>` и кнопку отправки мы добавляем сами:
```
{% extends "base.html" %}

{% block content %}
  <form>
    {{ form }}
    <input type="submit" value="Отправить">
  </form>
{% endblock %}
```
Такой подход позволяет быстро вставлять всю форму одной переменной.

---

### Контроллер (view)

Во view-функции мы создаём экземпляр формы и передаём его в шаблон через словарь контекста:
```
from django.shortcuts import render
from .forms import TaskForm  # подключаем класс формы

def create_task(request):
    form = TaskForm()                # создаём форму
    context = {'form': form}             # помещаем её в контекст
    return render(request, 'task.html', context)

```
Теперь при переходе на `/task/` пользователь увидит веб-форму, описанную в `TaskForm`.

---

### Как может выглядеть форма в HTML

Когда мы выводим форму на страницу `/birthday/`, Django по умолчанию представит её в виде таблицы.  
HTML-таблица строится из строк, а строки, в свою очередь, содержат ячейки.

Основные теги, которые используются:

- `<tr></tr>` — обозначает строку таблицы,
    
- `<td></td>` — обычная ячейка таблицы, в ней располагаются данные,
    
- `<th></th>` — заголовочная ячейка, её обычно применяют для названий колонок или подписей.

Таким образом, каждая строка таблицы может состоять, например, из заголовка (`<th>`) и значения (`<td>`).

Если хочется разобраться подробнее, как строятся таблицы и какие есть атрибуты у этих тегов, это можно найти в справочнике по HTML.

---
### Виджеты для форм в Django

Когда мы описываем класс формы, важно не только определить типы полей, но и то, **как именно пользователь будет вводить данные**. В HTML один и тот же тег `<input>` может работать по-разному: это может быть текстовое поле, поле для чисел, переключатель (checkbox) или календарь для выбора даты.

В Django внешний вид и поведение полей управляются **виджетами**.

- У каждого типа поля есть свой виджет по умолчанию,
    
- но разработчик может заменить его на другой, чтобы лучше подстроить интерфейс под задачу.

Список доступных встроенных виджетов можно найти в официальной документации.

---

#### Пример: выбор даты

Для поля с дедлайном задачи можно указать виджет календаря. В таком случае:

- пользователь сможет выбрать дату с помощью календаря,
    
- Django автоматически проверит правильность формата,
    
- при желании пользователь всё равно может ввести дату текстом, и система проверит, существует ли она.

Чтобы подключить такой виджет, в аргумент `widget` указывается `forms.DateInput` с атрибутом `type="date".
```
from django import forms

class TaskForm(forms.Form):
    title = forms.CharField(
        label='Заголовок',
        max_length=20
    )
    description = forms.CharField(
        label='Описание',
        required=False,
        help_text='Можно оставить пустым'
    )
    dead_line = forms.DateField(
        label='Дедлайн',
        widget=forms.DateInput(attrs={'type': 'date'})
    )
```

Теперь при выводе формы на страницу в поле для дедлайна отобразится календарь.

---
### Создание формы из модели с помощью `ModelForm`

После того как модель описана, в Django можно не писать форму вручную, а построить её автоматически на основе этой модели. Для этого существует специальный класс — `ModelForm`. Он связывает поля формы с атрибутами модели, поэтому данные, введённые пользователем, будут подходить для дальнейшего сохранения в объекте БД.

---

#### Как это делается

1. Создаём новый класс и наследуем его от `forms.ModelForm`.
    
2. Внутри объявляем вложенный класс `Meta`.
    
    - В `Meta` нужно указать модель, из которой будут генерироваться поля.
        
    - Там же задаётся список полей, которые попадут в форму.
        

Есть несколько вариантов:

- `fields = ('title', 'dead_line')` — в форму войдут только эти поля.
    
- `exclude = ('description',)` — исключим указанные поля, а остальные будут добавлены.
    
- `fields = '__all__'` — форма создаётся со всеми полями модели.
    

> 💡 Лучше явно перечислять поля, которые нужны, чтобы случайно не вывести служебные или технические поля (например, связанные с внешними ключами).
#### Пример

Предположим, у нас есть модель `Task`. Форма на её основе будет выглядеть так:
```
from django import forms
from .models import Task

# Для работы с моделями используем ModelForm
class TaskForm(forms.ModelForm):
    class Meta:
        # Указываем связанную модель
        model = Task
        # Для наглядности выводим все поля модели
        fields = '__all__'
```

---
#### Подключение календаря

Чтобы удобнее выбирать дату дедлайна, укажем для этого поля специальный виджет — HTML-календарь:
```
class TaskForm(forms.ModelForm):
    class Meta:
        model = Task
        fields = '__all__'
        widgets = {
            'dead_line': forms.DateInput(attrs={'type': 'date'})
        }
```

- С точки зрения пользователя форма останется такой же, как и при ручном описании.
    
- Но теперь она связана с моделью: если в `Task` добавить новое поле, то при `fields = '__all__'` оно автоматически появится и в форме.
    
- Сохранение данных в базу пока не происходит автоматически — обработку нужно реализовать в представлении (`views.py`).

---
### CSRF-защита в Django

Фреймворк Django из коробки обеспечивает защиту от CSRF-атак. Она используется для всех запросов, которые могут изменить данные на сервере — то есть для `POST`, `DELETE` и `PATCH`.

Механизм работает следующим образом:

- Когда рендерится HTML-форма, в неё автоматически добавляется скрытое поле со специальным токеном — `csrfmiddlewaretoken`. Это случайная строка, сгенерированная Django.
    
- Параллельно копия этого же токена сохраняется в cookies браузера. Доступ к этим cookies злоумышленник получить не может.
    

Что это даёт?

- Если кто-то попытается отправить поддельную форму, в ней не окажется корректного CSRF-токена.
    
- Даже если токен в форме будет подставлен, но не совпадёт с токеном из cookies, проверка не пройдёт.
    
- В результате сервер отвергнет такой запрос с ошибкой `403 Forbidden`. В режиме разработки появится сообщение об ошибке с объяснением.
    

Для `GET`-запросов токен не требуется, так как они должны только читать данные, а не менять их. Но важно, чтобы разработчик правильно использовал HTTP-методы (например, не вносил изменения через `GET`).

---
### Как добавить CSRF-токен в шаблон

Django не встраивает токен в сам объект формы. Его нужно явно указать в HTML-коде шаблона. Делается это через тег `{% csrf_token %}`:
```
<form method="post">
  {% csrf_token %}
  ...
</form>
```
Всегда добавляйте этот тег во все формы, отправляющие `POST`-запросы. Если токена не будет, сервер по умолчанию вернёт ошибку `403`.

---
### Пример CSRF-атаки

Предположим, у нас есть сайт `http://mytasks.com`, где пользователь может добавлять задачи. На странице `/add-task/` форма выглядит так:
```
<form method="post" action="/add-task/">
  <input type="text" name="title" value="Моя задача">
  <input type="submit" value="Создать">
</form>
```

Эта форма нормально работает, если пользователь авторизован.
#### Как атакующий может попробовать обмануть
Злоумышленник может разместить у себя на сайте поддельную форму:
```
<!-- Вредоносный сайт злоумышленника -->
<form method="post" action="http://mytasks.com/add-task/">
  <input type="hidden" name="title" value="Удалить все задачи">
  <input type="submit" value="Кликни меня!">
</form>
```

Если жертва авторизована на `mytasks.com` и случайно откроет этот сайт, браузер автоматически отправит запрос вместе с её cookies. Без защиты сервер мог бы воспринять такой запрос как настоящий.
#### Что делает CSRF-токен

Но Django требует CSRF-токен в каждом `POST`-запросе.
- В настоящей форме на `mytasks.com` есть скрытое поле:
```
<input type="hidden" name="csrfmiddlewaretoken" value="a1b2c3d4...">
```
- В поддельной форме на сайте злоумышленника этого токена **нет**.

Когда запрос придёт на сервер, Django проверит:

1. Есть ли CSRF-токен в теле формы.
    
2. Совпадает ли он с токеном, который хранится в cookies пользователя.

Так как во вредоносной форме токен отсутствует, проверка провалится, и сервер вернёт **403 Forbidden**.

---
### Сохранение данных формы в базу

Формы, созданные на основе моделей (`ModelForm`), обладают удобным методом `.save()`.  
Этот метод берёт проверенные данные из формы и создаёт (или обновляет) объект модели в базе данных. После выполнения он возвращает сам объект, с которым можно дальше работать — например, вывести его id или название.
#### Пример использования
```
# tasks/views.py
from django.shortcuts import render
from .forms import TaskForm

def add_task(request):
    # Создаём форму, заполняем её данными из POST-запроса (если они есть)
    form = TaskForm(request.POST or None)
    context = {'form': form}

    # Проверяем корректность данных
    if form.is_valid():
        # Сохраняем задачу в БД
        task = form.save()
        # Передаём созданный объект в шаблон
        context['task'] = task

    return render(request, 'tasks/add_task.html', context)
```

---
## Шаблон с выводом информации о сохранённой задаче
```
<!-- templates/tasks/add_task.html -->
<form method="post">
  {% csrf_token %}
  {{ form.as_p }}
  <button type="submit">Сохранить</button>
</form>

{% if task %}
  <hr>
  <p>Новая задача сохранена в базе!</p>
  <p><strong>ID:</strong> {{ task.id }}</p>
  <h3>{{ task.title }}</h3>
  {% if task.description %}
    <p>{{ task.description }}</p>
  {% endif %}
  <p>Дедлайн: {{ task.dead_line }}</p>
{% endif %}
```
### Что изменилось
- После отправки формы и успешной проверки в базе появляется новая запись.
    
- Метод `.save()` возвращает объект модели — его можно использовать в шаблоне для отображения ID или других данных.
    
- Таким образом, пользователь сразу видит результат сохранения, а в БД хранится новая задача.
