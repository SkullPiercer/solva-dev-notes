В любом веб-приложении важно защитить данные и действия добросовестных участников от случайных или вредоносных вмешательств. Для этого в Django предусмотрена встроенная система работы с пользователями, которая включает **регистрацию, аутентификацию и авторизацию**.
#### Регистрация

Регистрация — это первый шаг для нового пользователя. В процессе регистрации он создаёт учётную запись: задаёт логин (или email) и пароль, а также при необходимости другие данные профиля. Эта информация сохраняется в базе данных и используется для дальнейшей идентификации.

Зачем нужна регистрация:
- только зарегистрированные пользователи могут создавать контент (например, оставлять записи или комментарии);
    
- система может отслеживать активность и историю действий каждого пользователя;
    
- появляется возможность персонализации (профиль, настройки, подписки и т.д.);
    
- повышается уровень доверия к проекту, так как доступ получают только реальные участники, а не случайные гости.

#### Аутентификация

Аутентификация — это проверка личности пользователя при входе в систему.  
Пример: пользователь вводит логин **Вася** и пароль. Django сверяет эти данные с теми, что были сохранены при регистрации. Если пара совпадает — вход разрешается, и система понимает, что действительно к ней обратился именно этот пользователь.

#### Авторизация

После успешной аутентификации наступает следующий шаг — авторизация. Она определяет, какие конкретные действия или разделы доступны пользователю.

Пример:
- Пользователь **Вася** входит в проект и пытается попасть на страницу администрирования `/admin/`. Django проверяет, есть ли у него права администратора. Если прав нет — доступ запрещён, возвращается ошибка **403 — Forbidden**.
    
- Но при этом тот же пользователь может открыть страницу `/task/list/`, так как она доступна всем зарегистрированным.

#### Зачем это всё нужно в приложении
1. **Безопасность**: защита от нежелательных действий анонимных пользователей.
    
2. **Контроль доступа**: гибкая настройка прав — кто может редактировать записи, кто только читать, а кто управлять системой.
    
3. **Персонализация**: возможность хранить историю, профили, предпочтения.
    
4. **Надёжность архитектуры**: система аутентификации и авторизации в Django встроена «из коробки», что избавляет от необходимости разрабатывать её самостоятельно.

Таким образом, связка «регистрация → аутентификация → авторизация» образует фундамент работы с пользователями в Django-проектах.
- **Регистрация** создаёт нового участника системы.
    
- **Аутентификация** проверяет его подлинность.
    
- **Авторизация** определяет, что именно ему доступно.

Это базовый механизм, который обеспечивает безопасность и правильное распределение ролей в приложении.

---
## Работа с пользователями в Django: модуль `django.contrib.auth`

Система учётных записей в Django реализована через набор встроенных модулей и middleware, которые автоматически включаются в проект при его создании. Главным элементом здесь является приложение **`django.contrib.auth`**, отвечающее за аутентификацию, авторизацию и управление пользователями.

### Подключение `django.contrib.auth`

При создании нового проекта Django это приложение сразу же оказывается в списке установленных приложений в `settings.py`:

```
INSTALLED_APPS = [
    ...,
    'django.contrib.admin',
    'django.contrib.auth',   # Работа с пользователями и системой прав.
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    ...,
]
```

Таким образом, никакой дополнительной настройки для базового использования не требуется — модуль готов к работе "из коробки".

---

### Возможности `django.contrib.auth`

Модуль предоставляет уже реализованные механизмы для типовых задач, которые встречаются в любом веб-приложении:

- **аутентификация (login)** — вход пользователя в систему по логину и паролю;
    
- **логаут (logout)** — корректный выход из системы;
    
- **смена и сброс пароля** через встроенные формы и email-уведомления;
    
- **проверка прав доступа** к страницам и действиям;
    
- **управление пользователями** — администратор может создавать, редактировать и удалять аккаунты.
    

Кроме того, модуль содержит свои `urls.py`, `views.py` и набор шаблонов для отображения страниц входа/выхода, восстановления пароля и т.д., что позволяет быстро подключить систему аутентификации без написания кода с нуля.

---

### Модель пользователя: `User`

После запуска миграций в проекте автоматически появляется таблица в базе данных, связанная с моделью **`User`**. Каждый зарегистрированный пользователь — это объект этой модели.

Основные поля модели `User`:
- **username** — уникальное имя пользователя;
    
- **password** — пароль в зашифрованном виде;
    
- **email** — электронная почта;
    
- **first_name**, **last_name** — имя и фамилия (используются для отображения профиля);
    
- **groups** — принадлежность к группам пользователей;
    
- **user_permissions** — индивидуальные разрешения (например, доступ к редактированию статей);
    
- **is_staff** — флаг, определяющий доступ к админ-панели;
    
- **is_active** — статус активности (можно деактивировать пользователя без удаления);
    
- **is_superuser** — флаг суперпользователя с полным набором прав;
    
- **last_login** — время последнего входа;
    
- **date_joined** — дата регистрации.

На самом деле, это обычная Django-модель: у неё можно создавать объекты, изменять их и удалять точно так же, как и у любых других моделей.

Пример создания пользователя через Python-консоль:
```
from django.contrib.auth.models import User

user = User.objects.create_user(
    username='OlegCoolProger',
    email='duck@example.com',
    password='secure_password123'
)
```

### Почему это важно
1. **Стандартизация**: `django.contrib.auth` — часть ядра фреймворка, что делает код предсказуемым и совместимым с большинством сторонних приложений.
    
2. **Безопасность**: пароли автоматически хранятся в зашифрованном виде, используются проверенные механизмы хэширования.
    
3. **Ускорение разработки**: готовые формы и шаблоны позволяют внедрить авторизацию за считанные минуты.
    
4. **Гибкость**: при необходимости можно расширить стандартную модель `User` или даже заменить её на свою кастомную.
---
## Пользователи, права и группы в Django

Система пользователей в Django устроена гибко: мы можем управлять не только отдельными аккаунтами, но и назначать им **права (permissions)** и объединять в **группы**. Благодаря этому администратор может тонко контролировать, кто и какие действия выполняет в приложении.

---
### Права пользователей (Permissions)

Каждая модель в Django автоматически получает четыре базовых права:
- **add** — возможность создавать новые объекты;
    
- **view** — доступ к просмотру;
    
- **change** — редактирование;
    
- **delete** — удаление.

Таким образом, если в проекте есть модель **Task**, то в админке для неё будут созданы права: _add task_, _view task_, _change task_, _delete task_.  
Администратор может назначить эти права конкретному пользователю. Например, одному пользователю можно разрешить просматривать задачи, но запретить их изменять и удалять.

---
### Группы пользователей

Выдавать права каждому пользователю вручную неудобно, особенно если их сотни. Для этого существует механизм **групп**:
- создаём группу (например, _Редакторы задач_),
    
- назначаем ей нужные права,
    
- добавляем пользователей в эту группу.

Теперь все участники группы автоматически наследуют её права.  
Группы можно использовать и в прикладной логике: например, показывать разный интерфейс пользователям из разных групп или рассылать им разные уведомления.

---
### Суперпользователь и персонал

Особая роль в системе принадлежит **суперпользователю (superuser)**. У него в настройках установлено `is_superuser=True`, и это означает, что он получает все возможные права автоматически, даже если они явно не назначены.

При этом есть тонкость: чтобы получить доступ в админку, у пользователя должно быть включено поле **is_staff**. Даже суперпользователь с выключенным `is_staff` обладает всеми правами, но войти в административный интерфейс не сможет.

---
### Пример настройки прав
1. Создаём обычного пользователя.
    
2. Включаем ему флаг **is_staff**, чтобы разрешить вход в админку.
    
3. Не назначаем дополнительных прав.

В этом случае пользователь войдёт в админку, но не сможет управлять моделями.

Теперь добавим ему право **view task**. После этого он сможет видеть список задач в административной панели, но изменять или удалять их по-прежнему не получится.

---
### Права на пользовательских страницах

Важно понимать: проверка прав доступа в админке работает по умолчанию. Но если мы создаём свои страницы (например, `/task/`, `/task/<pk>/edit/`, `/task/<pk>/delete/`), то ответственность за проверку прав ложится на разработчика.

Для этого используются декораторы и mixin-классы:
- `@login_required` — доступ только авторизованным пользователям;
    
- `PermissionRequiredMixin` — проверка конкретного права у пользователя;
    
- `UserPassesTestMixin` — проверка по кастомному условию.

Если пользователь не соответствует условиям, то Django вернёт ошибку **403 Forbidden**.

---
## Расширение модели пользователя

Иногда стандартных полей (`username`, `email`, `password`, и т.д.) недостаточно. Например, нужно хранить биографию или фотографию. Django предлагает два пути:

1. **Расширить модель через связь один-к-одному**  
    Создаётся отдельная модель, например, `Profile`, которая хранит дополнительные поля и связана с `User`.  
    Плюсы: можно внедрить в уже работающий проект.  
    Минусы: дополнительные запросы к БД, настройка админки.
    
2. **Заменить модель пользователя на кастомную**  
    Для этого создаётся новая модель, унаследованная от `AbstractUser`.  

Пример: 
```
from django.contrib.auth.models import AbstractUser
from django.db import models

class MyUser(AbstractUser):
    bio = models.TextField('О себе', blank=True)
```

В `settings.py` указываем:
```
AUTH_USER_MODEL = 'users.MyUser'
```

После этого регистрируем модель в админке и применяем миграции.
Такой подход предпочтительнее, но важно помнить: замену модели лучше делать **в самом начале проекта**.
  
---
### Работа с моделью пользователя в коде

Если проект использует кастомную модель пользователя, напрямую обращаться к `User` уже нельзя. Чтобы не привязываться к конкретному классу, используется функция `get_user_model()`.

Пример:
```
from django.contrib.auth import get_user_model

User = get_user_model()

# Теперь User будет ссылаться на кастомную модель
users = User.objects.all()
```
Если изначально использовать `get_user_model()`, то в случае замены модели пользователя менять код по всему проекту не придётся.

---
### AbstractBaseUser — полный контроль

Если нужны нестандартные варианты (например, вход только по email вместо username), можно создать модель, унаследованную от `AbstractBaseUser`. В этом случае разработчик сам определяет все поля и методы. Такой способ даёт максимальную гибкость, но требует значительно больше работы.

---
# Разграничение прав доступа в Django

При разработке веб-приложений на Django часто возникает необходимость разграничить права пользователей. Простая регистрация и вход ещё не гарантируют безопасность: если не настроить контроль доступа, любой человек, даже случайный посетитель, сможет изменять и удалять чужие данные. В нашем проекте с задачами (**Task**) такая ситуация недопустима — каждый пользователь должен управлять только своими задачами.
## Пользователь и объект request

Каждый запрос в Django сопровождается объектом `request`, в котором хранится информация о методе, URL, заголовках и параметрах. В нём также есть свойство `user`, представляющее текущего пользователя.

- Если пользователь вошёл в систему, то `request.user` будет экземпляром модели пользователя (например, User с `id=15`).
    
- Если пользователь анонимный, объект всё равно существует, но его свойство `is_authenticated` будет `False`.

Таким образом, для любой проверки авторизации мы можем использовать `request.user.is_authenticated`. Это же свойство доступно и в шаблонах, где можно выводить имя пользователя или скрывать определённые элементы интерфейса.

## Ограничение доступа с помощью декораторов и миксинов

Если в проекте используются функции-представления (FBV), проверку доступа можно выполнять вручную:
```
from django.shortcuts import redirect

def task_create(request):
    if not request.user.is_authenticated:
        return redirect('login')
    # Здесь код для создания задачи
```

Но вставлять такую проверку в каждую функцию неудобно и нарушает принцип DRY. В Django есть встроенные инструменты для этого:
- **@login_required** — декоратор для функций,
    
- **LoginRequiredMixin** — миксин для классов-представлений.

Пример использования декоратора:
```
from django.contrib.auth.decorators import login_required
from django.http import HttpResponse

@login_required
def only_for_users(request):
    return HttpResponse("Доступ открыт только авторизованным пользователям")
```

Для классов используется миксин:
```
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import CreateView
from .models import Task
from .forms import TaskForm

class TaskCreateView(LoginRequiredMixin, CreateView):
    model = Task
    form_class = TaskForm
```

Таким образом, доступ к созданию задачи будет только у вошедших пользователей.

## Привязка задач к авторам
Чтобы ограничить редактирование и удаление задач, нужно знать, кто их создал. Для этого в модель задачи добавим связь с пользователем:
```
from django.db import models
from django.contrib.auth import get_user_model

User = get_user_model()

class Task(models.Model):
    title = models.CharField(max_length=200)
    description = models.TextField()
    author = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        verbose_name="Автор"
    )
```

Теперь каждая задача принадлежит конкретному пользователю.

### Скрытие поля `author` в форме
Если оставить настройку `fields = '__all__'` в `ModelForm`, то в HTML-форме появится выбор автора, и любой пользователь сможет создать задачу от чужого имени. Это неправильно.

Поэтому исключим поле `author` из формы:
```
from django import forms
from .models import Task

class TaskForm(forms.ModelForm):
    class Meta:
        model = Task
        exclude = ('author',)
```

### Автоматическое назначение автора

Когда пользователь создаёт задачу, автором должен быть именно тот, кто отправил форму. В классовых представлениях это можно реализовать через переопределение метода `form_valid`:
```
class TaskCreateView(LoginRequiredMixin, CreateView):
    model = Task
    form_class = TaskForm

    def form_valid(self, form):
        form.instance.author = self.request.user
        return super().form_valid(form)
```

В функциях-представлениях это делается так:
```
def create_task(request):
    form = TaskForm(request.POST or None)
    if form.is_valid():
        task = form.save(commit=False)
        task.author = request.user
        task.save()
```

Теперь каждая новая задача будет автоматически связана с текущим пользователем.

## Проверка авторства при редактировании и удалении

Даже после того, как задачи связаны с авторами, другой пользователь может попытаться открыть чужую задачу по прямой ссылке. Нужно запретить это.

### Проверка во view-функции
```
from django.shortcuts import get_object_or_404
from django.core.exceptions import PermissionDenied
from .models import Task

def edit_task(request, pk):
    task = get_object_or_404(Task, pk=pk)
    if task.author != request.user:
        raise PermissionDenied
    # код для редактирования
```

Здесь доступ будет только у владельца задачи, а чужим пользователям вернётся ошибка 403.

### Проверка в CBV через UserPassesTestMixin
Django предлагает специальный миксин для подобных случаев:
```
from django.contrib.auth.mixins import UserPassesTestMixin
from django.views.generic import UpdateView
from .models import Task
from .forms import TaskForm

class TaskUpdateView(UserPassesTestMixin, UpdateView):
    model = Task
    form_class = TaskForm

    def test_func(self):
        task = self.get_object()
        return task.author == self.request.user
```

Если автор не совпадает с пользователем, запрос будет отклонён.

Чтобы не повторять этот код в каждом представлении, можно вынести проверку в собственный миксин:
```
class AuthorRequiredMixin(UserPassesTestMixin):
    def test_func(self):
        return self.get_object().author == self.request.user
```

Теперь его можно добавлять в любые CBV для проверки прав.

## Управление доступом в шаблонах

Если на странице списка задач выводить ссылки «Редактировать» и «Удалить» под каждой задачей, то у пользователей может возникнуть соблазн нажать их, даже если права отсутствуют. Чтобы избежать лишних ошибок, лучше скрывать эти элементы для чужих записей.

В шаблоне можно сравнить автора задачи и текущего пользователя:
```
{% if task.author == user %}
    <a href="{% url 'task_edit' task.id %}">Редактировать</a>
    <a href="{% url 'task_delete' task.id %}">Удалить</a>
{% endif %}
```
Таким образом, кнопки будут видны только владельцу задачи.

---
В веб-приложении для управления задачами пользователю должно быть удобно работать со своим аккаунтом. Нужно предусмотреть полный набор стандартных страниц для авторизации: вход, выход, смена и восстановление пароля. Без этого сервис будет неполным — ведь пользователь может забыть пароль или захотеть его сменить, а также должен иметь возможность безопасно выйти из системы.

Django из коробки предоставляет готовые механизмы для этих сценариев, и нам не придётся писать всю логику с нуля. Во встроенном приложении `django.contrib.auth` есть класс-представления (CBV), которые отвечают за вход, выход и работу с паролем. Кроме того, предусмотрены URL-маршруты и шаблоны для всех этих действий. Всё, что нужно — правильно подключить их к проекту и заменить встроенные HTML-шаблоны на свои, чтобы страницы выглядели в стиле нашего приложения задач.

Подключение делается просто: в главный `urls.py` достаточно добавить строчку с подключением встроенных маршрутов. Например:
```
from django.urls import path, include

urlpatterns = [
    # ... другие маршруты ...
    path('auth/', include('django.contrib.auth.urls')),
]
```

После этого автоматически станут доступны страницы по адресам `auth/login/`, `auth/logout/`, `auth/password_change/`, `auth/password_reset/` и другие. То есть мы сразу получаем полный набор сервисов для работы с учётными записями. Но внешний вид этих страниц по умолчанию будет напоминать административную панель Django, а нам важно, чтобы пользователь видел единый дизайн всего сайта.

Шаблоны, которые использует система аутентификации, хранятся в директории `django/contrib/admin/templates/registration/`. Их изменять напрямую нельзя: при переносе проекта на другой сервер изменения пропадут. Вместо этого нужно в корневой папке проекта создать каталог `templates/registration/` и поместить туда свои HTML-файлы с теми же именами. Django всегда сначала ищет шаблон в директории проекта, и если находит — использует именно его.
Нам придётся подготовить такие шаблоны:
```
templates/
└── registration/
    ├── login.html
    ├── logged_out.html
    ├── password_change_form.html
    ├── password_change_done.html
    ├── password_reset_form.html
    ├── password_reset_done.html
    ├── password_reset_confirm.html
    └── password_reset_complete.html
```

Файл `login.html` в базовой поставке отсутствует — его разработчик обязан создать сам, ведь форма входа обычно у каждого проекта индивидуальная. Для примера сделаем простой вариант:
```
{% extends "base.html" %}

{% block content %}
  <div class="d-flex justify-content-center mt-5">
    <div class="card p-4 shadow-sm" style="max-width: 400px; width: 100%;">
      <h5 class="text-center mb-3">Вход</h5>

      {% if form.errors %}
        <div class="alert alert-danger py-1">
          Неверный логин или пароль
        </div>
      {% endif %}

      <form method="post" action="{% url 'login' %}">
        {% csrf_token %}
        <div class="mb-3">
          {{ form.username.label_tag }}
          {{ form.username }}
        </div>
        <div class="mb-3">
          {{ form.password.label_tag }}
          {{ form.password }}
        </div>
        {% if next %}
          <input type="hidden" name="next" value="{{ next }}">
        {% endif %}
        <button type="submit" class="btn btn-primary w-100">Войти</button>
      </form>

      <div class="text-center mt-3">
        <a href="{% url 'password_reset' %}">Забыли пароль?</a>
      </div>
    </div>
  </div>
{% endblock %}
```

Теперь при переходе на страницу входа пользователь увидит аккуратную форму в стиле проекта. Если он пытался попасть на защищённый раздел, например на список задач, но не был авторизован, Django добавит к адресу параметр `next`, и после успешного входа система вернёт его туда, куда он изначально хотел попасть.

По умолчанию, если параметра `next` нет, пользователь после входа попадает на страницу `/accounts/profile/`, которой у нас нет. Чтобы настроить нужный редирект, достаточно в `settings.py` указать константу:
```
LOGIN_REDIRECT_URL = 'tasks:list'
```

Таким образом, после входа мы будем сразу перекидывать человека на список его задач.
Для выхода из аккаунта используется `LogoutView`. Ему соответствует шаблон `logged_out.html`, который можно сделать предельно простым:
```
{% extends "base.html" %}

{% block content %}
  <h2>Вы вышли из системы</h2>
{% endblock %}
```

При переходе на `auth/logout/` пользователь автоматически разлогинивается, а на экране отображается сообщение.

Чтобы пользоваться системой было удобно, стоит добавить ссылки на вход и выход прямо в меню. Например, в шапке сайта можно вывести имя текущего пользователя и кнопку «Выйти», а для анонимного посетителя — ссылку «Войти». Django передаёт в шаблоны объект `user`, у которого есть полезное свойство `is_authenticated`. Используем его:
```
<nav>
  <ul class="nav">
    <li><a href="{% url 'tasks:list' %}">Мои задачи</a></li>

    {% if user.is_authenticated %}
      <li><span>Пользователь: {{ user.username }}</span></li>
      <li><a href="{% url 'logout' %}">Выйти</a></li>
    {% else %}
      <li><a href="{% url 'login' %}">Войти</a></li>
    {% endif %}
  </ul>
</nav>
```
Теперь интерфейс будет адаптироваться под статус пользователя. Если он вошёл в систему — появится его имя и кнопка выхода, если нет — ссылка на форму логина.

Таким образом, в нашем приложении задач всего в несколько шагов мы получили полноценную систему входа и выхода, с возможностью изменения и восстановления пароля, а также удобной навигацией для разных пользователей. Всё это опирается на встроенные возможности Django, но при этом полностью подстроено под стиль и логику нашего проекта.

---
## Смена пароля

Для авторизованных пользователей предусмотрена страница изменения пароля. Этой страницей управляет класс `PasswordChangeView`.

### Шаблон для PasswordChangeView

Создайте файл `templates/registration/password_change_form.html` со следующим содержимым:
```
{% extends "base.html" %}
{% load django_bootstrap5 %}

{% block content %}
  <div class="card col-4 m-3">
    <div class="card-header">Изменить пароль</div>
    <div class="card-body">
      <form method="post">
        {% csrf_token %}
        {% bootstrap_form form %}
        {% bootstrap_button button_type="submit" content="Сохранить" %}
      </form>
    </div>
  </div>
{% endblock %}
```

- Страница доступна по адресу `/auth/password_change/`.
    
- Доступ разрешён только вошедшим в систему пользователям.
    
- Незарегистрированный посетитель будет перенаправлен на страницу логина.

⚠️ По умолчанию Django перенаправляет на `/accounts/login/`. Чтобы это совпадало с нашей конфигурацией (`/auth/login/`), в `settings.py` нужно прописать:
```
LOGIN_URL = 'login'
```

---
### Шаблон для PasswordChangeDoneView

После успешной смены пароля пользователь увидит сообщение. Для этого используется класс `PasswordChangeDoneView`, который работает с шаблоном `registration/password_change_done.html`:
```
{% extends "base.html" %}

{% block content %}
  <h2>Пароль обновлён</h2>
  <p><a href="{% url 'tasks:task_list' %}">Вернуться к задачам</a></p>
{% endblock %}
```

## Восстановление пароля

Если пользователь забыл пароль, он может перейти по ссылке «Забыли пароль?» на странице входа. Django обрабатывает эту ситуацию с помощью четырёх CBV:

1. **PasswordResetView** – форма для ввода email.
    
2. **PasswordResetDoneView** – уведомление, что письмо отправлено.
    
3. **PasswordResetConfirmView** – ввод нового пароля по ссылке из письма.
    
4. **PasswordResetCompleteView** – сообщение об успешном завершении.
### Шаблон для PasswordResetView

Файл `registration/password_reset_form.html`:
```
{% extends "base.html" %}
{% load django_bootstrap5 %}

{% block content %}
  <div class="card col-4 m-3">
    <div class="card-header">Восстановление пароля</div>
    <div class="card-body">
      <form method="post">
        {% csrf_token %}
        {% bootstrap_form form %}
        {% bootstrap_button button_type="submit" content="Отправить письмо" %}
      </form>
    </div>
  </div>
{% endblock %}
```
Адрес: `/auth/password_reset/`.

После ввода email суперпользователя письмо появится в директории `sent_emails/`. Внутри будет уникальная ссылка с зашифрованным ID и токеном.

---
### Шаблон для PasswordResetDoneView
Файл `registration/password_reset_done.html`:
```
{% extends "base.html" %}

{% block content %}
  <h2>Инструкции отправлены</h2>
  <p>Если введённый адрес есть в базе, вам направлено письмо с инструкциями по восстановлению пароля.</p>
  <p>Проверьте почту и папку «Спам».</p>
  <p><a href="{% url 'tasks:task_list' %}">Вернуться к задачам</a></p>
{% endblock %}
```
Адрес: `/auth/password_reset/done/`.

---
### Шаблон для PasswordResetConfirmView
Файл `registration/password_reset_confirm.html`:
```
{% extends "base.html" %}
{% load django_bootstrap5 %}

{% block content %}
  <div class="card col-4 m-3">
    <div class="card-header">Установить новый пароль</div>
    <div class="card-body">
      <form method="post">
        {% csrf_token %}
        {% bootstrap_form form %}
        {% bootstrap_button button_type="submit" content="Сменить пароль" %}
      </form>
    </div>
  </div>
{% endblock %}
```
Адрес генерируется автоматически: `/auth/reset/<uidb64>/<token>/`.

---
### Шаблон для PasswordResetCompleteView
Файл `registration/password_reset_complete.html`:
```
{% extends "base.html" %}

{% block content %}
  <h2>Пароль успешно изменён</h2>
  <p>Теперь вы можете войти в систему с новым паролем.</p>
  <p><a href="{% url 'login' %}">Перейти ко входу</a></p>
{% endblock %}
```
Адрес: `/auth/reset/done/`.

---
# Настройка страницы регистрации пользователей

На текущем этапе в нашем приложении **task** уже реализованы основные механизмы работы с аккаунтами:
- пользователь может войти в систему и выйти из неё;
    
- если он забыл пароль — есть возможность восстановить доступ по электронной почте;
    
- при необходимости пароль можно сменить прямо в личном кабинете.

Однако остаётся серьёзная проблема: **новый пользователь не может зарегистрироваться самостоятельно**. Сейчас создать аккаунт может только администратор в панели управления или разработчик через консоль. Если мы выложим сервис в открытый доступ, и к нам захотят присоединиться сотни людей, ручная регистрация превратится в мучение.

Поэтому нам нужно реализовать **собственную страницу регистрации**.

---
## Почему в Django нет готового решения

Для логина, логаута, смены и восстановления пароля в Django есть встроенные вьюхи и шаблоны. А вот для регистрации ничего такого не предусмотрено. Разработчики фреймворка считают, что у разных проектов слишком разные требования: где-то при регистрации нужно подтверждение по e-mail, где-то — сразу ввод дополнительных данных (например, аватар или биография). Поэтому универсальной формы регистрации в `django.contrib.auth` нет.

Это значит, что мы должны **собрать всё самостоятельно**: маршрут, вьюху и шаблон.

---
## Использование готовой формы UserCreationForm

В админке Django уже есть форма для создания пользователей. Её логика вынесена в отдельный класс `UserCreationForm` из модуля `django.contrib.auth.forms`.

Этот класс:

- наследуется от `ModelForm`,
    
- связан с моделью пользователя,
    
- умеет проверять данные и валидировать пароли.
    

Мы можем взять его как основу для нашей страницы регистрации.

---
## Настройка маршрута и вьюхи

Создавать новый класс в `views.py` не обязательно. Мы можем прямо в `urls.py` подключить дженерик `CreateView`, передав ему все нужные параметры:
- `template_name` — путь до HTML-шаблона,
    
- `form_class` — форма, которая будет использоваться (в нашем случае `UserCreationForm`),
    
- `success_url` — куда перенаправлять пользователя после успешной регистрации.

Пример:
```
from django.contrib.auth.forms import UserCreationForm
from django.views.generic.edit import CreateView
from django.urls import path, reverse_lazy

urlpatterns = [
    path(
        'auth/registration/',
        CreateView.as_view(
            template_name='registration/registration_form.html',
            form_class=UserCreationForm,
            success_url=reverse_lazy('pages:homepage'),
        ),
        name='registration',
    ),
]
```
После этого по адресу `/auth/registration/` будет доступна форма регистрации.

---
## Шаблон страницы регистрации

Форма очень похожа на уже существующие шаблоны (`password_change_form.html`, `password_reset_form.html`). Разместим её в папке `registration/`.
```
{% extends "base.html" %}
{% load django_bootstrap5 %}

{% block content %}
  <div class="card col-4 m-3">
    <div class="card-header">
      Регистрация нового пользователя
    </div>
    <div class="card-body">
      <form method="post">
        {% csrf_token %}
        {% bootstrap_form form %}
        {% bootstrap_button button_type="submit" content="Создать аккаунт" %}
      </form>
    </div>
  </div>
{% endblock %}
```
Теперь при переходе на `/auth/registration/` можно зарегистрировать нового пользователя.

---
## Если используется кастомная модель пользователя

`UserCreationForm` работает только с базовой моделью User. Если в проекте определена собственная модель (например, с дополнительным полем `bio`), нужно создать свою форму:
```
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth import get_user_model

User = get_user_model()

class CustomUserCreationForm(UserCreationForm):
    class Meta(UserCreationForm.Meta):
        model = User
        fields = ('username', 'bio')
```
Здесь мы унаследовались от `UserCreationForm.Meta`, чтобы не потерять настройки родительского класса, и добавили новое поле.

Чтобы не разбрасывать код по разным частям проекта, обычно создают отдельное приложение `users`, где хранятся:

- `models.py` — кастомная модель пользователя,
    
- `forms.py` — собственные формы,
    
- `views.py` — представления,
    
- `urls.py` — маршруты, связанные с аккаунтами.
