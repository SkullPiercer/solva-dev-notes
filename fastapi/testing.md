## Виды тестирования

### 1. **Юнит-тесты (unit testing)**

- **Что это:** проверка маленьких частей программы (функций, классов, методов) в изоляции от внешнего мира.
    
- **Цель:** убедиться, что бизнес-логика работает правильно сама по себе.
    
- **Как делается:**
    
    - тестируем одну функцию/метод,
        
    - все внешние зависимости (БД, API, файлы) заменяем моками/фейками.
        
- **Где применяют:** при проверке бизнес-логики, утилит, хелперов.

В FastAPI:

- тестировать сервисные функции (например, функцию валидации пароля или расчёта скидки),
    
- тестировать CRUD-классы без поднятия сервера,
    
- тестировать зависимости, которые можно замокать.

---

### 2. **Мок-тесты (mock testing)**

- **Что это:** разновидность юнит-тестов, где настоящие зависимости заменяются заглушками (mock, stub, fake).
    
- **Цель:** проверить не результат работы внешней системы, а **факт и параметры взаимодействия с ней**.
    
- **Где применяют:**
    
    - когда важно проверить, что метод вызвался (`send_email`),
        
    - что он вызвался с правильными аргументами (`send("user@example.com")`).

В FastAPI:

- можно замокать `Session` от SQLAlchemy и проверить, что вызвался `db.commit()`,
    
- можно замокать `httpx` и проверить, что при вызове ручки идёт запрос к внешнему API.

---

### 3. **Интеграционные тесты (integration testing)**

- **Что это:** проверка работы нескольких частей системы вместе.
    
- **Цель:** убедиться, что взаимодействие между модулями правильно настроено.
    
- **Как делается:**
    
    - запускаем FastAPI-приложение через `TestClient`,
        
    - подключаем реальную тестовую БД (SQLite, PostgreSQL),
        
    - проверяем «от запроса до ответа».
        
- **Где применяют:** для проверки API-ручек, запросов к БД, сериализации/валидации.

В FastAPI:

- это стандартные тесты ручек через `TestClient` или `httpx.AsyncClient`,
    
- обычно подключается отдельная тестовая БД (in-memory или временная PostgreSQL),
    
- пример: создать заметку → проверить, что она сохранилась в БД → получить её обратно через API.

---

### 4. **E2E-тесты (end-to-end, сквозные)**

- **Что это:** тесты, которые повторяют поведение пользователя максимально близко к боевому окружению.
    
- **Цель:** проверить систему «от и до»: от UI или запроса до базы и обратно.
    
- **Как делается:**
    
    - поднимаем весь стек через Docker Compose (FastAPI, PostgreSQL, Redis, Celery),
        
    - отправляем HTTP-запросы реальным клиентом (например, `httpx` или `requests`),
        
    - иногда эмулируем поведение браузера (Playwright, Selenium).
        
- **Где применяют:** проверка «боевого сценария»: регистрация пользователя, логин, покупка, создание задачи и т.д.

В FastAPI:

- разворачивается полноценный сервис (часто в CI/CD пайплайне),
    
- запросы идут не через `TestClient`, а через реальный HTTP к запущенному серверу,
    
- такие тесты медленнее, но дают уверенность, что в бою всё работает.

---

### 5. **Функциональные тесты**

- **Что это:** проверяют отдельную функцию системы с точки зрения требований, а не внутренней реализации.
    
- **Отличие от unit:** фокус на «что делает», а не на «как устроено».
    
- **Пример:** проверить, что ручка `/register` создаёт пользователя и возвращает `201`.

В FastAPI:

- это может быть как интеграционный тест (через `TestClient`),
    
- так и E2E (через реальный сервер).  
    Главное — проверяется соответствие бизнес-требованию.

---
### 6. **Регрессионные тесты**

- **Что это:** тесты, которые проверяют, что старый функционал не сломался после изменений.
    
- **Обычно:** это просто набор юнит- и интеграционных тестов, которые гоняются в CI/CD.

В FastAPI:

- обычные тесты, которые гоняются после каждого пуша в GitHub Actions.

---

### 7. **Нагрузочные (performance, stress) тесты**

- **Что это:** проверка, выдерживает ли приложение много запросов, где узкие места.
    
- **Инструменты:** Locust, k6, Apache JMeter.
    
- **Где применяют:** для проверки API под нагрузкой.

В FastAPI:

- можно поднять сервис и нагнать на `/notes/` 1000 RPS, посмотреть latency, ошибки 500.

---

## Отличия в контексте FastAPI

- **Юнит-тесты** → тестируем внутреннюю логику без FastAPI (функции, сервисы).
    
- **Мок-тесты** → подменяем зависимости (например, `get_db`) на заглушки, проверяем вызовы.
    
- **Интеграционные** → `TestClient` + тестовая БД → основной способ тестирования ручек.
    
- **E2E** → запускаем реальный сервер + реальную БД в Docker, тестируем полные сценарии.
    
- **Нагрузочные** → отдельно, с внешними тулзами, проверяем производительность.

---
# Что такое пирамида тестирования

Это модель, которая показывает **соотношение** разных видов тестов в проекте.  
Идея в том, что чем ближе тест к коду (юнит), тем он:

- быстрее запускается,
    
- проще писать,
    
- надёжнее в поддержке.

А чем выше (интеграционные/ендпойнт/ручные) — тем дороже и медленнее.

---
### 1. Юнит-тесты (основание пирамиды)

- **Что тестируют:** отдельные функции, классы, модули.
    
- **Инструменты:** `pytest`, `unittest.mock`, `pytest-mock`.
    
- **Применение в FastAPI:**
    
    - тест бизнес-логики без запуска сервера,
        
    - тест валидации Pydantic-моделей,
        
    - тест CRUD-функций в отрыве от БД (замокать).
        
- **Особенности:** выполняются миллисекунды, их должно быть больше всего.

Пример: проверить, что функция `create_note_in_db` создаёт объект и возвращает ID.

---

### 2. Интеграционные тесты (середина)

- **Что тестируют:** взаимодействие нескольких модулей системы.
    
- **Применение в FastAPI:**
    
    - тестирование API с временной БД,
        
    - проверка работы эндпоинтов через `TestClient`,
        
    - проверка, что зависимость `get_db` действительно отрабатывает.
        
- **Особенности:** медленнее юнитов, но нужны, чтобы убедиться, что всё собрано правильно.

Пример: запрос `POST /notes/` → запись реально появляется в тестовой БД.

---

### 3. Системные тесты (выше интеграционных)

- **Что тестируют:** всю систему целиком, как единое приложение.
    
- **Применение в FastAPI:**
    
    - поднять приложение (например, через `docker-compose` с PostgreSQL),
        
    - прогнать тесты через HTTP (например, `httpx` или `requests`).
        
- **Особенности:** самые близкие к бою, но ещё без реального пользователя.

Пример: тест, что после регистрации юзера он может авторизоваться и получить токен.

---

### 4. End-to-End (E2E) тесты (вершина пирамиды)

- **Что тестируют:** сценарий использования глазами пользователя.
    
- **Применение в FastAPI:**
    
    - UI/Frontend + API вместе,
        
    - тестируется «клик по кнопке → запись реально ушла в БД».
        
- **Инструменты:** Playwright, Selenium.
    
- **Особенности:** самые дорогие по времени и поддержке, их обычно мало.

Пример: тестировать через браузер, что после логина можно создать заметку и увидеть её в списке.

---

### Отличия в FastAPI

- Юнит-тесты можно писать **без FastAPI** вообще, тестируя функции напрямую.
    
- Интеграционные требуют `TestClient` + фикстуры БД.
    
- Системные — уже нужно окружение (Postgres, Redis и т.д.).
    
- E2E — нужен UI или внешний клиент.

---

### Итоговая пирамида для FastAPI:

- **Основание (70%) — юнит-тесты** (быстро, много, покрывают бизнес-логику).
    
- **Середина (20%) — интеграционные** (эндпоинты, зависимость `get_db`, временная БД).
    
- **Выше (9%) — системные** (с Docker, внешними сервисами).
    
- **Вершина (1%) — E2E** (реальные сценарии пользователя, медленно, дорого).

---

# Разберем на простом примере создание разных тестов

Структура проекта очень простая, всего два файла но нам для примера хватит и их:
- main.py
- test_main.py
На заметку!
Правильная структура тестов на проде сильно влияет на то, как удобно поддерживать проект.  
Как обычно делят тесты в **FastAPI / Python проектах** и как их называют.
```
tests/
│
├── conftest.py          # глобальные фикстуры (pytest)
├── factories.py         # генераторы тестовых данных (опционально)
│
├── test_routes/         # тесты маршрутов (API)
│   ├── test_notes.py    # тесты CRUD для заметок
│   ├── test_auth.py     # тесты авторизации
│   └── ...
│
├── test_services/       # тесты бизнес-логики
│   ├── test_notes.py    # тесты функций работы с заметками
│   └── ...
│
├── test_models/         # тесты моделей и ORM
│   ├── test_note_model.py
│   └── ...
│
├── test_integration/    # интеграционные тесты (несколько компонентов вместе)
│   └── test_full_flow.py
│
└── test_e2e/            # end-to-end тесты (имитация работы клиента)
    └── test_api_flow.py
```
### Что в каждом типе тестов

1. **test_routes/**
    
    - Тестируют конкретные API ручки (`/notes/`, `/auth/login`).
        
    - Проверяют HTTP-коды, тело ответа, валидацию входных данных.
        
    - Обычно используют `TestClient` или `httpx.AsyncClient`.
        
2. **test_services/**
    
    - Тестируют бизнес-логику, вынесенную в отдельные сервисы/функции.
        
    - Тут проверяют именно "чистый" Python-код (без FastAPI), например:
```
def test_create_note_logic(note_service):
    note = note_service.create("text")
    assert note.text == "text"
```
Легко запускать без поднятия API.

3.  **test_models/**
    
    - Тесты моделей и ORM.
        
    - Проверяют работу сессий, транзакций, каскадное удаление, индексы.
        
    - Обычно используют временную SQLite/Postgres БД.
        
4. **test_integration/**
    
    - Проверяют работу нескольких частей вместе (например: запрос → сервис → БД).
        
    - Тут можно имитировать сценарии вроде: "пользователь создаёт заметку и сразу читает её".
        
5. **test_e2e/**
    
    - End-to-End тесты, имитируют реального клиента.
        
    - Обычно поднимают всё приложение (например, через Docker) и гоняют реальные HTTP-запросы.
        
    - Используются редко и в малом числе (долгие, дорогие).
        
6.  **conftest.py**
    
    - Здесь лежат фикстуры (например, `db_session`, `client`, `test_user`).
        
    - Благодаря pytest, они доступны во всех тестах без импорта.
        
7. **factories.py / fixtures.py** (опционально)
    
    - Утилиты для быстрого создания тестовых данных (например, `NoteFactory`, `UserFactory`).
        
    - В Django часто используют `factory_boy`, в FastAPI тоже применяют.

---
### Названия файлов и тестов
- Всегда **test_*.py** — чтобы pytest находил их автоматически.
    
- Внутри — функции начинаются с `test_`.
    
- Обычно:
    
    - `test_routes/test_notes.py` → `test_create_note`, `test_read_note`
        
    - `test_services/test_notes.py` → `test_note_service_create`
        
    - `test_models/test_note_model.py` → `test_note_str_repr`

---
# main.py
```
# main.py
from fastapi import FastAPI, Depends
from sqlalchemy import Column, Integer, String, create_engine
from sqlalchemy.orm import sessionmaker, declarative_base, Session

# URL подключения к базе данных.
# В данном примере используется SQLite для простоты.
# В реальном проекте здесь будет PostgreSQL или другая СУБД.
DATABASE_URL = "sqlite:///./app.db"

# Создание "движка" базы данных, через который SQLAlchemy общается с БД.
# Параметр connect_args={"check_same_thread": False} нужен только для SQLite,
# чтобы разрешить использование соединения в разных потоках (FastAPI работает асинхронно).
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})

# Создаём фабрику сессий.
# sessionmaker возвращает класс, который будет создавать объекты Session.
# autocommit=False и autoflush=False — управляем транзакциями вручную.
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Базовый класс для всех моделей.
# От него будут наследоваться таблицы.
Base = declarative_base()


# Модель таблицы "notes".
# Каждое поле = колонка в базе данных.
class Note(Base):
    __tablename__ = "notes"          # имя таблицы в базе
    id = Column(Integer, primary_key=True, index=True)  # первичный ключ
    text = Column(String, index=True)                   # текст заметки


# Зависимость для получения сессии БД.
# Каждый запрос будет получать свою сессию,
# а после завершения запроса соединение корректно закроется.
def get_db():
    db = SessionLocal()
    try:
        yield db  # отдаём сессию "наружу"
    finally:
        db.close()  # закрываем после использования


# Создаём экземпляр приложения FastAPI.
app = FastAPI()


# POST-эндпоинт для создания новой заметки.
# text — это параметр, который мы передаём в запросе.
# db: Session = Depends(get_db) — автоматическая подстановка зависимости,
# FastAPI сам вызовет get_db и передаст сессию в параметр.
@app.post("/notes/")
def create_note(text: str, db: Session = Depends(get_db)):
    note = Note(text=text)  # создаём объект заметки
    db.add(note)            # добавляем в сессию
    db.commit()             # сохраняем изменения в базе
    db.refresh(note)        # обновляем объект, чтобы получить сгенерированный id
    return note             # возвращаем заметку клиенту (будет преобразована в JSON)


# GET-эндпоинт для получения заметки по ID.
# Мы ищем первую запись с указанным note_id в таблице notes.
@app.get("/notes/{note_id}")
def read_note(note_id: int, db: Session = Depends(get_db)):
    return db.query(Note).filter(Note.id == note_id).first()
```

---
# test_main
```
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from main import app, Base, get_db, Note
from fastapi.testclient import TestClient

# --- Настройка базы данных для тестов ---
# Здесь мы создаём отдельную SQLite-базу для тестов (test.db).
# В отличие от "in-memory" БД (sqlite:///:memory:), файл test.db
# будет стабильнее — он сохранится на диске и доступен в рамках всех тестов.
SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"
engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})

# sessionmaker — это "фабрика" для создания новых сессий работы с БД
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)


# --- FIXTURE 1: Подготовка базы ---
@pytest.fixture(scope="session", autouse=True)
def prepare_database():
    """
    Фикстура, которая запускается один раз на всю сессию тестов.
    1. Создаёт все таблицы в базе (Base.metadata.create_all).
    2. Отдаёт управление тестам через yield.
    3. После завершения всех тестов — удаляет таблицы (drop_all).
    """
    Base.metadata.create_all(bind=engine)
    yield
    Base.metadata.drop_all(bind=engine)


# --- FIXTURE 2: Сессия для теста ---
@pytest.fixture()
def db_session():
    """
    Для каждого теста создаём новую "чистую" транзакцию.
    - connection = engine.connect() → открываем подключение к БД
    - transaction.begin() → запускаем транзакцию
    - TestingSessionLocal(bind=connection) → создаём сессию, привязанную к этому соединению
    После теста:
    - session.close() → закрываем сессию
    - transaction.rollback() → откатываем изменения (БД остаётся чистой для следующего теста)
    - connection.close() → закрываем подключение
    """
    connection = engine.connect()
    transaction = connection.begin()
    session = TestingSessionLocal(bind=connection)

    yield session  # отдаём объект session тесту

    session.close()
    transaction.rollback()
    connection.close()


# --- FIXTURE 3: HTTP-клиент для тестов ---
@pytest.fixture()
def client(db_session):
    """
    Создаём TestClient для работы с FastAPI-приложением.
    Так как у приложения есть зависимость get_db (которая обычно даёт рабочую БД),
    мы подменяем её тестовой сессией (override_get_db).
    После теста очищаем dependency_overrides, чтобы не повлияло на другие тесты.
    """

    def override_get_db():
        try:
            yield db_session
        finally:
            pass  # тут бы мог быть session.close(), но db_session уже управляется выше

    app.dependency_overrides[get_db] = override_get_db
    yield TestClient(app)  # отдаём клиент для теста
    app.dependency_overrides.clear()


# --- ТЕСТЫ ---
def test_create_note(client, db_session):
    """
    Проверяем создание заметки через POST-запрос.
    1. Делаем POST /notes/ с текстом "Test note".
    2. Проверяем что ответ 200 и текст совпадает.
    3. Дополнительно проверяем, что запись реально появилась в БД.
    """
    response = client.post("/notes/", params={"text": "Test note"})
    assert response.status_code == 200
    data = response.json()
    assert data["text"] == "Test note"

    note_in_db = db_session.query(Note).filter(Note.id == data["id"]).first()
    assert note_in_db is not None
    assert note_in_db.text == "Test note"


def test_read_note(client, db_session):
    """
    Проверяем чтение заметки.
    1. Добавляем заметку напрямую в БД (без API).
    2. Делаем GET-запрос /notes/{id}.
    3. Проверяем, что пришёл правильный текст.
    """
    note = Note(text="Hello DB")
    db_session.add(note)
    db_session.commit()
    db_session.refresh(note)

    response = client.get(f"/notes/{note.id}")
    assert response.status_code == 200
    data = response.json()
    assert data["text"] == "Hello DB"


def test_create_multiple_notes(client, db_session):
    """
    Проверяем массовое создание заметок.
    1. Создаём 3 заметки через API.
    2. Проверяем, что в БД оказалось ровно 3 записи и тексты совпадают.
    """
    texts = ["note1", "note2", "note3"]
    ids = []

    for text in texts:
        response = client.post("/notes/", params={"text": text})
        assert response.status_code == 200
        ids.append(response.json()["id"])

    notes = db_session.query(Note).all()
    assert len(notes) == 3
    assert {n.text for n in notes} == set(texts)


def test_read_non_existing_note(client):
    """
    Проверяем поведение при чтении несуществующей заметки.
    В текущей реализации API:
    - FastAPI возвращает None, а не 404 (это особенность текущего кода).
    """
    response = client.get("/notes/9999")
    assert response.status_code == 200
    assert response.json() is None


def test_create_and_read_back(client):
    """
    Roundtrip-тест:
    1. Создаём заметку через API.
    2. Сразу читаем её обратно.
    3. Проверяем, что данные совпадают.
    """
    response = client.post("/notes/", params={"text": "Roundtrip test"})
    assert response.status_code == 200
    note_id = response.json()["id"]

    response = client.get(f"/notes/{note_id}")
    assert response.status_code == 200
    data = response.json()
    assert data["text"] == "Roundtrip test"
```

---

Тестирование FastAPI-приложений строится на сочетании разных уровней: юнит-тесты проверяют отдельные функции и классы, интеграционные тесты — взаимодействие API с базой данных и зависимостями, а E2E-тесты эмулируют работу реального пользователя. Для организации тестов в боевых проектах используют **pytest** и его фикстуры, которые через `conftest.py` позволяют удобно готовить и очищать окружение (например, базу и клиента), а также делают тесты независимыми и воспроизводимыми. В итоге мы получаем надёжный процесс проверки кода: быстрые юнит-тесты составляют основу, интеграционные покрывают критические сценарии, а редкие E2E гарантируют, что приложение работает как ожидается.
