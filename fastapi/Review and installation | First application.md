**FastAPI** — это современный фреймворк на Python, предназначенный для создания API и отличающийся высокой скоростью работы. Он строится на механизмах аннотации типов Python, что делает его удобным и надёжным инструментом.
### Основные преимущества FastAPI:

- **Высокая производительность.** Работает на уровне Node.js и Go, так как основан на связке Starlette (асинхронный веб-сервер) и Pydantic (валидация данных). Это один из самых быстрых инструментов в экосистеме Python.

- **Ускорение разработки.** Проекты создаются в разы быстрее: время на написание кода сокращается примерно в 2–3 раза.

- **Снижение количества ошибок.** За счёт строгих типов и встроенной валидации количество багов, связанных с человеческим фактором, уменьшается почти наполовину.

- **Удобство и наглядность.** Отличная интеграция с редакторами кода: подсказки и автодополнение работают «из коробки», что облегчает отладку.

- **Простота освоения.** Фреймворк создан с прицелом на лёгкость понимания — даже новичку потребуется меньше времени на изучение документации.

- **Минимизация шаблонного кода.** Объявление параметров выполняет сразу несколько задач, что снижает дублирование и уменьшает вероятность ошибок.

- **Надёжность и готовность к использованию.** Код приложения сразу сопровождается автоматически сгенерированной интерактивной документацией.

- **Ориентация на стандарты.** FastAPI полностью совместим с общепринятыми API-спецификациями — OpenAPI (бывший Swagger) и JSON Schema.

---
### Подготовка окружения

Создадим каталог для нашего будущего проекта, пусть он называется `library_project/`. Внутри создадим виртуальное окружение и активируем его. После этого установим сам фреймворк FastAPI:
```
pip install fastapi
```

При установке подтянутся нужные зависимости — `Starlette`, `Pydantic` и несколько вспомогательных библиотек.

> В документации можно встретить вариант с установкой `fastapi[all]`, но он тянет множество дополнительных пакетов. Для учебного проекта с каталогом книг они не нужны, поэтому ограничимся минимальным набором.

---
### ASGI-сервер: движок под капотом

FastAPI не включает встроенный сервер, поэтому нам нужен отдельный ASGI-сервер. На практике чаще всего используют **Uvicorn**:
```
pip install "uvicorn[standard]"
```

Опция `[standard]` ставит дополнительно удобные инструменты, например:

- `watchgod` — автоматический перезапуск сервера при изменении кода;
    
- `python-dotenv` — работа с `.env` файлами для конфигурации.

Раньше вы могли встречать `Gunicorn` (WSGI-сервер), но он не поддерживает асинхронные приложения, поэтому для FastAPI выбираем Uvicorn.

---
### Первое приложение

В отличие от Django, FastAPI не предлагает готовый каркас проекта. Структуру вы задаёте сами.  
Создадим файл `main.py` в папке проекта:
```
library_project/
    ├── main.py
    └── venv/
```

Напишем минимальный код:
```
# main.py
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def home():
    return {"message": "Добро пожаловать в библиотеку!"}
```

Запуск:
```
uvicorn main:app
```

Если бы файл назывался `catalog.py`, а объект приложения — `library_app`, то команда выглядела бы так:
```
uvicorn catalog:library_app
```

### Что делает FastAPI автоматически

Перейдите в браузере по адресу [http://127.0.0.1:8000](http://127.0.0.1:8000).  
Фреймворк сразу преобразует Python-объекты (например, словарь) в JSON и отдает их клиенту. Даже если вернуть `datetime`, он аккуратно сериализует дату в нужный формат.

---
### Автодокументация

FastAPI встроенно поддерживает **OpenAPI** и генерирует два варианта документации:

- Swagger UI: [http://127.0.0.1:8000/docs](http://127.0.0.1:8000/docs)
    
- ReDoc: [http://127.0.0.1:8000/redoc](http://127.0.0.1:8000/redoc)

В Swagger можно сразу выполнять запросы к API, что удобно при разработке. ReDoc больше подходит для чтения спецификации.

Хотите отключить оба интерфейса? Легко:
```
app = FastAPI(docs_url=None, redoc_url=None)
```

После перезапуска сервера страница документации станет недоступной.

---
### Автоматический перезапуск

Чтобы не вводить `Ctrl+C` при каждой правке, можно запускать сервер с опцией:
```
uvicorn main:app --reload
```

Теперь приложение будет перезапускаться само при изменениях.

---
### Запуск из кода

Иногда сервер запускают прямо из Python-файла:
```
# main.py
import uvicorn
from fastapi import FastAPI

app = FastAPI()

@app.get("/books")
def list_books():
    return [{"title": "Мастер и Маргарита"}, {"title": "Преступление и наказание"}]

if __name__ == "__main__":
    uvicorn.run("main:app", reload=True)
```

Но чаще разработчики всё же используют запуск через терминал.

---
# Работа с GET-запросами и параметрами в FastAPI

До этого момента наше приложение библиотеки умело только возвращать приветственное сообщение. Давайте сделаем его полезнее: научим API здороваться с читателями по имени, а заодно посмотрим, как в FastAPI описываются маршруты (эндпоинты).

---
## Что такое эндпоинт?

В FastAPI маршрут создаётся при помощи декораторов (`@app.get`, `@app.post` и т. д.).  
Каждый такой маршрут — это «точка входа» в API. В разговорной речи программисты часто называют их **ручками**: _"подёргай ручку /books и посмотри, что вернётся"_.

---
## Первый GET-метод

Вспомним минимальный пример:
```
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def index():
    return {"message": "Добро пожаловать в библиотеку!"}
```

Здесь используется `@app.get("/")`, что означает: функция `index` обрабатывает **GET-запросы** к корневому адресу API.

Помимо `GET`, FastAPI поддерживает и другие HTTP-методы:

- `post()` — создание новой сущности (например, добавить книгу);
    
- `put()` — полная замена объекта;
    
- `patch()` — частичное обновление;
    
- `delete()` — удаление.

Есть и менее популярные методы (`options`, `head`, `trace`), но на практике они встречаются редко.

---
## Параметры пути (path parameters)

Сделаем так, чтобы наш сервис приветствовал читателя по имени. Пусть при обращении по адресу:

- `http://127.0.0.1:8000/Alice`
    
- `http://127.0.0.1:8000/Bob`

мы получали персональное сообщение: `{"message": "Привет, Alice"}`.

Реализуем:
```
from fastapi import FastAPI

app = FastAPI()

@app.get("/{reader_name}")
def greet_reader(reader_name: str):
    return {"message": f"Привет, {reader_name}"}
```

В фигурных скобках (`/{reader_name}`) указывается параметр пути. FastAPI извлекает его из URL и передаёт в функцию.

---
## Специфичные маршруты

Если добавить отдельный путь, например `/librarian`, он будет перехватывать только этот адрес:
```
@app.get("/librarian")
def greet_librarian():
    return {"message": "Здравствуйте, библиотекарь!"}
```

Теперь `/librarian` обработается именно этим эндпоинтом, а все остальные — шаблоном `/{reader_name}`.

⚠️ Важно: порядок функций имеет значение. Если поставить `/{reader_name}` выше, то `/librarian` попадёт под этот шаблон, и второй маршрут никогда не вызовется.

---
## Аннотации типов

Пусть мы хотим, чтобы имя в ответе всегда начиналось с заглавной буквы. В Python для этого есть метод `.capitalize()`. Чтобы IDE подсказывала методы строки, добавим аннотацию типа:
```
@app.get("/{reader_name}")
def greet_reader(reader_name: str) -> dict[str, str]:
    return {"message": f"Привет, {reader_name.capitalize()}"}
```

Теперь IDE понимает, что `reader_name` — строка, и предлагает методы для строк.

---
## Query-параметры

В URL можно передавать дополнительные параметры после `?`. Например:
```
http://127.0.0.1:8000/Alice?book=WarAndPeace&year=1869
```

Здесь мы передаём название книги и год издания. Добавим их в функцию:
```
from typing import Optional

@app.get("/{reader_name}")
def greet_reader(
    reader_name: str,
    book: str,
    year: Optional[int] = None
) -> dict[str, str]:
    result = f"{reader_name.capitalize()} читает книгу «{book}»"
    if year is not None:
        result += f" ({year} год)"
    return {"message": result}
```

Теперь:
- `reader_name` берётся из пути (`/{reader_name}`),
    
- `book` и `year` — из query-параметров (`?book=...&year=...`).

---
## Логический параметр

Добавим булевый флаг `is_librarian`. Если он равен `true`, то в ответе появится уточнение:
```
@app.get("/{reader_name}")
def greet_reader(
    reader_name: str,
    book: str,
    year: Optional[int] = None,
    is_librarian: bool = False
) -> dict[str, str]:
    result = f"{reader_name.title()} читает книгу «{book}»"
    if year:
        result += f" ({year})"
    if is_librarian:
        result += " [сотрудник библиотеки]"
    return {"message": result}
```

FastAPI сам умеет приводить значения `true/false`, `yes/no`, `1/0` и похожие строки к булевому типу.

---
# Перечисления (Enum) в FastAPI

Часто в API нужно ограничить набор допустимых значений. Например, если пользователь заполняет анкету, то поле «уровень языка» может принимать только фиксированные варианты: Beginner, Intermediate или Advanced.

Если просто использовать строку, клиент может отправить что угодно: `"lvl=pro"`, `"lvl=n00b"`. Чтобы этого избежать, применим **перечисления (Enum)**.

---
## Enum в Python: коротко
Перечисление связывает **имя** и **значение**.
```
from enum import Enum

class TrafficLight(Enum):
    RED = 1
    YELLOW = 2
    GREEN = 3
```

Использование:
```
TrafficLight.RED.value   # 1
TrafficLight(2).name     # 'YELLOW'
```

---
## Строковые и числовые перечисления

В FastAPI path- и query-параметры могут быть только строковыми или числовыми перечислениями.

### Пример со строками
```
class LanguageLevel(str, Enum):
    BEGINNER = "Начальный"
    INTERMEDIATE = "Средний"
    ADVANCED = "Продвинутый"
```

Теперь мы можем обращаться к строковым методам сразу:
```
print(LanguageLevel.BEGINNER.upper())  # НАЧАЛЬНЫЙ
```

Пример с числами
```
from enum import IntEnum

class PizzaSize(IntEnum):
    SMALL = 25
    MEDIUM = 30
    LARGE = 35
```

---
## Подключаем к FastAPI
Добавим параметр `language_level` в эндпоинт:
```
from fastapi import FastAPI
from typing import Optional

app = FastAPI()

@app.get("/profile/{username}")
def show_profile(
    *,
    username: str,
    country: str,
    language_level: Optional[LanguageLevel] = None,
    pizza_size: Optional[PizzaSize] = None,
) -> dict[str, str]:
    text = f"Профиль: {username} из {country}"
    if language_level:
        text += f" · Уровень языка: {language_level.lower()}"
    if pizza_size:
        text += f" · Любимая пицца: {pizza_size.value} см"
    return {"info": text}
```

## Проверяем

1. Запускаем проект и открываем Swagger (`http://127.0.0.1:8000/docs`).
    
2. В выпадающем списке для `language_level` доступны только три варианта.
    
3. Для `pizza_size` — строго три числа: 25, 30, 35.
    
4. Любое другое значение приведёт к ошибке.

