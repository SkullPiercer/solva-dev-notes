**Индексы в SQL (PostgreSQL)**

При добавлении новой строки в таблицу PostgreSQL не размещает её в каком-либо логическом порядке. То есть, если вы вставляете запись в таблицу `Users`, СУБД не сортирует данные по `id`, `last_name` или другим полям. Вместо этого запись помещается в первое подходящее свободное место на диске — PostgreSQL ведёт специальную структуру для отслеживания таких свободных областей.

В результате при выполнении запроса вроде:
```
SELECT email FROM Users WHERE email LIKE 'l%';
```
PostgreSQL будет вынужден просканировать всю таблицу построчно, чтобы найти все подходящие значения. Такой полный перебор (sequential scan) допустим на малых объёмах данных, но становится неэффективным при росте таблицы.

Именно здесь помогают **индексы** — они позволяют СУБД находить данные гораздо быстрее, особенно при фильтрации по определённым столбцам. Ниже мы сравним, как поведение запроса изменится при наличии индекса на поле `email`.

### Как работают индексы в PostgreSQL

Индексы в базе данных — это как предметный указатель в книге: они позволяют находить нужную информацию без необходимости читать весь том от начала до конца. В отличие от обычных таблиц, строки в индексах отсортированы определённым образом — по значениям одного или нескольких столбцов. При этом сами индексы не хранят все данные, а лишь необходимые для поиска поля и информацию о том, где именно находится соответствующая строка в таблице.

Таким образом, индекс — это вспомогательная структура, ускоряющая поиск, фильтрацию и сортировку данных, избавляя СУБД от необходимости перебирать каждую строку вручную.

### Создание индекса

Допустим, у нас есть таблица `Users`, и мы часто выполняем запросы по email. Чтобы ускорить такие выборки, можно создать индекс:
```
CREATE INDEX idx_email ON Users (email);
```

Теперь PostgreSQL может использовать этот индекс при обработке запросов, если это будет быстрее, чем полное сканирование таблицы. Если в таблице несколько индексов — PostgreSQL сам решит, какой использовать, основываясь на статистике и оценке стоимости запроса.

Посмотреть текущие индексы можно так:
```
SELECT * FROM pg_indexes WHERE tablename = 'users';
```

### Уникальные индексы

Некоторые поля, например `email`, должны быть уникальными. Для этого создаётся **уникальный индекс**, который не только ускоряет запросы, но и не даёт вставить повторяющиеся значения:
```
CREATE UNIQUE INDEX idx_email ON Users (email);
```

Если попытаться добавить строку с уже существующим email — PostgreSQL выдаст ошибку.

Важно: уникальность для `PRIMARY KEY` обеспечивается автоматически. Но можно создавать и другие уникальные индексы, если нужно исключить дублирование по другим полям.

### Многостолбцовые индексы

Если запросы используют несколько столбцов, например `last_name` и `first_name`, можно создать составной индекс:
```
CREATE INDEX idx_full_name ON Student (last_name, first_name);
```

Он особенно полезен, если WHERE-условие фильтрует сразу по фамилии и имени. Но если фильтруется только по `first_name`, такой индекс не поможет — важно учитывать **порядок столбцов**.

### Как PostgreSQL выбирает индекс

Чтобы понять, какие индексы использует PostgreSQL, применяйте команду:
```
EXPLAIN
SELECT id, first_name, last_name
FROM Student
WHERE first_name LIKE 'A%' AND last_name LIKE 'L%';
```
Она покажет, будет ли использоваться индекс, и какой именно. Это позволяет оптимизировать запросы и структуру таблиц.

### Обратная сторона индексов
Логично спросить: если индексы такие полезные — почему бы не добавить их везде? Ответ — **производительность и ресурсы**:

- Каждый индекс — это отдельная структура, которую нужно обновлять при любом изменении данных (INSERT, UPDATE, DELETE).
    
- Чем больше индексов, тем медленнее выполняются изменения данных.
    
- Индексы занимают место на диске.
    
- Поддержка избыточных индексов может негативно сказаться на производительности системы в целом.

Поэтому важно соблюдать баланс: индексируйте только те поля, по которым действительно выполняются частые запросы или фильтрации. Временные индексы можно создать перед выполнением ресурсоёмких отчётов и удалить после.

# Практическое задание:

Создадим таблицу `customers` и заполним её случайными данными
```
-- Убедимся, что таблица существует
DROP TABLE IF EXISTS customers;

CREATE TABLE customers (
    id SERIAL PRIMARY KEY,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL,
    city TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT now()
);

-- Добавим 100 000 случайных записей
INSERT INTO customers (first_name, last_name, email, city, created_at)
SELECT
    INITCAP(SUBSTRING(md5(random()::text), 1, 8)) AS first_name,
    INITCAP(SUBSTRING(md5(random()::text), 1, 10)) AS last_name,
    LOWER(SUBSTRING(md5(random()::text), 1, 6)) || '@example.com' AS email,
    CASE (random() * 5)::int
        WHEN 0 THEN 'Moscow'
        WHEN 1 THEN 'Saint Petersburg'
        WHEN 2 THEN 'Novosibirsk'
        WHEN 3 THEN 'Yekaterinburg'
        WHEN 4 THEN 'Kazan'
        ELSE 'Other'
    END AS city,
    now() - (random() * interval '365 days') AS created_at
FROM generate_series(1, 100000);
```

1. Для этой таблице выполните запрос:
```
EXPLAIN ANALYZE
SELECT * FROM customers
WHERE email LIKE 'alex%';
```
Далее добавьте индекс на поле email и повторите запрос
Сравни время выполнения и план запроса.


2. Создайте уникальный индекс
Попробуйте вставить дубликат email и убедись, что СУБД выдаёт ошибку

3. Создай составной индекс
Теперь выполним запрос
```
EXPLAIN ANALYZE
SELECT * FROM customers
WHERE city = 'Moscow' AND last_name LIKE 'I%';
```
Сравни результат с предыдущим запросом без индекса.
И убедись, что составной индекс **не помогает**, если фильтрация не начинается с первого поля (`city`).


4. Удали ненужные индексы
```
DROP INDEX idx_name;
```