### Транзакции в базе данных

Представьте, что приложения никогда не сбоили, пользователи не закрывали бы программы раньше времени, а серверы баз данных работали бы без перебоев 24/7. В таком идеальном мире нам не пришлось бы задумываться о том, как обеспечить безопасность одновременной работы с одними и теми же данными.

Но реальность далека от идеала: сбои случаются, соединения обрываются, приложения могут завершиться с ошибкой. Именно поэтому в системах управления базами данных предусмотрены **транзакции** — один из ключевых инструментов для обеспечения целостности данных при многопользовательской работе.

**Транзакция** — это набор операций, который воспринимается как единое целое. Либо все действия в составе транзакции выполняются успешно, либо ни одно из них не вступает в силу.

### Блокировки в PostgreSQL

Современные системы управления базами данных, такие как PostgreSQL, позволяют множеству пользователей одновременно читать и изменять данные. Когда доступ идёт только на чтение — это не вызывает особых сложностей. Но как только начинается одновременное изменение данных, СУБД приходится применять дополнительные механизмы для обеспечения согласованности и защиты от конфликтов.

Допустим, вы формируете финансовый отчёт по ежедневной выручке магазина за неделю. И в это же время происходят такие события:
- один клиент совершает покупку,
    
- другой возвращает товар и получает возврат денег,
    
- в магазин поступает новая партия товара.

Все эти действия затрагивают одну и ту же базу данных, и, если бы они происходили без координации, отчёт мог бы получиться некорректным. Как в такой ситуации PostgreSQL решает, какие именно данные включить в ваш отчёт?

Ответ — **система блокировок**, встроенная в механизм транзакций.
### Что такое блокировка?

**Блокировка** — это способ временно ограничить доступ к данным, чтобы гарантировать их корректную обработку, особенно в условиях одновременного доступа. PostgreSQL использует блокировки для защиты данных во время выполнения транзакций. Пока одна транзакция работает с записью, другие не могут её изменить и, в некоторых случаях, даже прочитать — пока не завершится первая.
### Уровни (гранулярность) блокировок в PostgreSQL

PostgreSQL поддерживает несколько уровней блокировки, в зависимости от того, насколько точечно нужно защитить данные:
- **Блокировка таблицы**  
    Применяется, когда нужно запретить изменения (или даже чтение) всей таблицы. Используется редко, например, при DDL-операциях (`ALTER`, `DROP`) или вручную через `LOCK TABLE`.
    
- **Блокировка строк (row-level locking)**  
    Это основной тип блокировки в PostgreSQL. Он позволяет разным транзакциям одновременно работать с одной таблицей, но с разными строками. Если две транзакции попытаются изменить одну и ту же строку, одна будет ждать, пока вторая завершится. Это обеспечивает точность и позволяет масштабировать нагрузку.

> Важно: PostgreSQL **не использует блокировку страниц**, в отличие от некоторых других СУБД. Он делает ставку именно на блокировку строк, что даёт гибкость и снижает вероятность конфликтов при массовом параллельном доступе.
### Как это работает на практике?

Когда вы обновляете строку:
```
BEGIN;

UPDATE products
SET stock = stock - 1
WHERE id = 42;
```
PostgreSQL ставит **эксклюзивную блокировку на эту строку**. Пока транзакция не завершится (`COMMIT` или `ROLLBACK`), другая транзакция, пытающаяся обновить ту же строку, будет ожидать.

Блокировки — это неотъемлемая часть транзакционной модели PostgreSQL. Они обеспечивают корректную параллельную работу с данными, предотвращая "гонки" и конфликтные изменения. Благодаря **блокировке на уровне строк**, PostgreSQL умеет балансировать между безопасностью и производительностью, позволяя множеству пользователей работать с одной таблицей без избыточных задержек.

### Создание транзакций в PostgreSQL

Представьте, что вы переводите 1000 долларов со своего сберегательного счёта на текущий. Если операция прервётся после списания, но до зачисления средств, это приведёт к потере денег — что, мягко говоря, неприятно. 

Чтобы исключить подобные ситуации, PostgreSQL позволяет использовать **транзакции** — механизм, который гарантирует, что либо **все** действия в рамках операции будут выполнены, либо **ни одно** из них не вступит в силу.

Когда вы инициируете перевод средств, приложение начинает транзакцию, выполняет SQL-запросы и в зависимости от результата:
- подтверждает изменения командой `COMMIT`, если всё прошло успешно;
    
- или отменяет все действия через `ROLLBACK`, если что-то пошло не так.
### Пример простой транзакции в PostgreSQL
```
BEGIN;

-- Проверка баланса отправителя
SELECT balance FROM accounts WHERE user_id = 1;

-- Списание и зачисление (предполагаем, что проверки прошли)
UPDATE accounts SET balance = balance - 1000 WHERE user_id = 1;
UPDATE accounts SET balance = balance + 1000 WHERE user_id = 2;

-- Подтверждение транзакции
COMMIT;
```

Если в процессе возникнет ошибка — например, у отправителя недостаточно средств, — можно выполнить:
```
ROLLBACK;
```

Это отменит все изменения, сделанные с момента начала транзакции.

### Явные транзакции

В PostgreSQL транзакции запускаются с помощью ключевого слова `BEGIN` (или `START TRANSACTION`, что по сути то же самое). Завершаются они одной из двух команд:
- `COMMIT` — применяет все изменения;
    
- `ROLLBACK` — отменяет всё, что было сделано с момента начала транзакции.

> Если соединение с сервером неожиданно прерывается (например, приложение аварийно завершилось), незавершённая транзакция будет автоматически откатана PostgreSQL при восстановлении.
### Точки сохранения (Savepoints)

Иногда может понадобиться отменить только часть операций внутри одной транзакции. В PostgreSQL для этого используются **точки сохранения** (`SAVEPOINT`). Это своего рода "контрольные точки", к которым можно откатиться, не отменяя всю транзакцию.

#### Пример:
```
BEGIN;

-- Устанавливаем точку сохранения перед изменением первого пользователя
SAVEPOINT before_user1;

UPDATE accounts SET balance = balance + 100 WHERE user_id = 1;

-- Допустим, бизнес-логика требует отмены этого действия
ROLLBACK TO SAVEPOINT before_user1;

-- Выполняем другое действие
UPDATE accounts SET balance = balance + 200 WHERE user_id = 2;

COMMIT;
```
- изменение для пользователя 1 откатывается;
    
- изменение для пользователя 2 сохраняется.
### Важные замечания
- Точки сохранения действуют только внутри текущей транзакции.
    
- `ROLLBACK TO SAVEPOINT` не завершает транзакцию — после него можно продолжить выполнять SQL-запросы.
    
- Если выполнить полный `ROLLBACK` без указания точки, откатятся **все** изменения и **все точки** будут потеряны.

