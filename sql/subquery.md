### Подзапросы в SQL (PostgreSQL)

**Подзапрос** — это запрос, вложенный внутрь другого SQL-запроса. Он используется для предварительного получения данных, которые затем применяются в основном запросе. Подзапрос заключается в круглые скобки `()` и может возвращать:
- одно значение (одна строка, один столбец),
    
- один столбец с несколькими строками,
    
- несколько строк и столбцов (таблицу).

Тип возвращаемого значения определяет, где и как можно использовать подзапрос — например, в `WHERE`, `FROM`, `SELECT` или `HAVING`.

Получим заказы, где сумма покупки равна самой большой
В базе данных `Orders` (из темы агрегатные функции), найдём все заказы с максимальной стоимостью покупки (кол-во × цена):

```
SELECT * FROM Orders
WHERE quantity * price = (
    SELECT MAX(quantity * price) FROM Orders
);
```
Подзапрос в `SELECT MAX(...)` сначала определяет максимальную сумму заказа, и только затем основной запрос выбирает все строки, соответствующие этой сумме.

## Скалярные подзапросы в PostgreSQL

**Скалярный подзапрос** — это подзапрос, который возвращает **ровно одну строку и один столбец**. Такое значение можно использовать как обычную константу: в `SELECT`, `WHERE`, `HAVING`, `ORDER BY`, а также в арифметических выражениях.

> ❗ Если подзапрос возвращает больше одной строки — PostgreSQL выдаст ошибку: `more than one row returned by a subquery used as an expression`.

### Получение одного значения

Допустим, у нас есть таблица `Employees`, и мы хотим получить имя того, кто первым устроился в компанию:

```
SELECT (
  SELECT full_name
  FROM Employees
  ORDER BY hire_date ASC
  LIMIT 1
) AS first_employee;
```
Этот запрос вернёт **имя самого первого сотрудника**, основываясь на дате приёма на работу.

### Фильтрация по значению из подзапроса

А теперь выберем полную информацию о сотруднике, устроившемся самым последним:
```
SELECT * FROM Employees
WHERE hire_date = (
  SELECT MAX(hire_date)
  FROM Employees
);
```
Здесь подзапрос `SELECT MAX(hire_date)` возвращает **одну дату**, и основной запрос подставляет это значение в `WHERE`, чтобы найти самого нового сотрудника.

### Важно помнить

Если вы случайно напишете подзапрос, возвращающий несколько строк (например, без `LIMIT 1` или `MAX()`), то попытка сравнения вида `=` или `<` вызовет ошибку. Например:
```
-- ❌ Ошибка: подзапрос может вернуть более одной строки
SELECT * FROM Employees
WHERE department_id = (
  SELECT department_id FROM Departments
);
```
В таких случаях нужно использовать `IN` или переписать подзапрос, чтобы он гарантированно возвращал одну строку.

### **Задание: Найти самого дорогого клиента**

В базе данных имеется таблица `Clients` со следующей структурой:
```
CREATE TABLE Clients (
    id SERIAL PRIMARY KEY,
    full_name TEXT NOT NULL,
    total_spent NUMERIC NOT NULL
);
```
**Требуется:**  
Напишите SQL-запрос, который выводит всю информацию о клиенте, потратившем наибольшую сумму. Используйте подзапрос, чтобы найти максимальное значение `total_spent`, и передайте его в основной запрос для фильтрации.



### Подзапросы, возвращающие несколько строк и один столбец

Когда подзапрос возвращает **несколько строк** и **один столбец**, нельзя использовать стандартные операторы сравнения, такие как `=`, `>`, `<`, без дополнительных уточнений. Однако SQL предоставляет **специальные операторы**, которые позволяют корректно работать с подобными подзапросами:
- `IN`
    
- `ANY` / `SOME`
    
- `ALL`
### Оператор `ALL`

С помощью оператора `ALL` можно сравнить отдельное значение с **каждым значением**, полученным из подзапроса. Условие вернёт `TRUE` **только если все сравнения вернут `TRUE`**.

Допустим, у нас есть таблица `Rooms`, и мы хотим выяснить, **есть ли хотя бы один номер, цена которого выше, чем у всех других**.

Вот как можно использовать `ALL` в таком случае:
```
SELECT * FROM Rooms
WHERE price > ALL (
    SELECT price FROM Rooms WHERE id != Rooms.id
);
```
Этот запрос вернёт **самый дорогой номер**, так как его цена будет выше всех остальных.  
Условие `id != Rooms.id` необходимо, чтобы не сравнивать строку с самой собой.

Получить список имён всех владельцев жилья
```
SELECT DISTINCT name FROM Users INNER JOIN Rooms
ON Users.id = Rooms.owner_id
```

Получить список идентификаторов всех пользователей, снимавших жилье
```
SELECT DISTINCT user_id FROM Reservations
```

Отфильтровать первый список всех владельцев по условию, что идентификатор владельца жилья не равен ни одному из идентификаторов пользователей, когда-либо снимавших жилье
```
SELECT DISTINCT name FROM Users INNER JOIN Rooms
    ON Users.id = Rooms.owner_id
    WHERE Users.id <> ALL (
        SELECT DISTINCT user_id FROM Reservations
    )
```

## Оператор IN

Оператор IN проверяет входит ли конкретное значение в набор значений. В качестве такого набора как раз может использоваться подзапрос, возвращающий несколько строк с одним столбцом.

Например, если нам необходимо получить всю информацию о владельцах жилья стоимостью больше 150 условных единиц, то это можно сделать следующим образом:
```
SELECT * FROM Users WHERE id IN (
    SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150
)
```

## Оператор ANY

Условное выражение с ANY имеет схожее поведение, но оно возвращает TRUE, если хотя бы одно сравнение отдельного значения со значением в наборе вернёт TRUE.

Давайте с его помощью напишем такой же запрос, что мы делали с оператором IN: найдём пользователей, которые владеют хотя бы 1 жилым помещением стоимостью более 150.
```
SELECT * FROM Users WHERE id = ANY (
    SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150
)
```

# Практика
на той же таблице с агрегатных функций необходимо:
1. **Оператор `IN`: Найти клиентов, которые заказывали товары из той же категории, что и "Alice"**
2. **Оператор `ANY`: Найти заказы с ценой выше, чем у любого заказа в категории 'Books'**
3. Оператор `ALL`: Найти клиентов, которые делали заказы дороже всех заказов из категории 'Clothing'


## Многостолбцовые подзапросы

Ранее мы рассматривали подзапросы, возвращающие только **один столбец**. Однако SQL также позволяет использовать **многостолбцовые подзапросы**, то есть те, которые возвращают **несколько столбцов и несколько строк**. Такие подзапросы часто применяются для **попарного сравнения** значений.
## Сравнение по нескольким столбцам: практический пример

Предположим, мы хотим найти все заказы, у которых одновременно совпадает и категория товара, и цена — с уже существующими комбинациями в таблице. То есть нас интересуют только такие строки, где **(product_category, price)** присутствуют в подмножестве уникальных сочетаний категорий и цен, уже имеющихся в заказах.

Это можно сделать с помощью многостолбцового подзапроса:
```
SELECT *
FROM Orders
WHERE (product_category, price) IN (
    SELECT DISTINCT product_category, price
    FROM Orders
);
```

Конечно, в этом случае результатом будет вся таблица, потому что мы сравниваем её саму с собой. Однако давай сделаем это полезным: найдем **все заказы, у которых совпадает сочетание категории и цены с заказами клиента 'Alice'**.
```
SELECT *
FROM Orders
WHERE (product_category, price) IN (
    SELECT DISTINCT product_category, price
    FROM Orders
    WHERE customer_name = 'Alice'
);
```
**Что делает этот запрос?**  
Он возвращает **все заказы любых клиентов**, у которых совпадают категория товара и цена с хотя бы одним заказом, сделанным Алисой.

## Альтернативный подход (без многостолбцового сравнения)

Этот же результат можно было бы получить и с помощью `JOIN`, но код при этом стал бы громоздким:
```
SELECT o.*
FROM Orders o
JOIN (
    SELECT DISTINCT product_category, price
    FROM Orders
    WHERE customer_name = 'Alice'
) AS a
ON o.product_category = a.product_category AND o.price = a.price;
```
Оба способа делают одно и то же — сравнивают сразу **две колонки**, но многостолбцовый подзапрос делает это более элегантно и читаемо.

### Коррелированные подзапросы

Ранее мы рассматривали только **некоррелированные подзапросы** — такие, которые можно выполнить отдельно от основного запроса, и результат подзапроса известен заранее.

**Коррелированные подзапросы** работают иначе: они ссылаются на поля из строк основного запроса и выполняются повторно для каждой такой строки.
#### Пример коррелированного подзапроса на основе таблицы Orders

Предположим, нам нужно узнать для каждого клиента сумму всех его заказов (суммарную стоимость).
```
SELECT customer_name,
    (
        SELECT SUM(quantity * price)
        FROM Orders o2
        WHERE o2.customer_name = o1.customer_name
    ) AS total_spent
FROM Orders o1
GROUP BY customer_name;
```
#### Важный момент по производительности

Коррелированные подзапросы выполняются **для каждой строки** основного запроса отдельно. Это может привести к значительному замедлению, если исходный набор данных большой. Поэтому стоит использовать их с осторожностью.

### Задача

Для каждого заказа вывести его `order_id`, `customer_name`, `order_date`, а также общую сумму всех заказов этого же клиента (то есть, сумма количества товаров, умноженного на цену, по всем заказам данного покупателя).

То есть, нужно получить детали каждого заказа и рядом с ними — сколько всего денег потратил этот клиент на все свои заказы.