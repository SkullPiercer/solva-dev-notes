1. Введение в Git
Git — это распределённая система контроля версий (VCS), которая помогает отслеживать изменения в коде, работать в команде и управлять версиями проекта.
Зачем нужен Git?
Позволяет хранить историю изменений кода.


Помогает работать над проектом командой без потери данных.


Дает возможность откатиться к предыдущим версиям кода.


Облегчает работу с различными версиями проекта через ветки.


Разница между Git и GitHub/GitLab
Git – инструмент для управления версиями на локальном компьютере.


GitHub/GitLab/Bitbucket – удалённые сервисы для хранения репозиториев и совместной работы.



2. Основные концепции
Терминология
Репозиторий – хранилище проекта с его историей изменений.


Коммит (commit) – сохранённое изменение кода.


Ветка (branch) – независимая линия разработки.


Рабочая директория (working directory) – текущие файлы проекта.


Индекс (staging area) – подготовленные к коммиту файлы.


Удалённый репозиторий (remote repository) – копия репозитория в сети (например, на GitLab).


3. Базовые команды
Создание и инициализация репозитория
# Создать новый локальный репозиторий
git init

# Клонировать существующий удаленный репозиторий
git clone https://github.com/user/repo.git

Commit

Допустим, нам надо выполнить задачу по добавлению текста.
Для этого мы создаем новую ветку от нашей master ветки, назовем ее test-commit. 

Далее вносим изменения в наш проект. 

Теперь нам нужно сохранить эти изменения. Чтобы посмотреть список измененных файлов, мы открываем вкладу Commit. Здесь мы видим наш измененный файл. Чтобы сделать коммит, нам надо добавить описание изменений и затем нажать на кнопку Commit. Теперь во вкладке Git при переходе на ветку test-commit, мы видим наш новый коммит с изменениями. 

Push

Далее, нам нужно отправить наши изменения в удаленный репозиторий. Для этого нам нужно воспользоваться командой git push. Мы можем либо написать ее в консоли git push origin test-commit, либо с помощью интерфейса IDE. Нажимаем Push. Теперь наша ветка с коммитом отправлена в удаленный репозиторий.

Amend Commit 

Допустим, во время выполнения задачи, вы забыли добавить какие-то изменения. Тогда мы, находясь в ветке с задачей, можем внести изменения. Но если мы опять нажмем кнопку Commit, то создадим новый коммит. Если же нам надо внести изменения в уже созданный commit, нам надо поставить галочку Amend, и затем уже нажать на кнопку Commit. В такой случае, наши изменения запишутся в последний коммит, перезаписав его. У каждого коммита есть уникальный хэш идентификатор, и если мы перезаписываем коммит, то этот идентификатор изменится на новый, так как технически это уже новый коммит.

Force Push

Теперь нам нужно снова отправить наши изменения на удаленный репозиторий. Кто скажет какую команду нам нужно выполнить? Если мы выполним git push, то получим ошибку, потому что локальная ветка, не соответствует ветке на сервере. Наш последний коммит изменился, изменился его хэш ключ, поэтому просто push нам теперь не поможет. Чтобы запушить нашу ветку, нам нужно использовать Force push. Он полностью перезаписывает ветку.
Если мы просто добавляем новый коммит в ветку, не меняя его структуру, либо предыдущие коммиты, то мы используем Push. Если мы меняем историю ветки, которая уже находится в удаленном репозитории, то используем Force Push.

Reset current branch to here

Рассмотрим следующую ситуацию. 
Мы выполняем задачу, в ходе которой делаем какое-то количество коммитов. 
Наша задача готова, и нам нужно оставить, только один коммит, со всеми изменениями. 
Для этого мы воспользуемся функцией Reset current branch to here. Что она делает? Она Удаляет все коммиты до выбранного нами, и в зависимости от выбранного свойства Soft или Hard либо удалит все изменения которые были в этих коммитах, либо оставит их. Если мы выбираем Soft, то мы удаляем все коммиты до выбранного, а изменения будут лежать в staging area. Далее мы можем создать коммит, который объединит все наши изменения и спокойно запушить. Если мы выбираем Hard, то мы удаляем не только коммиты до выбранного, но и все изменения в них. Это полезно, если мы просто хотим удалить какой-то коммит.

Squash commit

Еще один способ, для объединения коммитов - это Squash commit. С помощью него мы также можем объединить все выбранные коммиты в один, задать описание коммита.

Отличие между двумя этими подходами в том, что Squash commit применяется для объединения своих коммитов, то есть коммитов авторами которых являетесь вы. А Reset current branch to here для всех остальных случаев. То есть если вы используете Reset current branch to here, то вы можете объединить изменения с коммитом другого разработчика, с Squash commit так не получится, потому что будет создан новый коммит, автором которого будете вы.

Cherry-Pick
Рассмотрим следующую команду - Cherry-Pick. 
Она нужна в том случае, если мы хотим скопировать какие-то коммиты из одной ветки в другую.
Например, мы создаем новую ветку test-cherry-pick для задачи от master, сейчас структура ветки идентична ветке мастер. 
А нам надо взять один или несколько коммитов из другой ветки, например ветки другого разработчика. 
Для этого во вкладке Git, мы переходим на в remote branch которая нам нужна, local - это ветки которые находятся у нас локально на нашем компьютере, а remote - это ветки которые лежат в удаленном репозитории. 
Ищем ветку origin => test-commit, выбираем один или несколько коммитов, которые хотим скопировать и нажимаем кнопку cherry-pick. 
Видим сообщение cherry-pick successful, значит копирование завершено успешно. Теперь возвращаемся на свою ветку, и видим скопированный коммит. Мы скопировали содержимое и название коммита, но фактически это разные коммиты с разными хеш ключами. 
Также нужно быть внимательным с тем, что вы копируете. Прежде чем копировать коммит, убедитесь что коммит который вы копируете не связан с предыдущим коммитом, который вы не копируете, иначе вы получите проблему, которую будет сложно решить, и проще будет написать все с нуля.

Rebase

Rebase - это операция приведения ветки в актуальное состояние с базовой веткой. То есть эта операция позволяет нам обновить ветку в которой мы работали, от той, от которой мы отбранчевались. Рассмотрим на примере:

У нас есть ветка test-first-commit от которой мы создаем новую ветку под свою задачу test-second-commit. Мы вносим какие-то изменения. Внесли, сохранили. Теперь хотим сделать Merge Request наших изменений в родительскую ветку. 
Но в то время пока мы работали над задачей, другие разработчики уже внесли свои изменения в нашу родительскую ветку. Итак, мы пушим нашу ветку, создаем MR. И видим конфликты, которые не позволяют влить наш MR в родительскую ветку. 
Тут нам и пригодится rebase. 

Переходим в IDE, и нажимаем на ветку, от которой нам нужно актуализировать свою ветку, у нас появляется модальное окно, которое предлагает решить конфликты.
Здесь мы видим список файлов в которых есть конфликты, справа кнопка Accept Yours, что значит применить изменения из твоей ветки, Accept Theirs - применить изменения из ветки от которой мы делаем rebase, и Merge - то есть слить все изменения, но мы ей никогда не пользуемся, потому что у нас для этого существуют MR. Вообще не стоит пользоваться ни одной из этих кнопок. Мы просто открываем каждый файл, смотрим, слева находятся изменения которые были внесены в вашей ветке, справа изменения из ветки от которой делаем rebase. Посередине окно результата. После того как мы решили все конфликты, нажимаем Apply, и Continue rebase. Теперь в нашей рабочей ветке есть все изменения из родительской, и мы можем ее запушить. Теперь конфликтов в MR быть не должно и после апрува мы можем смержить наш MR.

Fetch, Pull

Для подгрузки актуальных изменений из удаленного репозитория, у нас есть две команды - git fetch, git pull.

Fetch - загружает все изменения из удаленного репозитория в remote папку. Просто загружает и все.

Pull - загружает все изменения из удаленного репозитория как и fetch, но еще и мержит изменения (если они есть) в ветку, в которой вы находитесь. Только в ветку в которой вы находитесь сейчас.
Отслеживание изменений

# Добавить файлы в индекс (подготовка к коммиту)
git add file.txt  # Один файл
git add .         # Все файлы

# Сделать коммит
git commit -m "Описание изменений"


4. Продвинутые команды
Изменение последнего коммита
git commit --amend -m "Новое описание коммита"

Важно! amend меняет историю, не используйте её после push.
Отправка изменений в удалённый репозиторий
# Обычный push
git push origin main

# Принудительный push (перезапишет историю)
git push --force
Получение изменений
# Обновить информацию об удалённом репозитории без изменения локальных файлов
git fetch

# Забрать изменения и объединить их с текущей веткой
git pull

Откат изменений
# Откатиться на один коммит назад (с сохранением изменений в файлах)
git reset HEAD~1

# Полный откат до конкретного коммита (удалит изменения!)
git reset --hard abc1234


Ссылки для самостоятельного изучения:
Основы Git
Git: советы новичкам – часть 1
Введение в Git: от установки до основных команд
Git за полчаса: руководство для начинающих
